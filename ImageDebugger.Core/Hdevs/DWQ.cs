//
// File generated by HDevelop for HALCON/.NET (C#) Version 18.11.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
  public HDevelopExport()
  {
    // Default settings used in HDevelop
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    if (HalconAPI.isWindows)
      HOperatorSet.SetSystem("use_window_thread","true");
    action();
  }
#endif

  // Procedures 
  // Chapter: Matching / Shape-Based
  // Short Description: Display the results of Shape-Based Matching. 
  public void dev_display_shape_matching_results (HTuple hv_ModelID, HTuple hv_Color, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC, 
      HTuple hv_Model)
  {



        // Local iconic variables 

        HObject ho_ModelContours=null, ho_ContoursAffinTrans=null;

        // Local control variables 

        HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Match = new HTuple(), hv_HomMat2DIdentity = new HTuple();
        HTuple hv_HomMat2DScale = new HTuple(), hv_HomMat2DRotate = new HTuple();
        HTuple hv_HomMat2DTranslate = new HTuple();
        HTuple   hv_Model_COPY_INP_TMP = new HTuple(hv_Model);
        HTuple   hv_ScaleC_COPY_INP_TMP = new HTuple(hv_ScaleC);
        HTuple   hv_ScaleR_COPY_INP_TMP = new HTuple(hv_ScaleR);

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffinTrans);
    //This procedure displays the results of Shape-Based Matching.
    //
    hv_NumMatches.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumMatches = new HTuple(hv_Row.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple((new HTuple(hv_ScaleR_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleR_COPY_INP_TMP, out ExpTmpOutVar_0);
        hv_ScaleR_COPY_INP_TMP.Dispose();
        hv_ScaleR_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      if ((int)(new HTuple((new HTuple(hv_ScaleC_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleC_COPY_INP_TMP, out ExpTmpOutVar_0);
        hv_ScaleC_COPY_INP_TMP.Dispose();
        hv_ScaleC_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        hv_Model_COPY_INP_TMP.Dispose();
        HOperatorSet.TupleGenConst(hv_NumMatches, 0, out hv_Model_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleGenConst(hv_NumMatches, hv_Model_COPY_INP_TMP, out ExpTmpOutVar_0);
        hv_Model_COPY_INP_TMP.Dispose();
        hv_Model_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ModelID.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ModelContours.Dispose();
        HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelID.TupleSelect(
            hv_Index), 1);
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
              hv_Index%(new HTuple(hv_Color.TupleLength()))));
          }
        }
        HTuple end_val18 = hv_NumMatches-1;
        HTuple step_val18 = 1;
        for (hv_Match=0; hv_Match.Continue(end_val18, step_val18); hv_Match = hv_Match.TupleAdd(step_val18))
        {
          if ((int)(new HTuple(hv_Index.TupleEqual(hv_Model_COPY_INP_TMP.TupleSelect(
              hv_Match)))) != 0)
          {
            hv_HomMat2DIdentity.Dispose();
            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DScale.Dispose();
            HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_ScaleR_COPY_INP_TMP.TupleSelect(
                hv_Match), hv_ScaleC_COPY_INP_TMP.TupleSelect(hv_Match), 0, 0, out hv_HomMat2DScale);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DRotate.Dispose();
            HOperatorSet.HomMat2dRotate(hv_HomMat2DScale, hv_Angle.TupleSelect(hv_Match), 
                0, 0, out hv_HomMat2DRotate);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DTranslate.Dispose();
            HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row.TupleSelect(
                hv_Match), hv_Column.TupleSelect(hv_Match), out hv_HomMat2DTranslate);
            }
            ho_ContoursAffinTrans.Dispose();
            HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffinTrans, 
                hv_HomMat2DTranslate);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ContoursAffinTrans, HDevWindowStack.GetActive()
                  );
            }
          }
        }
      }
    }
    ho_ModelContours.Dispose();
    ho_ContoursAffinTrans.Dispose();

    hv_Model_COPY_INP_TMP.Dispose();
    hv_ScaleC_COPY_INP_TMP.Dispose();
    hv_ScaleR_COPY_INP_TMP.Dispose();
    hv_NumMatches.Dispose();
    hv_Index.Dispose();
    hv_Match.Dispose();
    hv_HomMat2DIdentity.Dispose();
    hv_HomMat2DScale.Dispose();
    hv_HomMat2DRotate.Dispose();
    hv_HomMat2DTranslate.Dispose();

    return;
  }

  // Local procedures 
  public void analyze_coordinate (HTuple hv_Input_x, HTuple hv_Input_y, HTuple hv_Phi, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_sx, HTuple hv_sy, out HTuple hv_Output_x, 
      out HTuple hv_Output_y)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_x = new HTuple(), hv_y = new HTuple();
    HTuple hv_a = new HTuple(), hv_b = new HTuple(), hv_deta_y = new HTuple();
    HTuple hv_deta_x = new HTuple();
    // Initialize local and output iconic variables 
    hv_Output_x = new HTuple();
    hv_Output_y = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_x.Dispose();
    HOperatorSet.TupleAbs(hv_Input_x*1000, out hv_x);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_y.Dispose();
    HOperatorSet.TupleAbs(hv_Input_y*1000, out hv_y);
    }
    //x轴像素当量即colum方向
    hv_a.Dispose();
    hv_a = new HTuple(hv_sx);
    //y轴像素当量即Row方向
    hv_b.Dispose();
    hv_b = new HTuple(hv_sy);
    if ((int)(new HTuple(hv_Phi.TupleGreaterEqual(0))) != 0)
    {
      //C平移延x轴移动距离
      hv_deta_y.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_deta_y = ((hv_y*(hv_Phi.TupleCos()
          ))-(hv_x*(hv_Phi.TupleSin())))/hv_b;
      }
      //C平移延y轴移动距离
      hv_deta_x.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_deta_x = (((hv_y*(hv_Phi.TupleSin()
          ))-((hv_x*(hv_Phi.TupleTan()))*(hv_Phi.TupleSin())))+(hv_x/(hv_Phi.TupleCos()
          )))/hv_a;
      }
    }
    if ((int)(new HTuple(hv_Phi.TupleLess(0))) != 0)
    {
      //C,B平移延y轴移动像素距离
      hv_deta_y.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_deta_y = (((hv_y/(hv_Phi.TupleCos()
          ))+(hv_x*(hv_Phi.TupleSin())))-((hv_y*(hv_Phi.TupleSin()))*(hv_Phi.TupleTan()
          )))/hv_b;
      }
      //C,B平移延x轴移动像素距离
      hv_deta_x.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_deta_x = ((hv_x*(hv_Phi.TupleCos()
          ))-(hv_y*(hv_Phi.TupleSin())))/hv_a;
      }
    }
    //8个点的像素坐标，2位y方向补偿
    hv_Output_x.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Output_x = (hv_Column-hv_deta_x)-4;
    }
    hv_Output_y.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Output_y = (hv_Row-hv_deta_y)-4;
    }

    hv_x.Dispose();
    hv_y.Dispose();
    hv_a.Dispose();
    hv_b.Dispose();
    hv_deta_y.Dispose();
    hv_deta_x.Dispose();

    return;
  }

  public void analyze_flatness (HTuple hv_xs, HTuple hv_ys, HTuple hv_zs, HTuple hv_x, 
      HTuple hv_y, HTuple hv_z, out HTuple hv_flatness, out HTuple hv_distance)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_X = new HTuple(), hv_Y = new HTuple();
    HTuple hv_Z = new HTuple(), hv_ObjectModel3D = new HTuple();
    HTuple hv_ParFitting = new HTuple(), hv_ValFitting = new HTuple();
    HTuple hv_ObjectModel3DOutID = new HTuple(), hv_primitive_parameter = new HTuple();
    HTuple hv_center = new HTuple(), hv_a = new HTuple(), hv_b = new HTuple();
    HTuple hv_c = new HTuple(), hv_d = new HTuple(), hv_minD = new HTuple();
    HTuple hv_maxD = new HTuple(), hv_i = new HTuple(), hv_D = new HTuple();
    HTuple hv_X1 = new HTuple(), hv_Y1 = new HTuple(), hv_Z1 = new HTuple();
    HTuple hv_d1 = new HTuple(), hv_d2 = new HTuple();
    // Initialize local and output iconic variables 
    hv_flatness = new HTuple();
    hv_distance = new HTuple();
    //平整度测量
    //3D坐标
    hv_X.Dispose();
    hv_X = new HTuple(hv_xs);
    hv_Y.Dispose();
    hv_Y = new HTuple(hv_ys);
    hv_Z.Dispose();
    hv_Z = new HTuple(hv_zs);
    //3D坐标转化为3D模型
    hv_ObjectModel3D.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_X, hv_Y, hv_Z, out hv_ObjectModel3D);
    //3D模型拟合成平面
    hv_ParFitting.Dispose();
    hv_ParFitting = new HTuple();
    hv_ParFitting[0] = "primitive_type";
    hv_ParFitting[1] = "fitting_algorithm";
    hv_ParFitting[2] = "output_xyz_mapping";
    hv_ValFitting.Dispose();
    hv_ValFitting = new HTuple();
    hv_ValFitting[0] = "plane";
    hv_ValFitting[1] = "least_squares";
    hv_ValFitting[2] = "true";
    //Apply the fitting
    hv_ObjectModel3DOutID.Dispose();
    HOperatorSet.FitPrimitivesObjectModel3d(hv_ObjectModel3D, hv_ParFitting, hv_ValFitting, 
        out hv_ObjectModel3DOutID);
    //获取拟合参数（法向量，平面中心一点）
    hv_primitive_parameter.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DOutID, "primitive_parameter", 
        out hv_primitive_parameter);
    hv_center.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DOutID, "center", out hv_center);
    //计算平面方程(a,b,c,d)
    hv_a.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_a = hv_primitive_parameter.TupleSelect(
        0);
    }
    hv_b.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_b = hv_primitive_parameter.TupleSelect(
        1);
    }
    hv_c.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_c = hv_primitive_parameter.TupleSelect(
        2);
    }
    hv_d.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_d = (((-1*(hv_center.TupleSelect(
        0)))*hv_a)-((hv_center.TupleSelect(1))*hv_b))-((hv_center.TupleSelect(2))*(hv_primitive_parameter.TupleSelect(
        2)));
    }
    //平面度计算
    hv_minD.Dispose();
    hv_minD = 9999;
    hv_maxD.Dispose();
    hv_maxD = -9999;
    for (hv_i=0; (int)hv_i<=(int)((new HTuple(hv_X.TupleLength()))-1); hv_i = (int)hv_i + 1)
    {
      hv_D.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_D = (((hv_a*(hv_X.TupleSelect(
          hv_i)))+(hv_b*(hv_Y.TupleSelect(hv_i))))+(hv_c*(hv_Z.TupleSelect(hv_i))))+hv_d;
      }
      if ((int)(new HTuple(hv_minD.TupleGreater(hv_D))) != 0)
      {
        hv_minD.Dispose();
        hv_minD = new HTuple(hv_D);
      }
      if ((int)(new HTuple(hv_maxD.TupleLess(hv_D))) != 0)
      {
        hv_maxD.Dispose();
        hv_maxD = new HTuple(hv_D);
      }
    }
    hv_flatness.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_flatness = (hv_maxD-hv_minD)/1000;
    }
    //点到平面距离
    hv_X1.Dispose();
    hv_X1 = new HTuple(hv_x);
    hv_Y1.Dispose();
    hv_Y1 = new HTuple(hv_y);
    hv_Z1.Dispose();
    hv_Z1 = new HTuple(hv_z);
    hv_d1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_d1 = ((hv_a*hv_a)+(hv_b*hv_b))+(hv_c*hv_c);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_d2.Dispose();
    HOperatorSet.TupleAbs((((hv_a*hv_X1)+(hv_b*hv_Y1))+(hv_c*hv_Z1))+hv_d, out hv_d2);
    }

    hv_distance.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_distance = (hv_d2/hv_d1)/1000;
    }

    hv_X.Dispose();
    hv_Y.Dispose();
    hv_Z.Dispose();
    hv_ObjectModel3D.Dispose();
    hv_ParFitting.Dispose();
    hv_ValFitting.Dispose();
    hv_ObjectModel3DOutID.Dispose();
    hv_primitive_parameter.Dispose();
    hv_center.Dispose();
    hv_a.Dispose();
    hv_b.Dispose();
    hv_c.Dispose();
    hv_d.Dispose();
    hv_minD.Dispose();
    hv_maxD.Dispose();
    hv_i.Dispose();
    hv_D.Dispose();
    hv_X1.Dispose();
    hv_Y1.Dispose();
    hv_Z1.Dispose();
    hv_d1.Dispose();
    hv_d2.Dispose();

    return;
  }

  public void gen_B_line (HObject ho_Image, out HObject ho_OrginLineB, HTuple hv_RowL, 
      HTuple hv_ColumnL, out HTuple hv_RowBeginB, out HTuple hv_ColBeginB, out HTuple hv_RowEndB, 
      out HTuple hv_ColEndB)
  {




    // Local iconic variables 

    HObject ho_ROI_B, ho_ImageReducedB, ho_RegionB;
    HObject ho_RegionBlosing2, ho_RegionBorderB, ho_ContourBs;
    HObject ho_ContourBsSplit, ho_SelectedContourBs, ho_UnionContourBs;
    HObject ho_SelectedContours, ho_SortedContourBs, ho_ObjectSelectedB;

    // Local control variables 

    HTuple hv_Number = new HTuple(), hv_NrC = new HTuple();
    HTuple hv_NcC = new HTuple(), hv_DistC = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_OrginLineB);
    HOperatorSet.GenEmptyObj(out ho_ROI_B);
    HOperatorSet.GenEmptyObj(out ho_ImageReducedB);
    HOperatorSet.GenEmptyObj(out ho_RegionB);
    HOperatorSet.GenEmptyObj(out ho_RegionBlosing2);
    HOperatorSet.GenEmptyObj(out ho_RegionBorderB);
    HOperatorSet.GenEmptyObj(out ho_ContourBs);
    HOperatorSet.GenEmptyObj(out ho_ContourBsSplit);
    HOperatorSet.GenEmptyObj(out ho_SelectedContourBs);
    HOperatorSet.GenEmptyObj(out ho_UnionContourBs);
    HOperatorSet.GenEmptyObj(out ho_SelectedContours);
    HOperatorSet.GenEmptyObj(out ho_SortedContourBs);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelectedB);
    hv_RowBeginB = new HTuple();
    hv_ColBeginB = new HTuple();
    hv_RowEndB = new HTuple();
    hv_ColEndB = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ROI_B.Dispose();
    HOperatorSet.GenRectangle1(out ho_ROI_B, hv_RowL+520, hv_ColumnL-800, hv_RowL+560, 
        hv_ColumnL-100);
    }
    ho_ImageReducedB.Dispose();
    HOperatorSet.ReduceDomain(ho_Image, ho_ROI_B, out ho_ImageReducedB);
    ho_RegionB.Dispose();
    HOperatorSet.Threshold(ho_ImageReducedB, out ho_RegionB, -2200, -1800);
    ho_RegionBlosing2.Dispose();
    HOperatorSet.ClosingRectangle1(ho_RegionB, out ho_RegionBlosing2, 35, 1);
    ho_RegionBorderB.Dispose();
    HOperatorSet.Boundary(ho_RegionBlosing2, out ho_RegionBorderB, "inner");
    ho_ContourBs.Dispose();
    HOperatorSet.GenContourRegionXld(ho_RegionBorderB, out ho_ContourBs, "border");
    ho_ContourBsSplit.Dispose();
    HOperatorSet.SegmentContoursXld(ho_ContourBs, out ho_ContourBsSplit, "lines", 
        5, 1, 1);
    ho_SelectedContourBs.Dispose();
    HOperatorSet.SelectContoursXld(ho_ContourBsSplit, out ho_SelectedContourBs, "contour_length", 
        15, 2000, -0.5, 0.5);
    ho_UnionContourBs.Dispose();
    HOperatorSet.UnionCollinearContoursXld(ho_SelectedContourBs, out ho_UnionContourBs, 
        100, 5, 5, 0.5, "attr_keep");
    ho_SelectedContours.Dispose();
    HOperatorSet.SelectContoursXld(ho_UnionContourBs, out ho_SelectedContours, "contour_length", 
        50, 2000, -0.5, 0.5);
    ho_SortedContourBs.Dispose();
    HOperatorSet.SortContoursXld(ho_SelectedContours, out ho_SortedContourBs, "character", 
        "true", "column");
    hv_Number.Dispose();
    HOperatorSet.CountObj(ho_SortedContourBs, out hv_Number);
    ho_ObjectSelectedB.Dispose();
    HOperatorSet.SelectObj(ho_SortedContourBs, out ho_ObjectSelectedB, hv_Number);
    hv_RowBeginB.Dispose();hv_ColBeginB.Dispose();hv_RowEndB.Dispose();hv_ColEndB.Dispose();hv_NrC.Dispose();hv_NcC.Dispose();hv_DistC.Dispose();
    HOperatorSet.FitLineContourXld(ho_ObjectSelectedB, "drop", -1, 0, 5, 1, out hv_RowBeginB, 
        out hv_ColBeginB, out hv_RowEndB, out hv_ColEndB, out hv_NrC, out hv_NcC, 
        out hv_DistC);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_OrginLineB.Dispose();
    HOperatorSet.GenContourPolygonXld(out ho_OrginLineB, hv_RowBeginB.TupleConcat(
        hv_RowEndB), hv_ColBeginB.TupleConcat(hv_ColEndB));
    }
    ho_ROI_B.Dispose();
    ho_ImageReducedB.Dispose();
    ho_RegionB.Dispose();
    ho_RegionBlosing2.Dispose();
    ho_RegionBorderB.Dispose();
    ho_ContourBs.Dispose();
    ho_ContourBsSplit.Dispose();
    ho_SelectedContourBs.Dispose();
    ho_UnionContourBs.Dispose();
    ho_SelectedContours.Dispose();
    ho_SortedContourBs.Dispose();
    ho_ObjectSelectedB.Dispose();

    hv_Number.Dispose();
    hv_NrC.Dispose();
    hv_NcC.Dispose();
    hv_DistC.Dispose();

    return;
  }

  public void get_C_line (HObject ho_Image, out HObject ho_OrginLineC, HTuple hv_RowL, 
      HTuple hv_ColumnL, out HTuple hv_RowBeginC, out HTuple hv_ColBeginC, out HTuple hv_RowEndC, 
      out HTuple hv_ColEndC)
  {




    // Local iconic variables 

    HObject ho_ROI_C, ho_ImageReducedC, ho_RegionC;
    HObject ho_RegionClosing2, ho_RegionOpening, ho_ConnectedRegions;
    HObject ho_SelectedRegions, ho_RegionBorderC, ho_ContourCs;
    HObject ho_ContourCsSplit, ho_SelectedContourCs, ho_UnionContourCs;
    HObject ho_SortedContourCs, ho_ObjectSelectedC, ho_UnionContours1;

    // Local control variables 

    HTuple hv_NrC = new HTuple(), hv_NcC = new HTuple();
    HTuple hv_DistC = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_OrginLineC);
    HOperatorSet.GenEmptyObj(out ho_ROI_C);
    HOperatorSet.GenEmptyObj(out ho_ImageReducedC);
    HOperatorSet.GenEmptyObj(out ho_RegionC);
    HOperatorSet.GenEmptyObj(out ho_RegionClosing2);
    HOperatorSet.GenEmptyObj(out ho_RegionOpening);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
    HOperatorSet.GenEmptyObj(out ho_RegionBorderC);
    HOperatorSet.GenEmptyObj(out ho_ContourCs);
    HOperatorSet.GenEmptyObj(out ho_ContourCsSplit);
    HOperatorSet.GenEmptyObj(out ho_SelectedContourCs);
    HOperatorSet.GenEmptyObj(out ho_UnionContourCs);
    HOperatorSet.GenEmptyObj(out ho_SortedContourCs);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelectedC);
    HOperatorSet.GenEmptyObj(out ho_UnionContours1);
    hv_RowBeginC = new HTuple();
    hv_ColBeginC = new HTuple();
    hv_RowEndC = new HTuple();
    hv_ColEndC = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ROI_C.Dispose();
    HOperatorSet.GenRectangle1(out ho_ROI_C, hv_RowL-270, hv_ColumnL+925, hv_RowL+270, 
        hv_ColumnL+955);
    }
    ho_ImageReducedC.Dispose();
    HOperatorSet.ReduceDomain(ho_Image, ho_ROI_C, out ho_ImageReducedC);
    ho_RegionC.Dispose();
    HOperatorSet.Threshold(ho_ImageReducedC, out ho_RegionC, -2200, -600);
    ho_RegionClosing2.Dispose();
    HOperatorSet.ClosingRectangle1(ho_RegionC, out ho_RegionClosing2, 1, 5);
    ho_RegionOpening.Dispose();
    HOperatorSet.OpeningRectangle1(ho_RegionClosing2, out ho_RegionOpening, 2, 10);
    ho_ConnectedRegions.Dispose();
    HOperatorSet.Connection(ho_RegionOpening, out ho_ConnectedRegions);
    ho_SelectedRegions.Dispose();
    HOperatorSet.SelectShapeStd(ho_ConnectedRegions, out ho_SelectedRegions, "max_area", 
        70);
    ho_RegionBorderC.Dispose();
    HOperatorSet.Boundary(ho_SelectedRegions, out ho_RegionBorderC, "inner");
    ho_ContourCs.Dispose();
    HOperatorSet.GenContourRegionXld(ho_RegionBorderC, out ho_ContourCs, "border");
    ho_ContourCsSplit.Dispose();
    HOperatorSet.SegmentContoursXld(ho_ContourCs, out ho_ContourCsSplit, "lines", 
        5, 1, 1);
    ho_SelectedContourCs.Dispose();
    HOperatorSet.SelectContoursXld(ho_ContourCsSplit, out ho_SelectedContourCs, "contour_length", 
        20, 2000, -0.5, 0.5);
    ho_UnionContourCs.Dispose();
    HOperatorSet.UnionCollinearContoursXld(ho_SelectedContourCs, out ho_UnionContourCs, 
        100, 10, 10, 0.5, "attr_keep");
    ho_SelectedContourCs.Dispose();
    HOperatorSet.SelectContoursXld(ho_UnionContourCs, out ho_SelectedContourCs, "contour_length", 
        50, 2000, -0.5, 0.5);
    ho_SortedContourCs.Dispose();
    HOperatorSet.SortContoursXld(ho_SelectedContourCs, out ho_SortedContourCs, "character", 
        "true", "row");
    ho_ObjectSelectedC.Dispose();
    HOperatorSet.SelectObj(ho_SortedContourCs, out ho_ObjectSelectedC, 2);
    ho_UnionContours1.Dispose();
    HOperatorSet.UnionCollinearContoursXld(ho_ObjectSelectedC, out ho_UnionContours1, 
        1000, 20, 20, 0.5, "attr_keep");
    hv_RowBeginC.Dispose();hv_ColBeginC.Dispose();hv_RowEndC.Dispose();hv_ColEndC.Dispose();hv_NrC.Dispose();hv_NcC.Dispose();hv_DistC.Dispose();
    HOperatorSet.FitLineContourXld(ho_UnionContours1, "drop", -1, 0, 5, 1, out hv_RowBeginC, 
        out hv_ColBeginC, out hv_RowEndC, out hv_ColEndC, out hv_NrC, out hv_NcC, 
        out hv_DistC);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_OrginLineC.Dispose();
    HOperatorSet.GenContourPolygonXld(out ho_OrginLineC, hv_RowBeginC.TupleConcat(
        hv_RowEndC), hv_ColBeginC.TupleConcat(hv_ColEndC));
    }
    ho_ROI_C.Dispose();
    ho_ImageReducedC.Dispose();
    ho_RegionC.Dispose();
    ho_RegionClosing2.Dispose();
    ho_RegionOpening.Dispose();
    ho_ConnectedRegions.Dispose();
    ho_SelectedRegions.Dispose();
    ho_RegionBorderC.Dispose();
    ho_ContourCs.Dispose();
    ho_ContourCsSplit.Dispose();
    ho_SelectedContourCs.Dispose();
    ho_UnionContourCs.Dispose();
    ho_SortedContourCs.Dispose();
    ho_ObjectSelectedC.Dispose();
    ho_UnionContours1.Dispose();

    hv_NrC.Dispose();
    hv_NcC.Dispose();
    hv_DistC.Dispose();

    return;
  }

  public void get_ImageB (HObject ho_ProfileImageBW, out HObject ho_ImageNewB, out HObject ho_ImageBWToByte)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImageBWConverted, ho_ImageBWScaled;
    HObject ho_ImageNewBWConvert;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageNewB);
    HOperatorSet.GenEmptyObj(out ho_ImageBWToByte);
    HOperatorSet.GenEmptyObj(out ho_ImageBWConverted);
    HOperatorSet.GenEmptyObj(out ho_ImageBWScaled);
    HOperatorSet.GenEmptyObj(out ho_ImageNewBWConvert);
    ho_ImageBWConverted.Dispose();
    HOperatorSet.ConvertImageType(ho_ProfileImageBW, out ho_ImageBWConverted, "int4");
    ho_ImageBWScaled.Dispose();
    HOperatorSet.ScaleImage(ho_ImageBWConverted, out ho_ImageBWScaled, 1, -32768);
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ScaleImage(ho_ImageBWScaled, out ExpTmpOutVar_0, 1.6, 0);
    ho_ImageBWScaled.Dispose();
    ho_ImageBWScaled = ExpTmpOutVar_0;
    }
    //get_image_size (ImageBWScaled, WidthB, HeightB)
    //gen_image_const (ImageNewTempBW, 'int4', WidthB, HeightB)
    //for Index := 0 to HeightB-1 by 1
      //get_grayval (ImageBWScaled, gen_tuple_const(WidthB,Index), [0:WidthB-1], grayValueBefore)
      //grayValue := grayValueBefore[0:WidthB-1]-([0:WidthB-1]*kB+bB)
      //set_grayval (ImageNewTempBW, gen_tuple_const(WidthB,Index), [0:WidthB-1], grayValue)
    //endfor
    //mirror_image (ImageBWScaled, ImageNewBWMirror, 'column')
    ho_ImageNewBWConvert.Dispose();
    HOperatorSet.ConvertImageType(ho_ImageBWScaled, out ho_ImageNewBWConvert, "int2");
    ho_ImageNewB.Dispose();
    HOperatorSet.RotateImage(ho_ImageNewBWConvert, out ho_ImageNewB, 90, "constant");

    ho_ImageBWConverted.Dispose();
    HOperatorSet.ConvertImageType(ho_ProfileImageBW, out ho_ImageBWConverted, "byte");
    //mirror_image (ProfileImageBW, ImageBWMirror, 'column')
    ho_ImageBWToByte.Dispose();
    HOperatorSet.RotateImage(ho_ImageBWConverted, out ho_ImageBWToByte, 90, "constant");

    ho_ImageBWConverted.Dispose();
    ho_ImageBWScaled.Dispose();
    ho_ImageNewBWConvert.Dispose();


    return;
  }

  public void get_ImageTL (HObject ho_ProfileImageTLW, out HObject ho_ImageNewTLW, 
      out HObject ho_ImageTLWToByte)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImageTLWConverted, ho_ImageTLWScaled;
    HObject ho_ImageNewTLWMirror, ho_ImageNewTLWConvert, ho_ImageTLWMirror;
    HObject ho_ImageRotateTLW;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageNewTLW);
    HOperatorSet.GenEmptyObj(out ho_ImageTLWToByte);
    HOperatorSet.GenEmptyObj(out ho_ImageTLWConverted);
    HOperatorSet.GenEmptyObj(out ho_ImageTLWScaled);
    HOperatorSet.GenEmptyObj(out ho_ImageNewTLWMirror);
    HOperatorSet.GenEmptyObj(out ho_ImageNewTLWConvert);
    HOperatorSet.GenEmptyObj(out ho_ImageTLWMirror);
    HOperatorSet.GenEmptyObj(out ho_ImageRotateTLW);
    ho_ImageTLWConverted.Dispose();
    HOperatorSet.ConvertImageType(ho_ProfileImageTLW, out ho_ImageTLWConverted, "int4");
    ho_ImageTLWScaled.Dispose();
    HOperatorSet.ScaleImage(ho_ImageTLWConverted, out ho_ImageTLWScaled, 1, -32768);
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ScaleImage(ho_ImageTLWScaled, out ExpTmpOutVar_0, 1.6, 0);
    ho_ImageTLWScaled.Dispose();
    ho_ImageTLWScaled = ExpTmpOutVar_0;
    }
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ScaleImage(ho_ImageTLWScaled, out ExpTmpOutVar_0, 1, 0);
    ho_ImageTLWScaled.Dispose();
    ho_ImageTLWScaled = ExpTmpOutVar_0;
    }
    //get_image_size (ImageTLWScaled, WidthPITLW, HeightPITLW)
    //gen_image_const (ImageNewTempTLW, 'int4', WidthPITLW, HeightPITLW)
    //for Index := 0 to HeightPITLW-1 by 1
      //get_grayval (ImageTLWScaled, gen_tuple_const(WidthPITLW,Index), [0:WidthPITLW-1], grayValuePITLWBefore)
      //grayValuePITLW := grayValuePITLWBefore[0:WidthPITLW-1]-([0:WidthPITLW-1]*kTL+bTL)
      //set_grayval (ImageNewTempTLW, gen_tuple_const(WidthPITLW,Index), [0:WidthPITLW-1], grayValuePITLW)
    //endfor
    ho_ImageNewTLWMirror.Dispose();
    HOperatorSet.MirrorImage(ho_ImageTLWScaled, out ho_ImageNewTLWMirror, "column");
    ho_ImageNewTLWConvert.Dispose();
    HOperatorSet.ConvertImageType(ho_ImageNewTLWMirror, out ho_ImageNewTLWConvert, 
        "int2");
    ho_ImageNewTLW.Dispose();
    HOperatorSet.RotateImage(ho_ImageNewTLWConvert, out ho_ImageNewTLW, 90, "constant");

    ho_ImageTLWMirror.Dispose();
    HOperatorSet.MirrorImage(ho_ProfileImageTLW, out ho_ImageTLWMirror, "column");
    ho_ImageRotateTLW.Dispose();
    HOperatorSet.RotateImage(ho_ImageTLWMirror, out ho_ImageRotateTLW, 90, "constant");
    ho_ImageTLWToByte.Dispose();
    HOperatorSet.ConvertImageType(ho_ImageRotateTLW, out ho_ImageTLWToByte, "byte");

    ho_ImageTLWConverted.Dispose();
    ho_ImageTLWScaled.Dispose();
    ho_ImageNewTLWMirror.Dispose();
    ho_ImageNewTLWConvert.Dispose();
    ho_ImageTLWMirror.Dispose();
    ho_ImageRotateTLW.Dispose();


    return;
  }

  public void get_ImageTR (HObject ho_ProfileImageTRW, out HObject ho_ImageNewTRW, 
      out HObject ho_ImageTRWToByte)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImagePITRWConverted, ho_ImageTRWScaled;
    HObject ho_ImageNewTRWConvert, ho_ImageNewTRWMirror, ho_ImageTRWMirror;
    HObject ho_ImageRotateTRM;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageNewTRW);
    HOperatorSet.GenEmptyObj(out ho_ImageTRWToByte);
    HOperatorSet.GenEmptyObj(out ho_ImagePITRWConverted);
    HOperatorSet.GenEmptyObj(out ho_ImageTRWScaled);
    HOperatorSet.GenEmptyObj(out ho_ImageNewTRWConvert);
    HOperatorSet.GenEmptyObj(out ho_ImageNewTRWMirror);
    HOperatorSet.GenEmptyObj(out ho_ImageTRWMirror);
    HOperatorSet.GenEmptyObj(out ho_ImageRotateTRM);
    ho_ImagePITRWConverted.Dispose();
    HOperatorSet.ConvertImageType(ho_ProfileImageTRW, out ho_ImagePITRWConverted, 
        "int4");
    ho_ImageTRWScaled.Dispose();
    HOperatorSet.ScaleImage(ho_ImagePITRWConverted, out ho_ImageTRWScaled, 1, -32768);
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ScaleImage(ho_ImageTRWScaled, out ExpTmpOutVar_0, 1.6, 0);
    ho_ImageTRWScaled.Dispose();
    ho_ImageTRWScaled = ExpTmpOutVar_0;
    }
    //get_image_size (ImageTRWScaled, WidthPITRW, HeightPITRW)
    //gen_image_const (ImageNewTempTRW, 'int4', WidthPITRW, HeightPITRW)
    //for Index := 0 to HeightPITRW-1 by 1
      //get_grayval (ImageTRWScaled, gen_tuple_const(WidthPITRW,Index), [0:WidthPITRW-1], grayValuePITRWBefore)
      //grayValuePITRW := grayValuePITRWBefore[0:WidthPITRW-1]-([0:WidthPITRW-1]*kTR+bTR)
      //set_grayval (ImageNewTempTRW, gen_tuple_const(WidthPITRW,Index), [0:WidthPITRW-1], grayValuePITRW)
    //endfor
    ho_ImageNewTRWConvert.Dispose();
    HOperatorSet.ConvertImageType(ho_ImageTRWScaled, out ho_ImageNewTRWConvert, "int2");
    ho_ImageNewTRWMirror.Dispose();
    HOperatorSet.MirrorImage(ho_ImageNewTRWConvert, out ho_ImageNewTRWMirror, "column");
    ho_ImageNewTRW.Dispose();
    HOperatorSet.RotateImage(ho_ImageNewTRWMirror, out ho_ImageNewTRW, 90, "constant");

    ho_ImageTRWMirror.Dispose();
    HOperatorSet.MirrorImage(ho_ProfileImageTRW, out ho_ImageTRWMirror, "column");
    ho_ImageRotateTRM.Dispose();
    HOperatorSet.RotateImage(ho_ImageTRWMirror, out ho_ImageRotateTRM, 90, "constant");
    ho_ImageTRWToByte.Dispose();
    HOperatorSet.ConvertImageType(ho_ImageRotateTRM, out ho_ImageTRWToByte, "byte");
    ho_ImagePITRWConverted.Dispose();
    ho_ImageTRWScaled.Dispose();
    ho_ImageNewTRWConvert.Dispose();
    ho_ImageNewTRWMirror.Dispose();
    ho_ImageTRWMirror.Dispose();
    ho_ImageRotateTRM.Dispose();


    return;
  }

  public void get_ImageUP (HObject ho_ImageNewTRW, HObject ho_NewImageNewTLW, out HObject ho_ImageUP)
  {



    // Local iconic variables 

    HObject ho_Region, ho_ConnectedRegions, ho_SelectedRegions;
    HObject ho_RegionOpening, ho_RegionDilation, ho_RegionUnion;
    HObject ho_ImageReduced;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageUP);
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
    HOperatorSet.GenEmptyObj(out ho_RegionOpening);
    HOperatorSet.GenEmptyObj(out ho_RegionDilation);
    HOperatorSet.GenEmptyObj(out ho_RegionUnion);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    ho_Region.Dispose();
    HOperatorSet.Threshold(ho_ImageNewTRW, out ho_Region, -128000, -25500);
    ho_ConnectedRegions.Dispose();
    HOperatorSet.Connection(ho_Region, out ho_ConnectedRegions);
    ho_SelectedRegions.Dispose();
    HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area", 
        "and", 99577.5, 2000000);
    ho_RegionOpening.Dispose();
    HOperatorSet.OpeningCircle(ho_SelectedRegions, out ho_RegionOpening, 9);
    ho_RegionDilation.Dispose();
    HOperatorSet.DilationCircle(ho_RegionOpening, out ho_RegionDilation, 3);
    ho_RegionUnion.Dispose();
    HOperatorSet.Union1(ho_RegionDilation, out ho_RegionUnion);
    ho_ImageReduced.Dispose();
    HOperatorSet.ReduceDomain(ho_NewImageNewTLW, ho_RegionUnion, out ho_ImageReduced
        );
    ho_ImageUP.Dispose();
    HOperatorSet.PaintGray(ho_ImageReduced, ho_ImageNewTRW, out ho_ImageUP);
    ho_Region.Dispose();
    ho_ConnectedRegions.Dispose();
    ho_SelectedRegions.Dispose();
    ho_RegionOpening.Dispose();
    ho_RegionDilation.Dispose();
    ho_RegionUnion.Dispose();
    ho_ImageReduced.Dispose();


    return;
  }

  public void get_located_line (HObject ho_ImageNewTRW, HTuple hv_RowL, HTuple hv_ColumnL, 
      out HTuple hv_PhiStd)
  {




    // Local iconic variables 

    HObject ho_ROI_0, ho_ImageReduced, ho_RegionStd;
    HObject ho_RegionClosing, ho_RegionOpeningStd, ho_RegionBorderStd;
    HObject ho_ContourStds, ho_ContourStdsSplit, ho_SelectedContourStds;
    HObject ho_UnionContourStds, ho_SortedContourStds, ho_ObjectSelectedStd;
    HObject ho_ContourStd;

    // Local control variables 

    HTuple hv_RowBeginStd = new HTuple(), hv_ColBeginStd = new HTuple();
    HTuple hv_RowEndStd = new HTuple(), hv_ColEndStd = new HTuple();
    HTuple hv_NrC = new HTuple(), hv_NcC = new HTuple(), hv_DistC = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ROI_0);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_RegionStd);
    HOperatorSet.GenEmptyObj(out ho_RegionClosing);
    HOperatorSet.GenEmptyObj(out ho_RegionOpeningStd);
    HOperatorSet.GenEmptyObj(out ho_RegionBorderStd);
    HOperatorSet.GenEmptyObj(out ho_ContourStds);
    HOperatorSet.GenEmptyObj(out ho_ContourStdsSplit);
    HOperatorSet.GenEmptyObj(out ho_SelectedContourStds);
    HOperatorSet.GenEmptyObj(out ho_UnionContourStds);
    HOperatorSet.GenEmptyObj(out ho_SortedContourStds);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelectedStd);
    HOperatorSet.GenEmptyObj(out ho_ContourStd);
    hv_PhiStd = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ROI_0.Dispose();
    HOperatorSet.GenRectangle1(out ho_ROI_0, hv_RowL-260, hv_ColumnL+10, hv_RowL+270, 
        hv_ColumnL+40);
    }
    ho_ImageReduced.Dispose();
    HOperatorSet.ReduceDomain(ho_ImageNewTRW, ho_ROI_0, out ho_ImageReduced);
    ho_RegionStd.Dispose();
    HOperatorSet.Threshold(ho_ImageReduced, out ho_RegionStd, -2050, 4095);
    ho_RegionClosing.Dispose();
    HOperatorSet.ClosingRectangle1(ho_RegionStd, out ho_RegionClosing, 1, 15);

    ho_RegionOpeningStd.Dispose();
    HOperatorSet.OpeningRectangle1(ho_RegionClosing, out ho_RegionOpeningStd, 1, 
        5);

    ho_RegionBorderStd.Dispose();
    HOperatorSet.Boundary(ho_RegionOpeningStd, out ho_RegionBorderStd, "inner");
    ho_ContourStds.Dispose();
    HOperatorSet.GenContourRegionXld(ho_RegionBorderStd, out ho_ContourStds, "border");
    ho_ContourStdsSplit.Dispose();
    HOperatorSet.SegmentContoursXld(ho_ContourStds, out ho_ContourStdsSplit, "lines", 
        5, 1, 1);
    ho_SelectedContourStds.Dispose();
    HOperatorSet.SelectContoursXld(ho_ContourStdsSplit, out ho_SelectedContourStds, 
        "contour_length", 20, 2000, -0.5, 0.5);
    ho_UnionContourStds.Dispose();
    HOperatorSet.UnionCollinearContoursExtXld(ho_SelectedContourStds, out ho_UnionContourStds, 
        200, 7, 7, 0.5, 0, -1, 1, 1, 1, 1, 1, 0, "attr_keep");
    ho_SelectedContourStds.Dispose();
    HOperatorSet.SelectContoursXld(ho_UnionContourStds, out ho_SelectedContourStds, 
        "contour_length", 80, 2000, -0.5, 0.5);
    ho_SortedContourStds.Dispose();
    HOperatorSet.SortContoursXld(ho_SelectedContourStds, out ho_SortedContourStds, 
        "character", "true", "row");
    ho_ObjectSelectedStd.Dispose();
    HOperatorSet.SelectObj(ho_SortedContourStds, out ho_ObjectSelectedStd, 1);
    hv_RowBeginStd.Dispose();hv_ColBeginStd.Dispose();hv_RowEndStd.Dispose();hv_ColEndStd.Dispose();hv_NrC.Dispose();hv_NcC.Dispose();hv_DistC.Dispose();
    HOperatorSet.FitLineContourXld(ho_ObjectSelectedStd, "drop", -1, 2, 10, 1, out hv_RowBeginStd, 
        out hv_ColBeginStd, out hv_RowEndStd, out hv_ColEndStd, out hv_NrC, out hv_NcC, 
        out hv_DistC);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ContourStd.Dispose();
    HOperatorSet.GenContourPolygonXld(out ho_ContourStd, hv_RowBeginStd.TupleConcat(
        hv_RowEndStd), hv_ColBeginStd.TupleConcat(hv_ColEndStd));
    }

    hv_PhiStd.Dispose();
    HOperatorSet.LineOrientation(hv_RowBeginStd, hv_ColBeginStd, hv_RowEndStd, hv_ColEndStd, 
        out hv_PhiStd);
    ho_ROI_0.Dispose();
    ho_ImageReduced.Dispose();
    ho_RegionStd.Dispose();
    ho_RegionClosing.Dispose();
    ho_RegionOpeningStd.Dispose();
    ho_RegionBorderStd.Dispose();
    ho_ContourStds.Dispose();
    ho_ContourStdsSplit.Dispose();
    ho_SelectedContourStds.Dispose();
    ho_UnionContourStds.Dispose();
    ho_SortedContourStds.Dispose();
    ho_ObjectSelectedStd.Dispose();
    ho_ContourStd.Dispose();

    hv_RowBeginStd.Dispose();
    hv_ColBeginStd.Dispose();
    hv_RowEndStd.Dispose();
    hv_ColEndStd.Dispose();
    hv_NrC.Dispose();
    hv_NcC.Dispose();
    hv_DistC.Dispose();

    return;
  }

  public void get_location (HObject ho_ProfileImageTLW, HObject ho_ProfileImageTRW, 
      HObject ho_ProfileImageBW, out HObject ho_ImageNewTLW, out HObject ho_ImageNewTRW, 
      out HObject ho_ImageNewBW, out HObject ho_fit_contour, out HObject ho_ImageUP, 
      out HObject ho_RegionB, HTuple hv_ModelID, out HTuple hv_RowB, out HTuple hv_ColB, 
      out HTuple hv_RowC, out HTuple hv_ColC)
  {




    // Local iconic variables 

    HObject ho_ImageNewTL, ho_ImageTLWToByte, ho_ImageTRWToByte;
    HObject ho_ImageNewB, ho_ImageBWToByte, ho_ROI_0, ho_ImageReduced;
    HObject ho_ROI_1, ho_ROI_2, ho_ImageReducedMS, ho_ModelImages;
    HObject ho_ModelRegions, ho_Region, ho_OrginLineB, ho_LineB;
    HObject ho_OrginLineC, ho_LineC, ho_ROI_BR;

    // Local control variables 

    HTuple hv_RowTLW = new HTuple(), hv_ColumnTLW = new HTuple();
    HTuple hv_AngleTLW = new HTuple(), hv_ScoreTLW = new HTuple();
    HTuple hv_ModelIDMS = new HTuple(), hv_RowTR = new HTuple();
    HTuple hv_ColumnTR = new HTuple(), hv_AngleTR = new HTuple();
    HTuple hv_ScoreTR = new HTuple(), hv_RowTL = new HTuple();
    HTuple hv_ColumnTL = new HTuple(), hv_AngleTL = new HTuple();
    HTuple hv_ScoreTL = new HTuple(), hv_HomMat2D = new HTuple();
    HTuple hv_AngleB = new HTuple(), hv_Score2 = new HTuple();
    HTuple hv_PhiStd = new HTuple(), hv_RowBeginB = new HTuple();
    HTuple hv_ColBeginB = new HTuple(), hv_RowEndB = new HTuple();
    HTuple hv_ColEndB = new HTuple(), hv_PhiB = new HTuple();
    HTuple hv_HomMat2DB = new HTuple(), hv_PhiBB = new HTuple();
    HTuple hv_RowBeginC = new HTuple(), hv_ColBeginC = new HTuple();
    HTuple hv_RowEndC = new HTuple(), hv_ColEndC = new HTuple();
    HTuple hv_PhiC = new HTuple(), hv_HomMat2DC = new HTuple();
    HTuple hv_PhiCC = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageNewTLW);
    HOperatorSet.GenEmptyObj(out ho_ImageNewTRW);
    HOperatorSet.GenEmptyObj(out ho_ImageNewBW);
    HOperatorSet.GenEmptyObj(out ho_fit_contour);
    HOperatorSet.GenEmptyObj(out ho_ImageUP);
    HOperatorSet.GenEmptyObj(out ho_RegionB);
    HOperatorSet.GenEmptyObj(out ho_ImageNewTL);
    HOperatorSet.GenEmptyObj(out ho_ImageTLWToByte);
    HOperatorSet.GenEmptyObj(out ho_ImageTRWToByte);
    HOperatorSet.GenEmptyObj(out ho_ImageNewB);
    HOperatorSet.GenEmptyObj(out ho_ImageBWToByte);
    HOperatorSet.GenEmptyObj(out ho_ROI_0);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_ROI_1);
    HOperatorSet.GenEmptyObj(out ho_ROI_2);
    HOperatorSet.GenEmptyObj(out ho_ImageReducedMS);
    HOperatorSet.GenEmptyObj(out ho_ModelImages);
    HOperatorSet.GenEmptyObj(out ho_ModelRegions);
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_OrginLineB);
    HOperatorSet.GenEmptyObj(out ho_LineB);
    HOperatorSet.GenEmptyObj(out ho_OrginLineC);
    HOperatorSet.GenEmptyObj(out ho_LineC);
    HOperatorSet.GenEmptyObj(out ho_ROI_BR);
    hv_RowB = new HTuple();
    hv_ColB = new HTuple();
    hv_RowC = new HTuple();
    hv_ColC = new HTuple();

    //左侧和下侧图片要旋转才可以达到，加W结尾的才是最终输出图片
    //****************矫正I40TL照片
    ho_ImageNewTL.Dispose();ho_ImageTLWToByte.Dispose();
    get_ImageTL(ho_ProfileImageTLW, out ho_ImageNewTL, out ho_ImageTLWToByte);
    //矫正I40TR照片
    ho_ImageNewTRW.Dispose();ho_ImageTRWToByte.Dispose();
    get_ImageTR(ho_ProfileImageTRW, out ho_ImageNewTRW, out ho_ImageTRWToByte);
    //****************矫正I40B照片
    ho_ImageNewB.Dispose();ho_ImageBWToByte.Dispose();
    get_ImageB(ho_ProfileImageBW, out ho_ImageNewB, out ho_ImageBWToByte);
    //**********************合并上面两张图
    //gen_rectangle1 (ROI_0, 195.762, 539.958, 1130.34, 924.691)
    //gen_rectangle1 (ROI_0, 193.769, 606.164, 1109.66, 896.676)
    //gen_rectangle1 (TMP_Region, 283.488, 1660.91, 1023.68, 1899.08)
    //union2 (ROI_0, TMP_Region, ROI_0)
    //reduce_domain (ImageTRWToByte, ROI_0, ImageReduced)
    //create_shape_model (ImageReduced, 'auto', -0.39, 0.79, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID1)
    //write_shape_model (ModelID1, 'G:/项目文件/1107/50shapemodel')
    //针对每个工件正反面定位
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_ImageTRWToByte, HDevWindowStack.GetActive());
    }
    hv_RowTLW.Dispose();hv_ColumnTLW.Dispose();hv_AngleTLW.Dispose();hv_ScoreTLW.Dispose();
    HOperatorSet.FindShapeModel(ho_ImageTRWToByte, hv_ModelID, -0.39, 0.79, 0.2, 
        1, 0.5, "least_squares", 0, 0.9, out hv_RowTLW, out hv_ColumnTLW, out hv_AngleTLW, 
        out hv_ScoreTLW);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ROI_1.Dispose();
    HOperatorSet.GenRectangle1(out ho_ROI_1, hv_RowTLW-485, hv_ColumnTLW-570, hv_RowTLW+480, 
        hv_ColumnTLW-230);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ROI_2.Dispose();
    HOperatorSet.GenRectangle1(out ho_ROI_2, hv_RowTLW-380, hv_ColumnTLW+400, hv_RowTLW+390, 
        hv_ColumnTLW+780);
    }
    ho_ROI_0.Dispose();
    HOperatorSet.Union2(ho_ROI_1, ho_ROI_2, out ho_ROI_0);
    ho_ImageReducedMS.Dispose();
    HOperatorSet.ReduceDomain(ho_ImageTRWToByte, ho_ROI_0, out ho_ImageReducedMS);
    ho_ModelImages.Dispose();ho_ModelRegions.Dispose();
    HOperatorSet.InspectShapeModel(ho_ImageReducedMS, out ho_ModelImages, out ho_ModelRegions, 
        4, 30);
    hv_ModelIDMS.Dispose();
    HOperatorSet.CreateShapeModel(ho_ImageReducedMS, 4, -0.39, 0.79, "auto", "auto", 
        "use_polarity", "auto", "auto", out hv_ModelIDMS);
    //找模板，找旋转中心
    hv_RowTR.Dispose();hv_ColumnTR.Dispose();hv_AngleTR.Dispose();hv_ScoreTR.Dispose();
    HOperatorSet.FindShapeModel(ho_ImageTRWToByte, hv_ModelIDMS, -1, 1, 0.5, 1, 0.5, 
        "least_squares", 2, 0.9, out hv_RowTR, out hv_ColumnTR, out hv_AngleTR, out hv_ScoreTR);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_ImageTRWToByte, HDevWindowStack.GetActive());
    }
    dev_display_shape_matching_results(hv_ModelIDMS, "red", hv_RowTR, hv_ColumnTR, 
        hv_AngleTR, 1, 1, 0);
    hv_RowTL.Dispose();hv_ColumnTL.Dispose();hv_AngleTL.Dispose();hv_ScoreTL.Dispose();
    HOperatorSet.FindShapeModel(ho_ImageTLWToByte, hv_ModelIDMS, -1, 1, 0.3, 1, 0.5, 
        "least_squares", 2, 0.9, out hv_RowTL, out hv_ColumnTL, out hv_AngleTL, out hv_ScoreTL);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_ImageTLWToByte, HDevWindowStack.GetActive());
    }
    dev_display_shape_matching_results(hv_ModelIDMS, "red", hv_RowTL, hv_ColumnTL, 
        hv_AngleTL, 1, 1, 0);
    //旋转TL矫正镜像图片照片
    hv_HomMat2D.Dispose();
    HOperatorSet.VectorAngleToRigid(hv_RowTL, hv_ColumnTL, hv_AngleTL, hv_RowTR, 
        hv_ColumnTR, hv_AngleTR, out hv_HomMat2D);
    ho_ImageNewTLW.Dispose();
    HOperatorSet.AffineTransImage(ho_ImageNewTL, out ho_ImageNewTLW, hv_HomMat2D, 
        "constant", "false");
    ho_ImageUP.Dispose();
    get_ImageUP(ho_ImageNewTRW, ho_ImageNewTLW, out ho_ImageUP);
    //底面旋转到检测位置
    hv_RowB.Dispose();hv_ColB.Dispose();hv_AngleB.Dispose();hv_Score2.Dispose();
    HOperatorSet.FindShapeModel(ho_ImageBWToByte, hv_ModelIDMS, -1, 1, 0.2, 1, 0.3, 
        "least_squares", 2, 0.9, out hv_RowB, out hv_ColB, out hv_AngleB, out hv_Score2);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_ImageBWToByte, HDevWindowStack.GetActive());
    }
    dev_display_shape_matching_results(hv_ModelIDMS, "red", hv_RowB, hv_ColB, hv_AngleB, 
        1, 1, 0);
    hv_HomMat2D.Dispose();
    HOperatorSet.VectorAngleToRigid(hv_RowB, hv_ColB, hv_AngleB, hv_RowTR, hv_ColumnTR, 
        hv_AngleTR, out hv_HomMat2D);
    ho_ImageNewBW.Dispose();
    HOperatorSet.AffineTransImage(ho_ImageNewB, out ho_ImageNewBW, hv_HomMat2D, "constant", 
        "false");
    ho_Region.Dispose();
    HOperatorSet.Threshold(ho_ImageNewBW, out ho_Region, -11128, 255);
    //创建模板
    //gen_rectangle1 (ROI_0, 237.934, 181.275, 1140.4, 306.398)
    //reduce_domain (ImageTLWToByte, ROI_0, ImageReducedMS)
    //inspect_shape_model (ImageReducedMS, ModelImages, ModelRegions, 4, 50)
    //create_shape_model (ImageReducedMS, 4, -0.39, 0.79, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelIDL)
    //找模板，找旋转中心
    //find_shape_model (ImageTLWToByte, ModelIDMS, -1, 1, 0.5, 1, 0.3, 'least_squares', 2, 0.9, RowL, ColumnL, AngleL, ScoreTL)
    if (HDevWindowStack.IsOpen())
    {
      //dev_display (ImageTLWToByte)
    }
    //dev_display_shape_matching_results (ModelID, 'red', RowTL, ColumnTL, AngleTL, 1, 1, 0)
    //获取定位线
    hv_PhiStd.Dispose();
    get_located_line(ho_ImageNewTRW, hv_RowTR, hv_ColumnTR, out hv_PhiStd);
    //生成基准垂线
    //RowM := (RowBeginStd+RowEndStd)/2
    //ColM := (ColBeginStd+ColEndStd)/2
    //********************生成垂线**************************垂线长度
    //LineLength := 200
    //起点
    //RowStartV := RowM-cos(PhiStd)*LineLength
    //ColStartV := ColM-sin(PhiStd)*LineLength
    //终点
    //RowEndV := RowM+cos(PhiStd)*LineLength
    //ColEndV := ColM+sin(PhiStd)
    //LineLength
    //line_orientation (RowStartV, RowStartV, RowEndV, ColEndV, PhiV)
    //gen_contour_polygon_xld (ContourV, [RowStartV,RowEndV], [ColStartV,ColEndV])

    //生成B条线
    ho_OrginLineB.Dispose();hv_RowBeginB.Dispose();hv_ColBeginB.Dispose();hv_RowEndB.Dispose();hv_ColEndB.Dispose();
    gen_B_line(ho_ImageNewTRW, out ho_OrginLineB, hv_RowTR, hv_ColumnTR, out hv_RowBeginB, 
        out hv_ColBeginB, out hv_RowEndB, out hv_ColEndB);
    //校准B线
    hv_PhiB.Dispose();
    HOperatorSet.LineOrientation(hv_RowBeginB, hv_ColBeginB, hv_RowEndB, hv_ColEndB, 
        out hv_PhiB);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HomMat2DB.Dispose();
    HOperatorSet.VectorAngleToRigid((hv_RowBeginB+hv_RowEndB)/2, (hv_ColBeginB+hv_ColEndB)/2, 
        hv_PhiB, (hv_RowBeginB+hv_RowEndB)/2, (hv_ColBeginB+hv_ColEndB)/2, 0, out hv_HomMat2DB);
    }
    ho_LineB.Dispose();
    HOperatorSet.AffineTransContourXld(ho_OrginLineB, out ho_LineB, hv_HomMat2DB);
    hv_RowB.Dispose();hv_ColB.Dispose();
    HOperatorSet.GetContourXld(ho_LineB, out hv_RowB, out hv_ColB);
    hv_PhiBB.Dispose();
    HOperatorSet.OrientationXld(ho_LineB, out hv_PhiBB);
    //生成C条线
    ho_OrginLineC.Dispose();hv_RowBeginC.Dispose();hv_ColBeginC.Dispose();hv_RowEndC.Dispose();hv_ColEndC.Dispose();
    get_C_line(ho_ImageNewTRW, out ho_OrginLineC, hv_RowTR, hv_ColumnTR, out hv_RowBeginC, 
        out hv_ColBeginC, out hv_RowEndC, out hv_ColEndC);
    //校准C线
    hv_PhiC.Dispose();
    HOperatorSet.LineOrientation(hv_RowBeginC, hv_ColBeginC, hv_RowEndC, hv_ColEndC, 
        out hv_PhiC);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HomMat2DC.Dispose();
    HOperatorSet.VectorAngleToRigid((hv_RowBeginC+hv_RowEndC)/2, (hv_ColBeginC+hv_ColEndC)/2, 
        hv_PhiC, (hv_RowBeginC+hv_RowEndC)/2, (hv_ColBeginC+hv_ColEndC)/2, (new HTuple(90)).TupleRad()
        , out hv_HomMat2DC);
    }
    ho_LineC.Dispose();
    HOperatorSet.AffineTransContourXld(ho_OrginLineC, out ho_LineC, hv_HomMat2DC);
    hv_RowC.Dispose();hv_ColC.Dispose();
    HOperatorSet.GetContourXld(ho_LineC, out hv_RowC, out hv_ColC);
    hv_PhiCC.Dispose();
    HOperatorSet.OrientationXld(ho_LineC, out hv_PhiCC);
    ho_fit_contour.Dispose();
    HOperatorSet.GenEmptyObj(out ho_fit_contour);
    //显示B台阶面
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ROI_BR.Dispose();
    HOperatorSet.GenRectangle1(out ho_ROI_BR, hv_RowTR+520, hv_ColumnTR-930, hv_RowTR+550, 
        hv_ColumnTR-40);
    }
    ho_ImageReduced.Dispose();
    HOperatorSet.ReduceDomain(ho_ImageUP, ho_ROI_BR, out ho_ImageReduced);
    ho_RegionB.Dispose();
    HOperatorSet.Threshold(ho_ImageReduced, out ho_RegionB, -2000, -1600);
    ho_ImageNewTL.Dispose();
    ho_ImageTLWToByte.Dispose();
    ho_ImageTRWToByte.Dispose();
    ho_ImageNewB.Dispose();
    ho_ImageBWToByte.Dispose();
    ho_ROI_0.Dispose();
    ho_ImageReduced.Dispose();
    ho_ROI_1.Dispose();
    ho_ROI_2.Dispose();
    ho_ImageReducedMS.Dispose();
    ho_ModelImages.Dispose();
    ho_ModelRegions.Dispose();
    ho_Region.Dispose();
    ho_OrginLineB.Dispose();
    ho_LineB.Dispose();
    ho_OrginLineC.Dispose();
    ho_LineC.Dispose();
    ho_ROI_BR.Dispose();

    hv_RowTLW.Dispose();
    hv_ColumnTLW.Dispose();
    hv_AngleTLW.Dispose();
    hv_ScoreTLW.Dispose();
    hv_ModelIDMS.Dispose();
    hv_RowTR.Dispose();
    hv_ColumnTR.Dispose();
    hv_AngleTR.Dispose();
    hv_ScoreTR.Dispose();
    hv_RowTL.Dispose();
    hv_ColumnTL.Dispose();
    hv_AngleTL.Dispose();
    hv_ScoreTL.Dispose();
    hv_HomMat2D.Dispose();
    hv_AngleB.Dispose();
    hv_Score2.Dispose();
    hv_PhiStd.Dispose();
    hv_RowBeginB.Dispose();
    hv_ColBeginB.Dispose();
    hv_RowEndB.Dispose();
    hv_ColEndB.Dispose();
    hv_PhiB.Dispose();
    hv_HomMat2DB.Dispose();
    hv_PhiBB.Dispose();
    hv_RowBeginC.Dispose();
    hv_ColBeginC.Dispose();
    hv_RowEndC.Dispose();
    hv_ColEndC.Dispose();
    hv_PhiC.Dispose();
    hv_HomMat2DC.Dispose();
    hv_PhiCC.Dispose();

    return;

  }

  public void override_get_grayvalue (HObject ho_Image, HTuple hv_rows, HTuple hv_cols, 
      HTuple hv_phi, HTuple hv_grids, HTuple hv_plane, out HTuple hv_grayvalues)
  {




    // Local iconic variables 

    HObject ho_Rectangle=null, ho_Cross=null;

    // Local control variables 

    HTuple hv_Index = new HTuple(), hv_tempGrayvalues = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_GrayvalOrgin = new HTuple(), hv_Sorted = new HTuple();
    HTuple hv_Grayval = new HTuple(), hv_Index1 = new HTuple();
    HTuple hv_SortedGrayval = new HTuple(), hv_SelectedGrayval = new HTuple();
    HTuple hv_MeanGrayval = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    HOperatorSet.GenEmptyObj(out ho_Cross);
    hv_grayvalues = new HTuple();
    hv_grayvalues.Dispose();
    hv_grayvalues = new HTuple();
    //open_file ('C:/Users/25001885/Desktop/ZValues.csv', 'output', FileHandle)
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_rows.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_tempGrayvalues.Dispose();
      hv_tempGrayvalues = new HTuple();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_Rectangle.Dispose();
      HOperatorSet.GenRectangle2(out ho_Rectangle, hv_rows.TupleSelect(hv_Index), 
          hv_cols.TupleSelect(hv_Index), hv_phi, hv_grids/3, hv_grids/2);
      }
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_Rectangle, out hv_Rows, out hv_Columns);
      ho_Cross.Dispose();
      HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Columns, 6, 0.785398);
      hv_GrayvalOrgin.Dispose();
      HOperatorSet.GetGrayval(ho_Image, hv_Rows, hv_Columns, out hv_GrayvalOrgin);
      hv_Sorted.Dispose();
      HOperatorSet.TupleSort(hv_GrayvalOrgin, out hv_Sorted);
      if ((int)(new HTuple((new HTuple(hv_Sorted.TupleLength())).TupleGreaterEqual(
          9))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Grayval.Dispose();
        HOperatorSet.TupleSelectRange(hv_Sorted, 4, (new HTuple(hv_Sorted.TupleLength()
            ))-4, out hv_Grayval);
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Grayval.Dispose();
        HOperatorSet.TupleSelectRange(hv_Sorted, 0, (new HTuple(hv_Sorted.TupleLength()
            ))-1, out hv_Grayval);
        }
      }
      if ((int)(new HTuple(hv_plane.TupleEqual("A"))) != 0)
      {
        for (hv_Index1=0; (int)hv_Index1<=(int)((new HTuple(hv_Grayval.TupleLength()
            ))-1); hv_Index1 = (int)hv_Index1 + 1)
        {
          if ((int)((new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleGreater(
              -1200))).TupleAnd(new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleLess(
              -800)))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_tempGrayvalues = hv_tempGrayvalues.TupleConcat(
                hv_Grayval.TupleSelect(hv_Index1));
            hv_tempGrayvalues.Dispose();
            hv_tempGrayvalues = ExpTmpLocalVar_tempGrayvalues;
            }
            }
          }
        }
      }
      else if ((int)(new HTuple(hv_plane.TupleEqual("P"))) != 0)
      {
        for (hv_Index1=0; (int)hv_Index1<=(int)((new HTuple(hv_Grayval.TupleLength()
            ))-1); hv_Index1 = (int)hv_Index1 + 1)
        {
          if ((int)((new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleGreater(
              -3900))).TupleAnd(new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleLess(
              -3500)))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_tempGrayvalues = hv_tempGrayvalues.TupleConcat(
                hv_Grayval.TupleSelect(hv_Index1));
            hv_tempGrayvalues.Dispose();
            hv_tempGrayvalues = ExpTmpLocalVar_tempGrayvalues;
            }
            }
          }
        }
      }
      else if ((int)(new HTuple(hv_plane.TupleEqual("E"))) != 0)
      {
        for (hv_Index1=0; (int)hv_Index1<=(int)((new HTuple(hv_Grayval.TupleLength()
            ))-1); hv_Index1 = (int)hv_Index1 + 1)
        {
          if ((int)((new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleGreater(
              -3800))).TupleAnd(new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleLessEqual(
              -3500)))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_tempGrayvalues = hv_tempGrayvalues.TupleConcat(
                hv_Grayval.TupleSelect(hv_Index1));
            hv_tempGrayvalues.Dispose();
            hv_tempGrayvalues = ExpTmpLocalVar_tempGrayvalues;
            }
            }
          }
        }

      }
      else if ((int)(new HTuple(hv_plane.TupleEqual("F"))) != 0)
      {
        for (hv_Index1=0; (int)hv_Index1<=(int)((new HTuple(hv_Grayval.TupleLength()
            ))-1); hv_Index1 = (int)hv_Index1 + 1)
        {
          if ((int)((new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleGreater(
              -3000))).TupleAnd(new HTuple(((hv_Grayval.TupleSelect(hv_Index1))).TupleLess(
              2500)))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_tempGrayvalues = hv_tempGrayvalues.TupleConcat(
                hv_Grayval.TupleSelect(hv_Index1));
            hv_tempGrayvalues.Dispose();
            hv_tempGrayvalues = ExpTmpLocalVar_tempGrayvalues;
            }
            }
          }
        }
      }
      hv_SortedGrayval.Dispose();
      HOperatorSet.TupleSort(hv_tempGrayvalues, out hv_SortedGrayval);
      if ((int)((new HTuple((new HTuple(hv_SortedGrayval.TupleLength())).TupleGreaterEqual(
          3))).TupleAnd(new HTuple((new HTuple(hv_SortedGrayval.TupleLength())).TupleLessEqual(
          5)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SelectedGrayval.Dispose();
        HOperatorSet.TupleSelect(hv_SortedGrayval, HTuple.TupleGenSequence(1,(new HTuple(hv_SortedGrayval.TupleLength()
            ))-1,1), out hv_SelectedGrayval);
        }
      }
      else if ((int)(new HTuple((new HTuple(hv_SortedGrayval.TupleLength()
          )).TupleGreater(5))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SelectedGrayval.Dispose();
        HOperatorSet.TupleSelect(hv_SortedGrayval, HTuple.TupleGenSequence(2,(new HTuple(hv_SortedGrayval.TupleLength()
            ))-2,1), out hv_SelectedGrayval);
        }
      }
      else
      {
        hv_SelectedGrayval.Dispose();
        hv_SelectedGrayval = new HTuple(hv_SortedGrayval);
      }
      //for Index2 := 0 to |SortedGrayval|-1 by 1
        //fwrite_string (FileHandle, SortedGrayval[Index2]+',')
      //endfor
      //fnew_line (FileHandle)
      hv_MeanGrayval.Dispose();
      HOperatorSet.TupleMean(hv_SelectedGrayval, out hv_MeanGrayval);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_grayvalues = hv_grayvalues.TupleConcat(
          hv_MeanGrayval);
      hv_grayvalues.Dispose();
      hv_grayvalues = ExpTmpLocalVar_grayvalues;
      }
      }
    }
    ho_Rectangle.Dispose();
    ho_Cross.Dispose();

    hv_Index.Dispose();
    hv_tempGrayvalues.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_GrayvalOrgin.Dispose();
    hv_Sorted.Dispose();
    hv_Grayval.Dispose();
    hv_Index1.Dispose();
    hv_SortedGrayval.Dispose();
    hv_SelectedGrayval.Dispose();
    hv_MeanGrayval.Dispose();

    return;
  }

#if !NO_EXPORT_MAIN
  // Main procedure 
  private void action()
  {

    // Initialize local and output iconic variables 
    //get_system_time (MSecond, Second, Minute, Hour, Day, YDay, Month, Year)
    //* open_file ('C:/Users/25001885/Desktop/数据/'+Month+Day+Hour+Minute+Second+'.csv', 'output', FileHandleData)
    //open_file ('C:/Users/25001885/Desktop/grayvalue1.csv', 'output', FileHandleDataGrayValue1)
    //open_file ('C:/Users/25001885/Desktop/grayvalue2.csv', 'output', FileHandleDataGrayValue2)
    //strPath := 'G:/项目文件/1108/1107wen/dynamic/d1/'
    //* list_files (strPath+'2', ['files','follow_links'], ImageFilesTL)
    //tuple_regexp_select (ImageFilesTL, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImageFilesTL)
    //* list_files (strPath+'3', ['files','follow_links'], ImageFilesTR)
    //tuple_regexp_select (ImageFilesTR, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImageFilesTR)
    //* list_files (strPath+'1', ['files','follow_links'], ImageFilesB)
    //tuple_regexp_select (ImageFilesB, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImageFilesB)
    //gen_empty_obj (EmptyObject)
    //for IndexLoop := 0 to 8 by 1
      //dev_update_off ()
      //*     read_image (ProfileImageTLW, ImageFilesTL[IndexLoop])
      //*     read_image (ProfileImageTRW, ImageFilesTR[IndexLoop])
      //*     read_image (ProfileImageBW, ImageFilesB[IndexLoop])
      //创建模板,初定位
      //read_shape_model ('G:/项目文件/1107/50shapemodel', ModelID)
      //*     get_location (ProfileImageTLW, ProfileImageTRW, ProfileImageBW, ImageNewTLW, ImageNewTRW, ImageNewBW, fit_contour, ImageUP, RegionB, ModelID, RowB, ColB, RowC, ColC)

      //*     intersection_lines (RowC[0], ColC[0], RowC[1], ColC[1], RowB[0], ColB[0], RowB[1], ColB[1], RowBC, ColumnBC, IsOverlappingBC)
      //*     gen_region_points (RegionBC, RowBC, ColumnBC)

      //*     scale_image(ImageUP, ImageUPShow, 0.001, 0)
      //scale_image_range (ImageUPShow, ImageUPShow, -5, 250)
      //*     intersection_lines (RowB[0], ColB[0], RowB[1], ColB[1], 0, 0, 1600, 0, Row1, Column1, IsOverlapping1)
      //*     intersection_lines (RowB[0], ColB[0], RowB[1], ColB[1], 0, 2400, 1600, 2400, Row2, Column2, IsOverlapping1) 
      //*     gen_contour_polygon_xld (Contourb, [Row1,Row2], [Column1,Column2])
      //*     intersection_lines (0, 0, 0, 1600, RowC[0], ColC[0], RowC[1], ColC[1], Row3, Column3, IsOverlapping1)
      //*     intersection_lines (1600, 0, 1600, 800, RowC[0], ColC[0], RowC[1], ColC[1], Row4, Column4, IsOverlapping1)
      //*     gen_contour_polygon_xld (Contourc, [Row3,Row4], [Column3,Column4])
      //*     intersection_lines (Row3, Column3, Row4, Column4, Row1, Column1, Row2, Column2, Row, Column, IsOverlapping)
      //*     gen_region_points (Region, Row, Column)
      //*     concat_obj (EmptyObject, Region, EmptyObject)
      //dev_update_on ()
      //*    dev_display (ImageNewTRW)
      //*    dev_display (Contourc)
      //*    dev_display (Contourb)
      if (HDevWindowStack.IsOpen())
      {
        //dev_set_color ('green')
      }
      //*    dev_display (RegionB)
      //*    dev_display(EmptyObject)
      if (HDevWindowStack.IsOpen())
      {
        //dev_set_color ('red')
      }
      //定义像素当量
      //sy := 12.35
      //sx := 14
      //PhiB := 0
      //********************FAI16-1检测***************************
      //x16_1A := 19.605-[7.120,7.120,4.540,-4.540,-6.940,-6.940,-4.540,4.540]
      //y16_1A := 6.788+[4.340,-4.340,-6.570,-6.570,-4.050,4.050,6.570,6.570]
      //x16_1F := 19.605-[18.170,18.170,10.390+0.3,10.390+0.3,6.120,6.120,2.440,-2.440,-4.770,-6.120,-6.120,-4.770,-2.440,2.440]
      //y16_1F := 6.788+[-3.890,3.890,3.890,-3.890,-0.980,0.980,-5.510,-5.510,-4.480,-0.980,0.980,4.480,5.510,5.510]
      //*     analyze_coordinate (x16_1A, y16_1A, PhiB, RowBC, ColumnBC, sx, sy, Output_xA, Output_yA)
      //*     analyze_coordinate (x16_1F, y16_1F, PhiB, RowBC, ColumnBC, sx, sy, Output_xF, Output_yF)
      //*     override_get_grayvalue (ImageUP, Output_yA, Output_xA, PhiB, 4, 'A', grayvaluesA)

      //*     fwrite_string(FileHandleDataGrayValue1,grayvaluesA[0]+','+grayvaluesA[1]+','+grayvaluesA[2]+','+grayvaluesA[3]+','+grayvaluesA[4]+','+grayvaluesA[5]+','+grayvaluesA[6]+','+grayvaluesA[7] )
      //*     fnew_line (FileHandleDataGrayValue1)

      //gen_cross_contour_xld (Cross1, Output_yA, Output_xA, 6, 60)
      //*     override_get_grayvalue (ImageNewBW, Output_yF, Output_xF, PhiB, 4, 'F', grayvaluesF)

      //*     fwrite_string(FileHandleDataGrayValue2,grayvaluesF[0]+','+grayvaluesF[1]+','+grayvaluesF[2]+','+grayvaluesF[3]+','+grayvaluesF[4]+','+grayvaluesF[5]+','+grayvaluesF[6]+','+grayvaluesF[7]+','+grayvaluesF[8]+','+grayvaluesF[9]+','+grayvaluesF[10]+','+grayvaluesF[11]+','+grayvaluesF[12]+','+grayvaluesF[13] )
      //*     fnew_line (FileHandleDataGrayValue2)

      //gen_cross_contour_xld (Cross2, Output_yF, Output_xF, 6, 60)
      //analyze_flatness (Output_yF, Output_xF, -5000-grayvaluesF, Output_yA, Output_xA, grayvaluesA, flatness, distance)
      //平行度测量
      //parallam16 := max(distance)-min(distance)
      //记录16――1结果
      //*     fwrite_string (FileHandleData, parallam16+',')

      //********************FAI16-2检测***************************
      //x16_2 := 19.605-[-6.900,-6.970,-6.900,-6.970,-6.900,-6.970,-6.900,-6.970]
      //y16_2 := 6.788+[-4.900,-4.300,-3.800,-3.200,3.200,3.800,4.300,4.900]
      //*     analyze_coordinate (x16_2, y16_2, PhiB, RowBC, ColumnBC, sx, sy, Output_x, Output_y)
      //*     override_get_grayvalue (ImageUP, Output_y, Output_x, PhiB, 4, 'A', grayvalues)
      //*     gen_region_points (Region3, Output_y, Output_x)
      //*     gen_cross_contour_xld (Cross3, Output_y, Output_x, 6, 0.785398)
      //*     analyze_flatness (Output_y, Output_x, grayvalues, [], [], [], flatness, distance)
      //记录16――2结果
      //*     fwrite_string (FileHandleData, flatness+',')

      //********************FAI16-3检测***************************
      //x16_3 := 19.605-[-5.100,-4.500,-3.800,-3.200,3.200,3.800,4.500,5.100]
      //y16_3 := 6.788+[6.550,6.6000,6.550,6.6000,6.550,6.6000,6.550,6.6000]
      //    analyze_coordinate (x16_3, y16_3, PhiB, RowBC, ColumnBC, sx, sy, Output_x, Output_y)
      //    override_get_grayvalue (ImageUP, Output_y, Output_x, PhiB, 4, , plane3, grayvalues)
      //gen_cross_contour_xld (Cross5, Output_y, Output_x, 6, 0.785398)
      //    analyze_flatness_COPY_1 (Output_y, Output_x, grayvalues, [], [], [], flatness, distance)
      //********************FAI16-4检测***************************
      //8个点到B.C直线的距离
      //x16_4 := 19.605-[6.900,6.970,6.900,6.970,6.900,6.970,6.900,6.970]
      //y16_4 := 6.788+[-4.900,-4.300,-3.800,-3.200,3.200,3.800,4.300,4.900]
      //    analyze_coordinate (x16_4, y16_4, PhiB, RowBC, ColumnBC, sx, sy, Output_x, Output_y)
      //    override_get_grayvalue (ImageUP, Output_y, Output_x, PhiB, 5, , plane4, grayvalues)
      //gen_cross_contour_xld (Cross6, Output_y, Output_x, 6, 0.785398)
      //    analyze_flatness_COPY_1 (Output_y, Output_x, grayvalues, [], [], [], flatness, distance)

      //********************FAI16-5检测***************************
      //8个点到B.C直线的距离
      //x16_5 := 19.605-[-5.100,-4.500,-3.800,-3.200,3.200,3.800,4.500,5.100]
      //y16_5 := 6.788+[-6.550,-6.6000,-6.550,-6.6000,-6.550,-6.6000,-6.550,-6.6000]
      //    analyze_coordinate (x16_5, y16_5, PhiB, RowBC, ColumnBC, sx, sy, Output_x, Output_y)
      //    override_get_grayvalue (ImageUP, Output_y, Output_x, PhiB, 5, , plane5, grayvalues)
      //gen_cross_contour_xld (Cross7, Output_y, Output_x, 6, 0.785398)
      //    analyze_flatness_COPY_1 (Output_y, Output_x, grayvalues, [], [], [], flatness, distance)

      //********************FAI18C检测***************************
      //x18CA := 19.605-[7.120,7.120,4.540,-4.540,-6.940,-6.940,-4.540,4.540]
      //y18CA := 6.788+[4.340,-4.340,-6.570,-6.570,-4.050,4.050,6.570,6.570]
      //x18CE := 19.605-[5.220,5.220,-5.220+0.3,-5.220+0.3]
      //y18CE := 6.788+[1.520,-1.520,-1.520,1.520]
      //*     analyze_coordinate (x18CA, y18CA, PhiB, RowBC, ColumnBC, sx, sy, Output_xA, Output_yA)
      //*     analyze_coordinate (x18CE, y18CE, PhiB, RowBC, ColumnBC, sx, sy, Output_xE, Output_yE)
      //*     override_get_grayvalue (ImageUP, Output_yA, Output_xA, PhiB, 8, 'A', grayvaluesA)

      //gen_cross_contour_xld (Cross, Output_yA, Output_xA, 6, 0.785398)
      //*     override_get_grayvalue (ImageUP, Output_yE, Output_xE, PhiB, 4, 'E', grayvaluesE)

      //gen_region_points (Region3, Output_yE, Output_xE)
      //gen_cross_contour_xld (Cross4, Output_yE, Output_xE, 6, 0.785398)
      //analyze_flatness (Output_yA, Output_xA, grayvaluesA, Output_yE, Output_xE, grayvaluesE, flatness, distance)
      //轮廓度计算
      //pos1 := 2*max(abs(2.612-distance))
      //记录18C结果
      //*     fwrite_string (FileHandleData, pos1+',')

      //********************FAI18M检测***************************
      //x18MA := 19.605-[7.120,7.120,4.540,-4.540,-6.940,-6.940,-4.540,4.540]
      //y18MA := 6.788+[4.340,-4.340,-6.570,-6.570,-4.050,4.050,6.570,6.570]
      //x18ME := 19.605-[4.770,6.120,6.120,4.770,2.440,-2.440,-4.770,-6.120,-6.120,-4.770,-2.440,2.440]
      //y18ME := 6.788+[4.480,0.980,-0.980,-4.480,-5.510,-5.510,-4.480,-0.980,0.980,4.480,5.510,5.510]
      //*     analyze_coordinate (x18MA, y18MA, PhiB, RowBC, ColumnBC, sx, sy, Output_xA, Output_yA)
      //*     analyze_coordinate (x18ME, y18ME, PhiB, RowBC, ColumnBC, sx, sy, Output_xE, Output_yE)
      //*     override_get_grayvalue (ImageUP, Output_yA, Output_xA, PhiB, 8, 'A', grayvaluesA)
      //gen_cross_contour_xld (Cross3, Output_yA, Output_xA, 6, 0.785398)
      //*     override_get_grayvalue (ImageUP, Output_yE, Output_xE, PhiB, 4, 'E', grayvaluesE)
      //*     gen_cross_contour_xld (Cross5, Output_yE, Output_xE, 6, 0.785398)
      //*     analyze_flatness (Output_yA, Output_xA, grayvaluesA, Output_yE, Output_xE, grayvaluesE, flatness, distance)
      //计算轮廓度
      //selectRows := []
      //selectCols := []
      //tuple1 := [abs(2.612-distance[0]),abs(2.612-distance[1]),abs(2.612-distance[11])]
      //*     pos21:=2*max(tuple1)

      //tuple2 := [abs(2.612-distance[2]),abs(2.612-distance[3]),abs(2.612-distance[4])]
      //*     pos22:=2*max(tuple2)

      //tuple3 := [abs(2.612-distance[5]),abs(2.612-distance[6]),abs(2.612-distance[7])]
      //*     pos23:=2*max(tuple3)

      //tuple4 := [abs(2.612-distance[8]),abs(2.612-distance[9]),abs(2.612-distance[10])]
      //*     pos24:=2*max(tuple4)

      //记录18CM结果
      //*     fwrite_string (FileHandleData, pos21+','+pos22+','+pos23+','+pos24+',')    

      //********************FAI20检测***************************
      //x20F := 19.605-[18.170,18.170,10.390+0.3,10.390+0.3]
      //y20F := 6.788+[-3.890,3.890,3.890,-3.890]
      //x20P := 19.605-[18.170,18.170,10.390+0.3,10.390+0.3]
      //y20P := 6.788+[-3.890,3.890,3.890,-3.890]
      //*     analyze_coordinate (x20F, y20F, PhiB, RowBC, ColumnBC, sx, sy, Output_xF, Output_yF)
      //*     analyze_coordinate (x20P, y20P, PhiB, RowBC, ColumnBC, sx, sy, Output_xP, Output_yP)
      //*     override_get_grayvalue (ImageNewBW, Output_yF, Output_xF, PhiB, 4, 'F', grayvaluesF)
      //gen_cross_contour_xld (Cross6, Output_yF, Output_xF, 6, 0.785398)
      //*     override_get_grayvalue (ImageUP, Output_yP, Output_xP, PhiB, 4, 'P', grayvaluesP)
      //gen_cross_contour_xld (Cross7, Output_yP, Output_xP, 6, 0.785398)
      //计算四点对应的距离,5000是标定板厚度

      //distance20 := ((5000+grayvaluesP)+grayvaluesF)/1000
      //记录20结果
      //*     fwrite_string (FileHandleData, distance20[0]+','+distance20[1]+','+distance20[2]+','+distance20[3]+',')

      //********************FAI21检测***************************
      //x21F := 19.605-[18.170,18.170,10.390+0.3,10.390+0.3,6.120,6.120,2.440,-2.440,-4.770,-6.120,-6.120,-4.770,-2.440,2.440]
      //y21F := 6.788+[-3.890,3.890,3.890,-3.890,-0.980,0.980,-5.510,-5.510,-4.480,-0.980,0.980,4.480,5.510,5.510]
      //*     analyze_coordinate (x21F, y21F, PhiB, RowBC, ColumnBC, sx, sy, Output_xF, Output_yF)
      //*     override_get_grayvalue (ImageNewBW, Output_yF, Output_xF, PhiB, 4,  'F', grayvaluesF)
      //*     gen_cross_contour_xld (Cross8, Output_yF, Output_xF, 6, 0.785398)
      //计算平整度flatness
      //*     analyze_flatness (Output_yF, Output_xF, grayvaluesF, [], [], [], flatness, distance)
      //记录21结果
      //*     fwrite_string (FileHandleData, flatness+',')

      //********************FAI22检测***************************
      //x22A := 19.605-[7.120,7.120,4.540,-4.540,-6.940,-6.940,-4.540,4.540]
      //y22A := 6.788+[4.340,-4.340,-6.570,-6.570,-4.050,4.050,6.570,6.570]
      //由于跨边界  修改点位 以下为原始点位
      //x22P := 19.605-[18.170,18.170,10.390,10.390]
      //y22P := 6.788+[3.890,-3.890,-3.890,3.890]

      //x22P := 19.605-[18.170,18.170,10.390+0.2,10.390+0.2]
      //y22P := 6.788+[3.890,-3.890,-3.890,3.890]
      //*     analyze_coordinate (x22A, y22A, PhiB, RowBC, ColumnBC, sx, sy, Output_xA, Output_yA)
      //*     analyze_coordinate (x22P, y22P, PhiB, RowBC, ColumnBC, sx, sy, Output_xP, Output_yP)
      //*     override_get_grayvalue (ImageUP, Output_yA, Output_xA, PhiB, 8, 'A', grayvaluesA)
      //*     gen_cross_contour_xld (Cross9, Output_yA, Output_xA, 6, 0.785398)

      //*     override_get_grayvalue (ImageUP, Output_yP, Output_xP, PhiB, 4, 'P', grayvaluesP)
      //*     gen_region_points (Region3, Output_yP, Output_xP)

      //*     gen_cross_contour_xld (Cross10, Output_yP, Output_xP, 6, 0.785398)
      //*     analyze_flatness (Output_yA, Output_xA, grayvaluesA, Output_yP, Output_xP, grayvaluesP, flatness, distance)
      //平行度测量
      //*     parallam22:=max(distance)-min(distance)
      //记录22结果
      //*     fwrite_string (FileHandleData, parallam22)
      //*     fnew_line (FileHandleData)

    //endfor


  }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

