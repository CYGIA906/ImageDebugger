<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.0">
<procedure name="main">
<interface/>
<body>
<l>imageDir := 'C:/Users/afterbunny/Desktop/Projects/LineScan/Data/1102/静态/'</l>
<c></c>
<l>list_image_files (imageDir + 3, 'default', [], ImageFilesRight)</l>
<l>list_image_files (imageDir + 2, 'default', [], ImageFilesLeft)</l>
<l>list_image_files (imageDir + 1, 'default', [], ImageFilesBottom)</l>
<l>read_shape_model ('C:/Users/afterbunny/Desktop/Transfer/Xiaojin/ImageDebugger/Configs/3D/I40/ShapeModels/ModelRight', ShapeModelHandel)</l>
<c></c>
<c></c>
<c></c>
<l>for Index := 1 to |ImageFilesRight| - 1 by 1</l>
<l>    read_image(ImageRight, ImageFilesRight[Index])</l>
<l>    read_image(ImageLeft, ImageFilesLeft[Index])</l>
<l>    read_image (ImageB, ImageFilesBottom[Index])</l>
<c>    </c>
<l>    I40AlignAllAndGetBaseLines (ImageRight, ImageLeft, ImageB, ImageLeftAligned, ImageBottomAligned, MultiChannelImageLR, MultiChannelImageBR, ShapeModelHandel, RowBeginB, ColBeginB, RowEndB, ColEndB, RowBeginC, ColBeginC, RowEndC, ColEndC)</l>
<l>    stop ()</l>
<l>endfor</l>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="GenVisibleMeasureRect">
<interface>
<oo>
<par name="ROI_0" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="rect1_row" base_type="ctrl" dimension="0"/>
<par name="rect1_col" base_type="ctrl" dimension="0"/>
<par name="rect1_rad" base_type="ctrl" dimension="0"/>
<par name="rect1_len1" base_type="ctrl" dimension="0"/>
<par name="rect1_len2" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MeasureHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>gen_rectangle2 (ROI_0, rect1_row, rect1_col, rect1_rad, rect1_len1, rect1_len2)</l>
<l>gen_measure_rectangle2 (rect1_row, rect1_col, rect1_rad, rect1_len1, rect1_len2, Width, Height, 'nearest_neighbor', MeasureHandle)</l>
<l>return ()</l>
</body>
<docu id="GenVisibleMeasureRect">
<parameters>
<parameter id="Height"/>
<parameter id="MeasureHandle"/>
<parameter id="ROI_0"/>
<parameter id="Width"/>
<parameter id="rect1_col"/>
<parameter id="rect1_len1"/>
<parameter id="rect1_len2"/>
<parameter id="rect1_rad"/>
<parameter id="rect1_row"/>
</parameters>
</docu>
</procedure>
<procedure name="VisionProStyleFindLine">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ROI_0" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="rect1_row" base_type="ctrl" dimension="0"/>
<par name="rect1_col" base_type="ctrl" dimension="0"/>
<par name="rect1_rad" base_type="ctrl" dimension="0"/>
<par name="rect1_len1" base_type="ctrl" dimension="0"/>
<par name="rect1_len2" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="sigma" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
<par name="usingPairs" base_type="ctrl" dimension="0"/>
<par name="whichEdgePair" base_type="ctrl" dimension="0"/>
<par name="minEdge" base_type="ctrl" dimension="0"/>
<par name="maxEdge" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>Xs := []</l>
<l>Ys := []</l>
<c></c>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<c></c>
<c></c>
<l>leftFaced := rect1_rad&lt;rad(-90) or rect1_rad&gt;rad(90)</l>
<l>rect1_deg := deg(rect1_rad)</l>
<c></c>
<l>gen_rectangle2 (ROI_0, rect1_row, rect1_col, rect1_rad, rect1_len1, rect1_len2)</l>
<l>widthSubRects := rect1_len2/numSubRects*2</l>
<l>heightSubRects := rect1_len1*2</l>
<c></c>
<l>if(leftFaced)</l>
<l>    betaDeg := -rect1_deg - 90</l>
<l>rectStartX := rect1_col - rect1_len2 * cos(rad(betaDeg))</l>
<l>rectStartY := rect1_row - rect1_len2 * sin(rad(betaDeg))</l>
<l>subRectXIncrement := widthSubRects * cos(rad(betaDeg))</l>
<l>subRectYIncrement := sqrt(widthSubRects*widthSubRects-subRectXIncrement*subRectXIncrement)</l>
<l>firstSubRectCenterX := rectStartX + subRectXIncrement*0.5</l>
<l>firstSubRectCenterY := rectStartY + subRectYIncrement * 0.5</l>
<l>else</l>
<l>    betaDeg := 90 + rect1_deg</l>
<l>rectStartX := rect1_col + rect1_len2 * cos(rad(betaDeg))</l>
<l>rectStartY := rect1_row - rect1_len2 * sin(rad(betaDeg))</l>
<l>subRectXIncrement := -widthSubRects * cos(rad(betaDeg))</l>
<l>subRectYIncrement := sqrt(widthSubRects*widthSubRects-subRectXIncrement*subRectXIncrement)</l>
<l>firstSubRectCenterX := rectStartX + subRectXIncrement*0.5</l>
<l>firstSubRectCenterY := rectStartY + subRectYIncrement * 0.5</l>
<l>endif</l>
<c></c>
<c></c>
<l>for Index := 0 to numSubRects-1 by 1</l>
<c>    </c>
<l>    if(leftFaced)</l>
<l>         subRectCenterX := firstSubRectCenterX + Index*subRectXIncrement</l>
<l>   subRectCenterY := firstSubRectCenterY + Index*subRectYIncrement </l>
<l>   subRectLen1 := rect1_len1</l>
<l>   subRectLen2 := rect1_len2/numSubRects</l>
<l>   subRectPhi := rect1_rad</l>
<l>    else</l>
<l>           subRectCenterX := firstSubRectCenterX + Index*subRectXIncrement</l>
<l>   subRectCenterY := firstSubRectCenterY + Index*subRectYIncrement </l>
<l>   subRectLen1 := rect1_len1</l>
<l>   subRectLen2 := rect1_len2/numSubRects</l>
<l>   subRectPhi := rect1_rad</l>
<l>    endif</l>
<c>    </c>
<l>   gen_rectangle2 (Rectangle, subRectCenterY, subRectCenterX, subRectPhi, subRectLen1, subRectLen2)</l>
<l>   gen_measure_rectangle2 (subRectCenterY, subRectCenterX, subRectPhi, subRectLen1, subRectLen2, Width, Height, 'nearest_neighbor', MeasureHandle1)</l>
<c>   </c>
<l>   if(usingPairs == 'false')</l>
<l>          measure_pos (Image, MeasureHandle1, sigma, threshold, transition, firstOrLast, RowEdge1, ColumnEdge1, Amplitude1, Distance1)</l>
<l>          Xs := [Xs,ColumnEdge1]</l>
<l>          Ys := [Ys, RowEdge1]</l>
<l>   else</l>
<l>       measure_pairs (Image, MeasureHandle1, sigma, threshold, transition, whichEdgePair, RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)</l>
<c>       * only count if edge with is within range</c>
<l>       if(|IntraDistance|&gt;0 and IntraDistance &gt; minEdge and IntraDistance &lt; maxEdge)</l>
<l>           if(firstOrLast == 'first')</l>
<l>               Xs := [Xs,ColumnEdgeFirst]</l>
<l>               Ys := [Ys, RowEdgeFirst]</l>
<l>           else</l>
<l>                 Xs := [Xs,ColumnEdgeSecond]</l>
<l>               Ys := [Ys, RowEdgeSecond]</l>
<l>*                      Xs := [Xs,(ColumnEdgeSecond + ColumnEdgeFirst) / 2.0]</l>
<l>*                Ys := [Ys, (RowEdgeSecond+RowEdgeFirst)/2.0]</l>
<l>           endif</l>
<l>       endif</l>
<c>       </c>
<l>   endif</l>
<l>                close_measure (MeasureHandle1)</l>
<c></c>
<c>   </c>
<c></c>
<l>endfor</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="VisionProStyleFindLine">
<parameters>
<parameter id="Image"/>
<parameter id="ROI_0"/>
<parameter id="Xs"/>
<parameter id="Ys"/>
<parameter id="firstOrLast"/>
<parameter id="maxEdge">
<sem_type>real</sem_type>
</parameter>
<parameter id="minEdge">
<default_value>0</default_value>
<sem_type>real</sem_type>
</parameter>
<parameter id="numSubRects"/>
<parameter id="rect1_col"/>
<parameter id="rect1_len1"/>
<parameter id="rect1_len2"/>
<parameter id="rect1_rad"/>
<parameter id="rect1_row"/>
<parameter id="sigma">
<default_value>1</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
</parameter>
<parameter id="threshold"/>
<parameter id="transition"/>
<parameter id="usingPairs">
<default_value>'false'</default_value>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="whichEdgePair">
<default_value>'first'</default_value>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="FitLine2D">
<interface>
<ic>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
<par name="ignorePortion" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>fit_line2D_rough (Xs, Ys, lineX1, lineY1, lineX2, lineY2)</l>
<c></c>
<l>totalPoints := |Xs|</l>
<c>* number of points to ignore</c>
<l>numPointsLeft := (1.0-ignorePortion) * |Xs|</l>
<c></c>
<c>* calculate fitness of each point</c>
<l>fiterrors := []</l>
<l>for i := 0 to |Xs|-1 by 1</l>
<l>    distance_pl (Ys[i], Xs[i], lineY1, lineX1, lineY2, lineX2, Distance)</l>
<l>    fiterrors := [fiterrors, Distance]</l>
<l>endfor</l>
<c></c>
<l>tuple_sort_index (fiterrors, Indices)</l>
<c></c>
<c>* select the best fits</c>
<l>XsUsed := []</l>
<l>YsUsed := []</l>
<l>XsIgnored := []</l>
<l>YsIgnored := []</l>
<l>ErrorBest := []</l>
<l>for i := 0 to totalPoints-1 by 1</l>
<l>    index := Indices[i]</l>
<l>   if(i &lt; numPointsLeft)</l>
<l>           XsUsed := [XsUsed, Xs[index]]</l>
<l>    YsUsed := [YsUsed, Ys[index]]</l>
<l>    ErrorBest := [ErrorBest, fiterrors[index]]</l>
<l>   else</l>
<l>       XsIgnored := [XsIgnored, Xs[index]]</l>
<l>       YsIgnored := [YsIgnored, Ys[index]]</l>
<l>   endif</l>
<l>endfor</l>
<c></c>
<c>* fit line again</c>
<l>fit_line2D_rough (XsUsed, YsUsed, lineX1, lineY1, lineX2, lineY2)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="FitLine2D">
<parameters>
<parameter id="Xs"/>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="Ys"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="ignorePortion"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
</parameters>
</docu>
</procedure>
<procedure name="move_point_along_line">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineDirectionX" base_type="ctrl" dimension="0"/>
<par name="lineDirectionY" base_type="ctrl" dimension="0"/>
<par name="distance" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineMovedX" base_type="ctrl" dimension="0"/>
<par name="lineMovedY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>xDiff := lineDirectionX - lineStartX</l>
<l>yDiff := lineDirectionY - lineStartY</l>
<l>totalDiff := sqrt(yDiff*yDiff+xDiff*xDiff)</l>
<l>xDirection := xDiff / totalDiff</l>
<l>yDirection := yDiff / totalDiff</l>
<l>lineMovedX := lineStartX + xDirection * distance</l>
<l>lineMovedY := lineStartY + yDirection * distance</l>
<l>return ()</l>
</body>
<docu id="move_point_along_line">
<parameters>
<parameter id="distance"/>
<parameter id="lineDirectionX"/>
<parameter id="lineDirectionY"/>
<parameter id="lineMovedX"/>
<parameter id="lineMovedY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
</parameters>
</docu>
</procedure>
<procedure name="get_perpendicular_line_that_passes">
<interface>
<ic>
<par name="lineXStart" base_type="ctrl" dimension="0"/>
<par name="lineYStart" base_type="ctrl" dimension="0"/>
<par name="lineXEnd" base_type="ctrl" dimension="0"/>
<par name="lineYEnd" base_type="ctrl" dimension="0"/>
<par name="xPass" base_type="ctrl" dimension="0"/>
<par name="yPass" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineXPerpendicular" base_type="ctrl" dimension="0"/>
<par name="lineYPerpendicular" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>GetLineUnitVector (lineXStart, lineYStart, lineXEnd, lineYEnd, xUnit, yUnit)</l>
<l>get_perpendicular_direction (xUnit, yUnit, outputVectorX, outputVectorY)</l>
<c></c>
<c>* another point on the perpendicular line can be determined by</c>
<c>* adding perpendicular unit vector to the first point that we passed</c>
<l>lineXPerpendicular := xPass + outputVectorX</l>
<l>lineYPerpendicular := yPass + outputVectorY</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_perpendicular_line_that_passes">
<abstract lang="en_US">Note lineXYPerpendicular is not the intersection point</abstract>
<parameters>
<parameter id="lineXEnd"/>
<parameter id="lineXPerpendicular"/>
<parameter id="lineXStart"/>
<parameter id="lineYEnd"/>
<parameter id="lineYPerpendicular"/>
<parameter id="lineYStart"/>
<parameter id="xPass"/>
<parameter id="yPass"/>
</parameters>
</docu>
</procedure>
<procedure name="GetLineUnitVector">
<interface>
<ic>
<par name="xStart" base_type="ctrl" dimension="0"/>
<par name="yStart" base_type="ctrl" dimension="0"/>
<par name="xEnd" base_type="ctrl" dimension="0"/>
<par name="yEnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="xUnit" base_type="ctrl" dimension="0"/>
<par name="yUnit" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>xDiff := xEnd - xStart</l>
<l>yDiff := yEnd - yStart</l>
<c></c>
<l>totalDiff := sqrt(yDiff*yDiff + xDiff*xDiff)</l>
<c></c>
<l>xUnit := xDiff / totalDiff</l>
<l>yUnit := yDiff / totalDiff</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetLineUnitVector">
<abstract lang="zh_CN">Get unit vector from point start to point end</abstract>
<parameters>
<parameter id="xEnd"/>
<parameter id="xStart"/>
<parameter id="xUnit"/>
<parameter id="yEnd"/>
<parameter id="yStart"/>
<parameter id="yUnit"/>
</parameters>
</docu>
</procedure>
<procedure name="get_perpendicular_direction">
<interface>
<ic>
<par name="inputVectorX" base_type="ctrl" dimension="0"/>
<par name="inputVectorY" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outputVectorX" base_type="ctrl" dimension="0"/>
<par name="outputVectorY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*Should be deprecated</c>
<l>inputVectorY := inputVectorY + 0.000001</l>
<c>* assume that a perticular vector perpendiclar to me is (xAssume, yAssume), let xAssume = 1</c>
<l>xAssume := 1</l>
<l>yAssume := -(inputVectorX/inputVectorY)</l>
<l>distAssume := sqrt(yAssume*yAssume + xAssume * xAssume)</l>
<c></c>
<c>* calculate unit length direction vector</c>
<l>outputVectorX := xAssume / distAssume</l>
<l>outputVectorY := yAssume / distAssume</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_perpendicular_direction">
<parameters>
<parameter id="inputVectorX"/>
<parameter id="inputVectorY"/>
<parameter id="outputVectorX"/>
<parameter id="outputVectorY"/>
</parameters>
</docu>
</procedure>
<procedure name="fit_line2D_rough">
<interface>
<ic>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if(|Xs| == 0)</l>
<l>    throw ('No points being passed in')</l>
<l>endif</l>
<c></c>
<c>* determine if a line is vertical</c>
<l>tuple_deviation (Xs, DeviationX)</l>
<l>tuple_deviation (Ys, DeviationY)</l>
<l>isVertical := DeviationY &gt; DeviationX</l>
<l>if(isVertical)</l>
<l>   swap (Xs, Ys, Xs, Ys)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>tuple_sum (Xs, SumX)</l>
<l>AverageX := SumX / |Xs|</l>
<c></c>
<l>tuple_sum (Ys, SumY)</l>
<l>AverageY := SumY / |Ys|</l>
<c></c>
<l>SumUpper := 0</l>
<l>SumLower := 0</l>
<l>for i := 0 to |Xs|-1 by 1</l>
<l>    incrementUpper := (Xs[i]-AverageX) * (Ys[i]-AverageY)</l>
<l>    incrementLower := (AverageX-Xs[i]) * (AverageX-Xs[i])</l>
<l>    SumUpper := SumUpper + incrementUpper</l>
<l>    SumLower := SumLower + incrementLower</l>
<l>endfor</l>
<c></c>
<l>m := SumUpper / SumLower</l>
<l>b := AverageY - m*AverageX </l>
<c></c>
<c></c>
<c></c>
<c>* sample two point</c>
<l>tuple_max (Xs, lineX1)</l>
<l>tuple_min (Xs, lineX2)</l>
<c></c>
<l>lineY1 := m * lineX1 + b</l>
<l>lineY2 := m * lineX2 + b</l>
<c></c>
<l>if(isVertical)</l>
<l>   swap (lineX1, lineY1, lineX1, lineY1)</l>
<l>   swap (lineX2, lineY2, lineX2, lineY2)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="fit_line2D_rough">
<parameters>
<parameter id="Xs"/>
<parameter id="Ys"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
</parameters>
</docu>
</procedure>
<procedure name="VisionProStyleFindLineOneStep">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRegion" base_type="iconic" dimension="0"/>
<par name="lineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
<par name="ignoreFraction" base_type="ctrl" dimension="0"/>
<par name="isVertical" base_type="ctrl" dimension="0"/>
<par name="sigma1" base_type="ctrl" dimension="0"/>
<par name="sigma2" base_type="ctrl" dimension="0"/>
<par name="imageWidth" base_type="ctrl" dimension="0"/>
<par name="imageHeight" base_type="ctrl" dimension="0"/>
<par name="newWidth" base_type="ctrl" dimension="0"/>
<par name="cannyHigh" base_type="ctrl" dimension="0"/>
<par name="cannyLow" base_type="ctrl" dimension="0"/>
<par name="kernelWidth" base_type="ctrl" dimension="0"/>
<par name="longestOnly" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>MultipleLines := 'false'</l>
<l>if (|row| &gt; 1)</l>
<l>    MultipleLines := 'true'</l>
<l>endif</l>
<c></c>
<l>EdgesX := []</l>
<l>EdgesY := []</l>
<l>AllXsUsed := []</l>
<l>AllYsUsed := []</l>
<l>AllXsIgnored := []</l>
<l>AllYsIgnored := []</l>
<c></c>
<l>gen_empty_obj (findLineRegions)</l>
<l>gen_empty_obj (lineRegions)</l>
<c></c>
<l>for i:= 0 to |row|-1 by 1</l>
<l>    VisionProStyleFindLine (inputImage, findLineRegion, transition, row[i], col[i], radian[i], len1[i], len2[i], numSubRects, threshold[i], sigma1, firstOrLast, 'false', 'first', 0, 100, Xs, Ys)</l>
<c></c>
<l>    if(isVertical == 'true')</l>
<l>        FitLine2D (Ys, Xs, ignoreFraction, lineY1, lineX1, lineY2, lineX2, YsUsed, XsUsed, YsIgnored, XsIgnored)</l>
<l>    else</l>
<l>        FitLine2D (Xs, Ys, ignoreFraction, lineX1, lineY1, lineX2, lineY2, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>    endif</l>
<c>    </c>
<l>*     _genSubRect2(findLineRegion, row[i], col[i], radian[i], len1[i], len2[i], lineX1, lineY1, lineX2, lineY2, newWidth)</l>
<l>    _pinPointFindLine (inputImage, findLineRegion1, lineX1, lineX2, lineY1, lineY2, radian, newWidth, MultipleLines, cannyHigh, cannyLow, sigma2, kernelWidth, longestOnly, RowBegin, ColBegin, RowEnd, ColEnd, EdgesXStep, EdgesYStep)</l>
<c></c>
<l>    if(MultipleLines == 'true')</l>
<l>        EdgesX := [EdgesX, EdgesXStep]</l>
<l>        EdgesY := [EdgesY, EdgesYStep]</l>
<l>        concat_obj (findLineRegions, findLineRegion, findLineRegions)</l>
<l>        AllXsUsed := [AllXsUsed, Xs]</l>
<l>        AllYsUsed := [AllYsUsed, Ys]</l>
<l>        AllXsIgnored := [AllXsIgnored, XsIgnored]</l>
<l>        AllYsIgnored := [AllYsIgnored, YsIgnored]</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>if(MultipleLines == 'true')</l>
<l>    FitLine2D (EdgesX, EdgesY,ignoreFraction, ColBegin, RowBegin, ColEnd, RowEnd, _, _, _, _)</l>
<l>    findLineRegion := findLineRegions</l>
<l>    XsUsed := AllXsUsed</l>
<l>    YsUsed := AllYsUsed</l>
<l>    XsIgnored := AllXsIgnored</l>
<l>    YsIgnored := AllYsIgnored</l>
<l>endif</l>
<c></c>
<c></c>
<l>GenLineRegion (lineRegion, ColBegin, RowBegin, ColEnd, RowEnd, imageWidth, imageHeight)</l>
<l>lineX1 := ColBegin</l>
<l>lineY1 := RowBegin</l>
<l>lineX2 := ColEnd</l>
<l>lineY2 := RowEnd</l>
<l>return ()</l>
</body>
<docu id="VisionProStyleFindLineOneStep">
<parameters>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="cannyHigh">
<default_value>60</default_value>
<sem_type>real</sem_type>
</parameter>
<parameter id="cannyLow">
<default_value>30</default_value>
</parameter>
<parameter id="col"/>
<parameter id="findLineRegion">
<description lang="zh_CN">The region where the line was searched</description>
</parameter>
<parameter id="firstOrLast"/>
<parameter id="ignoreFraction"/>
<parameter id="imageHeight">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="imageWidth">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="inputImage"/>
<parameter id="isVertical"/>
<parameter id="kernelWidth"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="lineRegion">
<description lang="zh_CN">The found line</description>
</parameter>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="longestOnly"/>
<parameter id="newWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="numSubRects"/>
<parameter id="radian"/>
<parameter id="row"/>
<parameter id="sigma1">
<default_type>real</default_type>
<default_value>1</default_value>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="sigma2"/>
<parameter id="threshold"/>
<parameter id="transition"/>
</parameters>
</docu>
</procedure>
<procedure name="TranslateLineInWorldCoordinateAndConvertBack">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineEndX" base_type="ctrl" dimension="0"/>
<par name="lineEndY" base_type="ctrl" dimension="0"/>
<par name="distance" base_type="ctrl" dimension="0"/>
<par name="mapToWorld" base_type="ctrl" dimension="0"/>
<par name="mapToImage" base_type="ctrl" dimension="0"/>
<par name="isVertical" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outLineStartX" base_type="ctrl" dimension="0"/>
<par name="outLineStartY" base_type="ctrl" dimension="0"/>
<par name="outLineEndX" base_type="ctrl" dimension="0"/>
<par name="outLineEndY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if(isVertical == 'true')</l>
<l>    SortLineUpDown (lineStartX, lineStartY, lineEndX, lineEndY, lineStartX, lineStartY, lineEndX, lineEndY)</l>
<l>elseif (isVertical == 'false')</l>
<l>    SortLineLeftRight (lineStartX, lineStartY, lineEndX, lineEndY, lineStartX, lineStartY, lineEndX, lineEndY)</l>
<l>else</l>
<l>    throw ('Unknow param &lt;isVertical&gt;')</l>
<l>endif</l>
<c></c>
<l>affine_trans_point_2d (mapToWorld, lineStartX, lineStartY, X1World, Y1World)</l>
<l>affine_trans_point_2d (mapToWorld, lineEndX, lineEndY, X2World, Y2World)</l>
<c></c>
<l>GetParallelLine (X1World, Y1World, X2World, Y2World, distance, X1WorldTranslated, Y1WorldTranslated, X2WorldTranslated, Y2WorldTranslated)</l>
<c></c>
<l>affine_trans_point_2d (mapToImage, X1WorldTranslated, Y1WorldTranslated, outLineStartX, outLineStartY)</l>
<l>affine_trans_point_2d (mapToImage, X2WorldTranslated, Y2WorldTranslated, outLineEndX, outLineEndY)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="TranslateLineInWorldCoordinateAndConvertBack">
<parameters>
<parameter id="distance"/>
<parameter id="isVertical">
<sem_type>string</sem_type>
</parameter>
<parameter id="lineEndX"/>
<parameter id="lineEndY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
<parameter id="mapToImage"/>
<parameter id="mapToWorld"/>
<parameter id="outLineEndX"/>
<parameter id="outLineEndY"/>
<parameter id="outLineStartX"/>
<parameter id="outLineStartY"/>
</parameters>
</docu>
</procedure>
<procedure name="DistancePLInWorld">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineEndX" base_type="ctrl" dimension="0"/>
<par name="lineEndY" base_type="ctrl" dimension="0"/>
<par name="ptX" base_type="ctrl" dimension="0"/>
<par name="ptY" base_type="ctrl" dimension="0"/>
<par name="mapToWorld" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="distanceWorld" base_type="ctrl" dimension="0"/>
<par name="distancePixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>distance_pl (ptY, ptX, lineStartY, lineStartX, lineEndY, lineEndX, distancePixel)</l>
<c></c>
<c></c>
<c></c>
<l>affine_trans_point_2d (mapToWorld, ptX, ptY, ptXWorld, ptYWorld)</l>
<l>affine_trans_point_2d (mapToWorld, lineStartX, lineStartY, X1World, Y1World)</l>
<l>affine_trans_point_2d (mapToWorld, lineEndX, lineEndY, X2World, Y2World)</l>
<c></c>
<c></c>
<l>distance_pl (ptYWorld, ptXWorld, Y1World, X1World, Y2World, X2World, distanceWorld)</l>
<l>return ()</l>
</body>
<docu id="DistancePLInWorld">
<parameters>
<parameter id="distancePixel"/>
<parameter id="distanceWorld"/>
<parameter id="lineEndX"/>
<parameter id="lineEndY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
<parameter id="mapToWorld"/>
<parameter id="ptX"/>
<parameter id="ptY"/>
</parameters>
</docu>
</procedure>
<procedure name="VisionProStyleFindLineOneStep_Pairs">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRegion" base_type="iconic" dimension="0"/>
<par name="lineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="sigma1" base_type="ctrl" dimension="0"/>
<par name="sigma2" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
<par name="isVertical" base_type="ctrl" dimension="0"/>
<par name="ignoreFraction" base_type="ctrl" dimension="0"/>
<par name="whichEdgePair" base_type="ctrl" dimension="0"/>
<par name="minEdge" base_type="ctrl" dimension="0"/>
<par name="maxEdge" base_type="ctrl" dimension="0"/>
<par name="imageWidth" base_type="ctrl" dimension="0"/>
<par name="imageHeight" base_type="ctrl" dimension="0"/>
<par name="cannyHigh" base_type="ctrl" dimension="0"/>
<par name="cannyLow" base_type="ctrl" dimension="0"/>
<par name="useXLD" base_type="ctrl" dimension="0"/>
<par name="newWidth" base_type="ctrl" dimension="0"/>
<par name="kernelWidth" base_type="ctrl" dimension="0"/>
<par name="longestOnly" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>MultipleLines := 'false'</l>
<l>if (|row| &gt; 1)</l>
<l>    MultipleLines := 'true'</l>
<l>endif</l>
<c></c>
<l>EdgesX := []</l>
<l>EdgesY := []</l>
<l>AllXsUsed := []</l>
<l>AllYsUsed := []</l>
<l>AllXsIgnored := []</l>
<l>AllYsIgnored := []</l>
<c></c>
<l>gen_empty_obj (findLineRegions)</l>
<l>gen_empty_obj (lineRegions)</l>
<c></c>
<l>for i:= 0 to |row|-1 by 1</l>
<l>    VisionProStyleFindLine (inputImage, findLineRegion, transition, row[i], col[i], radian[i], len1[i], len2[i], numSubRects, threshold[i], sigma1, firstOrLast, 'true', whichEdgePair, minEdge, maxEdge, Xs, Ys)</l>
<c></c>
<l>    if(isVertical == 'true')</l>
<l>        FitLine2D (Ys, Xs, ignoreFraction, lineY1, lineX1, lineY2, lineX2, YsUsed, XsUsed, YsIgnored, XsIgnored)</l>
<l>    else</l>
<l>        FitLine2D (Xs, Ys, ignoreFraction, lineX1, lineY1, lineX2, lineY2, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>    endif</l>
<c></c>
<l>        _genSubRect2(findLineRegion, row[i], col[i], radian[i], len1[i], len2[i], lineX1, lineY1, lineX2, lineY2, newWidth)</l>
<c></c>
<l>    _pinPointFindLine (inputImage, findLineRegion, lineX1, lineX2, lineY1, lineY2, radian, 5, MultipleLines, cannyHigh, cannyLow, sigma2, kernelWidth, longestOnly, RowBegin, ColBegin, RowEnd, ColEnd, EdgesXStep, EdgesYStep)</l>
<c></c>
<l>    if(MultipleLines == 'true')</l>
<l>        EdgesX := [EdgesX, EdgesXStep]</l>
<l>        EdgesY := [EdgesY, EdgesYStep]</l>
<l>        concat_obj (findLineRegions, findLineRegion, findLineRegions)</l>
<l>        AllXsUsed := [AllXsUsed, Xs]</l>
<l>        AllYsUsed := [AllYsUsed, Ys]</l>
<l>        AllXsIgnored := [AllXsIgnored, XsIgnored]</l>
<l>        AllYsIgnored := [AllYsIgnored, YsIgnored]</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>if(MultipleLines == 'true')</l>
<l>    if(useXLD == 'false')</l>
<l>        EdgesX := XsUsed</l>
<l>        EdgesY := YsUsed</l>
<l>    endif</l>
<l>    FitLine2D (EdgesX, EdgesY, 0, ColBegin, RowBegin, ColEnd, RowEnd, _, _, _, _)</l>
<l>    findLineRegion := findLineRegions</l>
<l>    XsUsed := AllXsUsed</l>
<l>    YsUsed := AllYsUsed</l>
<l>    XsIgnored := AllXsIgnored</l>
<l>    YsIgnored := AllYsIgnored</l>
<l>endif</l>
<c></c>
<c></c>
<l>GenLineRegion (lineRegion, ColBegin, RowBegin, ColEnd, RowEnd, imageWidth, imageHeight)</l>
<l>lineX1 := ColBegin</l>
<l>lineY1 := RowBegin</l>
<l>lineX2 := ColEnd</l>
<l>lineY2 := RowEnd</l>
<l>return ()</l>
</body>
<docu id="VisionProStyleFindLineOneStep_Pairs">
<parameters>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="cannyHigh"/>
<parameter id="cannyLow"/>
<parameter id="col">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="findLineRegion">
<description lang="zh_CN">The region where the line was searched</description>
</parameter>
<parameter id="firstOrLast">
<default_value>'first'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="ignoreFraction">
<sem_type>real</sem_type>
</parameter>
<parameter id="imageHeight">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="imageWidth">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="inputImage"/>
<parameter id="isVertical">
<default_value>'false'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="kernelWidth"/>
<parameter id="len1">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="len2">
<default_type>real</default_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="lineRegion">
<description lang="zh_CN">The found line</description>
</parameter>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="longestOnly"/>
<parameter id="maxEdge">
<sem_type>real</sem_type>
</parameter>
<parameter id="minEdge">
<sem_type>real</sem_type>
</parameter>
<parameter id="newWidth"/>
<parameter id="numSubRects">
<default_type>integer</default_type>
<default_value>10</default_value>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="radian">
<default_type>real</default_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="row">
<default_type>integer</default_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="sigma1">
<sem_type>real</sem_type>
</parameter>
<parameter id="sigma2"/>
<parameter id="threshold">
<sem_type>number</sem_type>
</parameter>
<parameter id="transition">
<default_value>'positive'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="useXLD">
<default_value>'false'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="whichEdgePair">
<default_value>'first'</default_value>
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="_affineTransRect2Single">
<interface>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="map" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="rowOut" base_type="ctrl" dimension="0"/>
<par name="colOut" base_type="ctrl" dimension="0"/>
<par name="radianOut" base_type="ctrl" dimension="0"/>
<par name="len1Out" base_type="ctrl" dimension="0"/>
<par name="len2Out" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>affine_trans_point_2d (map, row, col, rowOut, colOut)</l>
<l>len1Out := len1</l>
<l>len2Out := len2</l>
<c></c>
<l>topCenterCol := col + cos(radian) * len1</l>
<l>topCenterRow := row - sin(radian) * len2</l>
<c></c>
<l>affine_trans_point_2d (map, topCenterRow, topCenterCol, topCenterRowTrans, topCenterColTrans)</l>
<c></c>
<c></c>
<c></c>
<l>vecCol := topCenterColTrans - colOut</l>
<l>vecRow := topCenterRowTrans - rowOut</l>
<l>epslon := 0.0000000001</l>
<l>if(abs(vecRow) &lt; epslon)</l>
<l>    vecRow := epslon</l>
<l>endif</l>
<c></c>
<l>if(vecCol &gt;=0 and vecRow &gt;=0)</l>
<c>    * 右下</c>
<l>    radianOut := -atan(vecRow / vecCol)</l>
<l>elseif (vecCol &gt;= 0 and vecRow &lt; 0)</l>
<c>    * 右上</c>
<l>    radianOut := -atan(vecRow / vecCol)</l>
<l>elseif (vecCol &lt; 0 and vecRow &gt;=0)</l>
<c>    * 左下</c>
<l>     radianOut := rad(-180) - atan(vecRow / vecCol)</l>
<l>else</l>
<c>    * 左上</c>
<l>     radianOut := rad(180) - atan(vecRow / vecCol)</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_affineTransRect2Single">
<parameters>
<parameter id="col"/>
<parameter id="colOut"/>
<parameter id="len1"/>
<parameter id="len1Out"/>
<parameter id="len2"/>
<parameter id="len2Out"/>
<parameter id="map"/>
<parameter id="radian"/>
<parameter id="radianOut"/>
<parameter id="row"/>
<parameter id="rowOut"/>
</parameters>
</docu>
</procedure>
<procedure name="GenLineRegion">
<interface>
<oo>
<par name="lineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lineXStart" base_type="ctrl" dimension="0"/>
<par name="lineYStart" base_type="ctrl" dimension="0"/>
<par name="lineXEnd" base_type="ctrl" dimension="0"/>
<par name="lineYEnd" base_type="ctrl" dimension="0"/>
<par name="imageWidth" base_type="ctrl" dimension="0"/>
<par name="imageHeight" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>if(|lineXStart| == 0)</l>
<l>    throw ('No points passed in')</l>
<l>endif</l>
<l>xDiff := lineXEnd - lineXStart</l>
<l>yDiff := lineYEnd - lineYStart</l>
<c></c>
<l>epslon := 0.0000000001</l>
<l>if(abs(xDiff) &lt; epslon)</l>
<l>    xDiff := epslon</l>
<l>endif</l>
<c></c>
<l>m := yDiff/xDiff</l>
<l>b := lineYStart - m* lineXStart</l>
<c></c>
<l>ImageLineIntersections (m, b, imageWidth, imageHeight, xStart, yStart, xEnd, yEnd)</l>
<c></c>
<l>gen_contour_polygon_xld(lineRegion,[yStart,yEnd],[xStart,xEnd])</l>
<l>return ()</l>
</body>
<docu id="GenLineRegion">
<parameters>
<parameter id="imageHeight">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="imageWidth">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="lineRegion"/>
<parameter id="lineXEnd"/>
<parameter id="lineXStart"/>
<parameter id="lineYEnd"/>
<parameter id="lineYStart"/>
</parameters>
</docu>
</procedure>
<procedure name="I94TopFaceMeasurementOverflow">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageUndistorted" base_type="iconic" dimension="0"/>
<par name="lineRegions" base_type="iconic" dimension="0"/>
<par name="FindLineRects" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="xCoeff" base_type="ctrl" dimension="0"/>
<par name="yCoeff" base_type="ctrl" dimension="0"/>
<par name="FindLineNames" base_type="ctrl" dimension="0"/>
<par name="thresholds" base_type="ctrl" dimension="0"/>
<par name="IgnorePortions" base_type="ctrl" dimension="0"/>
<par name="Sigma1s" base_type="ctrl" dimension="0"/>
<par name="Sigma2s" base_type="ctrl" dimension="0"/>
<par name="NewWidths" base_type="ctrl" dimension="0"/>
<par name="CannyLows" base_type="ctrl" dimension="0"/>
<par name="CannyHighs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outputs" base_type="ctrl" dimension="0"/>
<par name="crossesXused" base_type="ctrl" dimension="0"/>
<par name="crossesYused" base_type="ctrl" dimension="0"/>
<par name="crossesXIgnored" base_type="ctrl" dimension="0"/>
<par name="crossesYIgnored" base_type="ctrl" dimension="0"/>
<par name="intersectXs" base_type="ctrl" dimension="0"/>
<par name="intersectYs" base_type="ctrl" dimension="0"/>
<par name="outputsPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CameraParameters := ['area_scan_telecentric_division',0.588471,3.42746,4.4974e-006,4.5e-006,2556.48,2560.7,5120,5120]</l>
<l>CameraPose := [0.00180843,-0.000646214,0.000999199,0.316458,2.27204,180.151,0]</l>
<l>UndistortImage (Image, Image, CameraParameters, OutCameraParams)</l>
<l>ImageUndistorted := Image</l>
<c></c>
<l>GenCalibrationMaps (Image, OutCameraParams, CameraPose, MapToWorld, MapToImage)</l>
<c></c>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<c></c>
<c></c>
<l>dev_set_draw ('margin')</l>
<c></c>
<l>crossSize := 100</l>
<l>numSubRects := 10</l>
<c></c>
<l>ModelThreshold := 70</l>
<c></c>
<c></c>
<c>* record find line points</c>
<l>crossesXused := []</l>
<l>crossesYused := []</l>
<l>crossesXIgnored := []</l>
<l>crossesYIgnored := []</l>
<c></c>
<c>* record line-line intersections</c>
<l>intersectXs := []</l>
<l>intersectYs := []</l>
<c></c>
<c>* outputs</c>
<l>outputs := []</l>
<l>outputsPixel := []</l>
<c></c>
<c>* set units and positions</c>
<c></c>
<c></c>
<l>FAI2_LEN_P1 := 4.583 </l>
<l>FAI2_LEN_P2 := 9 </l>
<l>FAI2_LEN_P3 := 14.583 </l>
<c></c>
<l>FAI3_LEN_P1 := 5.299 </l>
<l>FAI3_LEN_P2 := 9</l>
<l>FAI3_LEN_P3 := 13.299 </l>
<c></c>
<l>FAI4_LEN_P1 := 5.299</l>
<l>FAI4_LEN_P2 := 9.299</l>
<l>FAI4_LEN_P3 := 13.299</l>
<c></c>
<l>FAI5_LEN_P1 := 5.299</l>
<l>FAI5_LEN_P2 := 9.299</l>
<l>FAI5_LEN_P3 := 13.299</l>
<c></c>
<l>FAI6_LEN_P1 := 22.024 </l>
<l>FAI6_LEN_P2 := 24.024 </l>
<l>FAI6_LEN_P3 := 26.024 </l>
<c></c>
<l>FAI9_LEN_P1 := 21.753 </l>
<l>FAI9_LEN_P2 := 23.753</l>
<l>FAI9_LEN_P3 := 25.753</l>
<c></c>
<c></c>
<l>FAI12_LEN_P1 := 23.213</l>
<l>FAI12_LEN_P2 := 34.97</l>
<c></c>
<l>FAI16_LEN_P1 := 13.071</l>
<l>FAI16_LEN_P2 := 20.213</l>
<c></c>
<l>FAI17_LEN_P1 := 1.53</l>
<l>FAI17_LEN_P2 := 9.827</l>
<c></c>
<l>FAI19_LEN_P1 := 2.157 </l>
<l>FAI19_LEN_P2 := 13.791 </l>
<c></c>
<l>FAI20_LEN_X := 9.299</l>
<l>FAI20_LEN_Y := 7.886 </l>
<c></c>
<l>gen_empty_obj (FindLineRects)</l>
<l>gen_empty_obj (lineRegions)</l>
<c></c>
<c></c>
<c>* find model</c>
<l>Threshold := 128</l>
<l>rowModel := 1171.5</l>
<l>colModel := 3678.5</l>
<l>gen_rectangle1 (ROI_0, 53.9, 1940.83, 2000, 3900)</l>
<l>reduce_domain (Image, ROI_0, ImageReduced)</l>
<l>binary_threshold (ImageReduced, Region, 'max_separability', 'dark', UsedThreshold)</l>
<l>connection (Region, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 800000, 99999999)</l>
<l>paint_region (SelectedRegions, ImageReduced, ImageResult, 255, 'fill')</l>
<l>find_shape_model (ImageResult, ModelID, -0.39, 0.79, 0.3, 1, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, MovementImageToImage)</l>
<c></c>
<c>* image normalization</c>
<l>* ROW_1 := 1972 - rowModel</l>
<l>* COL_1 := 4257- colModel</l>
<l>* RAD_1 := 0</l>
<l>* LEN_1 := 150</l>
<l>* LEN_2 := 150</l>
<c></c>
<l>* AffineTransRect2 (ROW_1, COL_1, RAD_1, LEN_1, LEN_2, MovementImageToImage, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>* gen_rectangle2 (Rectangle8, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>* reduce_domain (ImageReduced, Rectangle8, ImageReduced1)</l>
<l>* gray_features (Rectangle8, ImageReduced1, 'mean', Value)</l>
<l>* standardGrayValue := 140.0</l>
<l>* scaleFacotr := standardGrayValue / Value</l>
<l>* scale_image (Image, Image, scaleFacotr, 0)</l>
<c></c>
<l>ROW1_1 := 2684 - rowModel</l>
<l>COL1_1 := 4804 - colModel</l>
<l>RAD1_1 := rad(180)</l>
<l>LEN1_1 := 200</l>
<l>LEN2_1 := 350</l>
<c></c>
<l>ROW1_2 := 4380 - rowModel</l>
<l>COL1_2 := 4804 - colModel</l>
<l>RAD1_2 := rad(180)</l>
<l>LEN1_2 := 200</l>
<l>LEN2_2 := 350</l>
<c></c>
<l>baseRightRow := 3400 - rowModel</l>
<l>baseRightColum := 4804 - colModel</l>
<l>baseRightRadian := rad(180)</l>
<l>baseRightLen1 := 150</l>
<l>baseRightLen2 := 1000</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, MovementImageToImage, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<l>gen_rectangle2 (Rectangle1, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<l>GetFindLineParams ('RightBase', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, numSubRects, [threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth10, longestOnly12, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, 10, 'positive', threshValue, sigma1, sigma21, 'first', widthRatio, ignoreFraction, newWidth1, cannyLow1, cannyHigh1, kernelWidth, longestOnly, XsUsed, Ys, lineX2, lineY2, XsUsed1, YsUsed1, XsIgnored1, YsIgnored1)</l>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<c></c>
<c>* find top base line</c>
<l>ROW_1 := 162.42300000 - rowModel</l>
<l>COL_1 := 3050 - colModel</l>
<l>RAD_1 := rad(-90.00000000)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 200</l>
<c></c>
<l>ROW_2 := 162.42300000 - rowModel</l>
<l>COL_2 := 3694 - colModel</l>
<l>RAD_2 := rad(-90.00000000)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 100</l>
<c></c>
<l>ROW_3 := 162.42300000 - rowModel</l>
<l>COL_3 := 4310 - colModel</l>
<l>RAD_3 := rad(-90.00000000)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 100</l>
<c></c>
<l>baseTopRow := 162.42300000 - rowModel</l>
<l>baseTopColumn := 3694 - colModel</l>
<l>baseTopRadian := rad(-91)</l>
<l>baseTopLen1 := 100</l>
<l>baseTopLen2 := 650</l>
<c></c>
<c></c>
<c></c>
<l>AffineTransRect2 (baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, MovementImageToImage, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<l>gen_rectangle2 (Rectangle, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<l>GetFindLineParams ('TopBase', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, numSubRects, [threshValue,threshValue,threshValue], 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth11, longestOnly13, lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours1, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, 10, 'positive', threshValue, sigma1, sigma22, 'first', widthRatio1, ignoreFraction1, newWidth2, cannyLow2, cannyHigh2, kernelWidth1, longestOnly1, XsUsed, Ys1, lineX21, lineY21, XsUsed2, YsUsed2, XsIgnored2, YsIgnored2)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c></c>
<c></c>
<c>* make origin</c>
<l>intersection_lines (lineY1RightBase, lineX1RightBase, lineY2RightBase, lineX2RightBase, lineY1TopBase, lineX1TopBase, lineY2TopBase, lineX2TopBase, rowOrigin, colOrigin, IsOverlapping)</l>
<l>intersectXs := [intersectXs, colOrigin]</l>
<l>intersectYs := [intersectYs, rowOrigin]</l>
<c></c>
<c>*rectify bases</c>
<l>get_perpendicular_line_that_passes (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colOrigin, rowOrigin, ptXOnPerpenducularDir, ptYOnPerpenducularDir)</l>
<l>lineX1RightBase := colOrigin</l>
<l>lineY1RightBase := rowOrigin</l>
<l>lineX2RightBase := ptXOnPerpenducularDir</l>
<l>lineY2RightBase := ptYOnPerpenducularDir</l>
<c></c>
<c></c>
<c>****************************************************FAI2***********************************</c>
<c>* make vertical grids</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI2_LEN_P1, MapToWorld, MapToImage, 'true', FAI2_P1_LineStartX, FAI2_P1_LineStartY, FAI2_P1_LineEndX, FAI2_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI2_LEN_P2, MapToWorld, MapToImage, 'true', FAI2_P2_LineStartX, FAI2_P2_LineStartY, FAI2_P2_LineEndX, FAI2_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI2_LEN_P3, MapToWorld, MapToImage, 'true', FAI2_P3_LineStartX, FAI2_P3_LineStartY, FAI2_P3_LineEndX, FAI2_P3_LineEndY)</l>
<c></c>
<c>* make H line for FAI2</c>
<c></c>
<l>rectFAI2Row :=2145.39000000 - rowModel</l>
<l>rectFAI2Col :=3168.38000000 - colModel</l>
<l>rectFAI2Radian := rad(-91)</l>
<l>rectFAI2Len1 :=50.89500000</l>
<l>rectFAI2Len2 := 200.18000000</l>
<c></c>
<l>rectFAI2Row_RIGHT :=2160.39000000 - rowModel</l>
<l>rectFAI2Col_RIGHT :=4168.38000000 - colModel</l>
<l>rectFAI2Radian_RIGHT := rad(-91)</l>
<l>rectFAI2Len1_RIGHT :=50.89500000</l>
<l>rectFAI2Len2_RIGHT := 200.18000000</l>
<l>AffineTransRect2 ([rectFAI2Row, rectFAI2Row_RIGHT], [rectFAI2Col,rectFAI2Col_RIGHT], [rectFAI2Radian, rectFAI2Radian_RIGHT], [rectFAI2Len1, rectFAI2Len1_RIGHT], [rectFAI2Len2, rectFAI2Len2_RIGHT], MovementImageToImage, rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2)</l>
<l>gen_rectangle2 (Rectangle9, rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2)</l>
<l>GetFindLineParams ('2', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rectFAI2, lineRegion, 'negative', rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2, 10, [threshValue,threshValue], 'first', ignorePortion, 'false', sigma1, sigma2, 5120, 5120, newWidth, cannyHigh, cannyLow, kernelWidth12, longestOnly14, lineStartX_FAI2H, lineStartY_FAI2H, lineEndX_FAI2H, lineEndY_FAI2H, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>* VisionProStyleFindLineOneStep_Pairs (Image, rectFAI2, lineRegion, rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2, 'positive', 10, [threshValue,threshValue], sigma1, sigma2, 'first', 'false', ignorePortion, 'first', 1, 10, 5120, 5120, cannyHigh, cannyLow, 'false', newWidth, kernelWidth24, longestOnly10, XsUsed, YsUsed, XsIgnored, YsIgnored, lineStartX_FAI2H, lineStartY_FAI2H, lineEndX_FAI2H, lineEndY_FAI2H)</l>
<l>FindLineGradiant_Pair (Image, rectFAI2, lineRegion, rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2, 6, 0.2, 'positive', [threshValue,threshValue], sigma1, 'last', 'first', 1, 10, XsUsed, YsUsed, XsIgnored, YsIgnored, lineStartX_FAI2H, lineStartY_FAI2H, lineEndX_FAI2H, lineEndY_FAI2H)</l>
<l>concat_obj (FindLineRects, rectFAI2, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c></c>
<c>* FAI2-P2</c>
<l>intersection_lines (lineStartY_FAI2H, lineStartX_FAI2H, lineEndY_FAI2H, lineEndX_FAI2H, FAI2_P2_LineStartY, FAI2_P2_LineStartX, FAI2_P2_LineEndY, FAI2_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping1)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c>**********************************************FAI3************************************</c>
<c></c>
<c></c>
<l>rectFAI3Row :=2210.39000000 - rowModel</l>
<l>rectFAI3Col :=3168.38000000 - colModel</l>
<l>rectFAI3Radian := rad(-94)</l>
<l>rectFAI3Len1 :=40.89500000</l>
<l>rectFAI3Len2 := 200.18000000</l>
<c></c>
<l>rectFAI3Row_RIGHT :=2233.39000000 - rowModel</l>
<l>rectFAI3Col_RIGHT :=4168.38000000 - colModel</l>
<l>rectFAI3Radian_RIGHT := rad(-93)</l>
<l>rectFAI3Len1_RIGHT :=40.89500000</l>
<l>rectFAI3Len2_RIGHT := 200.18000000</l>
<l>AffineTransRect2 ([rectFAI3Row, rectFAI3Row_RIGHT], [rectFAI3Col,rectFAI3Col_RIGHT], [rectFAI3Radian, rectFAI3Radian_RIGHT], [rectFAI3Len1, rectFAI3Len1_RIGHT], [rectFAI3Len2, rectFAI3Len2_RIGHT], MovementImageToImage, rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2)</l>
<c></c>
<l>gen_rectangle2 (Rectangle7, rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2)</l>
<l>* VisionProStyleFindLineOneStep (Image, rectFAI3, lineRegion, 'positive', rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2, 10, [FAI3Threshold,FAI3Threshold], 'first', 0.2, 'false', 1, 1, 5120, 5120, 5, 15, 5, kernelWidth13, longestOnly15, lineX1FAI3, lineY1FAI3, lineX2FAI3, lineY2FAI3, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>GetFindLineParams ('3', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>FindLineAdaptiveSingle (Image, rectFAI3, lineRegion, lineContours2, rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2, 5, 'negative', [threshValue,threshValue], sigma1, sigma23, 'first', widthRatio2, ignoreFraction2, newWidth3, cannyLow3, cannyHigh3, kernelWidth2, longestOnly2, XsUsed, Ys2, lineX22, lineY22, XsUsed3, YsUsed3, XsIgnored3, YsIgnored3)</l>
<c></c>
<l>concat_obj (FindLineRects, rectFAI3, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI3_LEN_P1, MapToWorld, MapToImage, 'true', FAI3_P1_LineStartX, FAI3_P1_LineStartY, FAI3_P1_LineEndX, FAI3_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI3_LEN_P2, MapToWorld, MapToImage, 'true', FAI3_P2_LineStartX, FAI3_P2_LineStartY, FAI3_P2_LineEndX, FAI3_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI3_LEN_P3, MapToWorld, MapToImage, 'true', FAI3_P3_LineStartX, FAI3_P3_LineStartY, FAI3_P3_LineEndX, FAI3_P3_LineEndY)</l>
<c></c>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI3, lineX1FAI3, lineY2FAI3, lineX2FAI3, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>***********************************************FAI4*******************************</c>
<l>rectFAI4Row := 4682.30000000 - rowModel</l>
<l>rectFAI4Col := 3567.21000000 - colModel</l>
<l>rectFAI4Radian := rad(85)</l>
<l>rectFAI4Len1 := 70.89900000</l>
<l>rectFAI4Len2 := 800</l>
<l>AffineTransRect2 (rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2, MovementImageToImage, rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2)</l>
<l>gen_rectangle2 (Rectangle6, rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2)</l>
<l>GetFindLineParams ('4', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rectFAI4, lineRegion, 'negative', rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2, 6, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth14, longestOnly16, lineX1FAI4, lineY1FAI4, lineX2FAI4, lineY2FAI4, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rectFAI4, lineRegion, lineContours3, rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2, 10, 'negative', threshValue, sigma1, sigma24, 'first', widthRatio3, ignoreFraction3, newWidth4, cannyLow4, cannyHigh4, kernelWidth3, longestOnly3, XsUsed, Ys3, lineX23, lineY23, XsUsed4, YsUsed4, XsIgnored4, YsIgnored4)</l>
<l>concat_obj (FindLineRects, rectFAI4, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P1_LineStartY, FAI3_P1_LineStartX, FAI3_P1_LineEndY, FAI3_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P3_LineStartY, FAI3_P3_LineStartX, FAI3_P3_LineEndY, FAI3_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>*************************************FAI 5***************************************</c>
<l>ROW_1 := 4850 - rowModel</l>
<l>COL_1 := 2800 - colModel</l>
<l>RAD_1 := rad(-90.00000000)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 200</l>
<c></c>
<l>ROW_2 := 4850- rowModel</l>
<l>COL_2 := 3650 - colModel</l>
<l>RAD_2 := rad(-90.00000000)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 150</l>
<c></c>
<l>ROW_3 := 4890- rowModel</l>
<l>COL_3 := 4470 - colModel</l>
<l>RAD_3 := rad(-90.00000000)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 200</l>
<c></c>
<c></c>
<l>rectFAI5Row := 4850- rowModel</l>
<l>rectFAI5Col := 3600 - colModel</l>
<l>rectFAI5Radian := rad(-94)</l>
<l>rectFAI5Len1 := 100</l>
<l>rectFAI5Len2 := 1000</l>
<c></c>
<l>AffineTransRect2 (rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2, MovementImageToImage, rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2)</l>
<l>gen_rectangle2 (Rectangle2, rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2)</l>
<c></c>
<l>GetFindLineParams ('5', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2, 6, [threshValue,threshValue,threshValue], 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth15, longestOnly17, lineX1FAI5, lineY1FAI5, lineX2FAI5, lineY2FAI5, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI5, lineX1FAI5, lineY2FAI5, lineX2FAI5, FAI3_P1_LineStartY, FAI3_P1_LineStartX, FAI3_P1_LineEndY, FAI3_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI5, lineX1FAI5, lineY2FAI5, lineX2FAI5, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI5, lineX1FAI5, lineY2FAI5, lineX2FAI5, FAI3_P3_LineStartY, FAI3_P3_LineStartX, FAI3_P3_LineEndY, FAI3_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c>*************************************FAI 6******************************************</c>
<l>rectFAI6Row := 2983.82000000 - rowModel</l>
<l>rectFAI6Col := 1710.50000000 - colModel</l>
<l>rectFAI6Radian := rad(88)</l>
<l>rectFAI6Len1 := 101.93600000</l>
<l>rectFAI6Len2 := 300.58900000</l>
<l>AffineTransRect2 (rectFAI6Row, rectFAI6Col, rectFAI6Radian, rectFAI6Len1, rectFAI6Len2, MovementImageToImage, rectFAI6Row, rectFAI6Col, rectFAI6Radian, rectFAI6Len1, rectFAI6Len2)</l>
<l>GetFindLineParams ('6', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI6Row, rectFAI6Col, rectFAI6Radian, rectFAI6Len1, rectFAI6Len2, numSubRects, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth16, longestOnly18, lineX1FAI6, lineY1FAI6, lineX2FAI6, lineY2FAI6, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours4, rectFAI6Row, rectFAI6Col, rectFAI6Radian, rectFAI6Len1, rectFAI6Len2, 10, 'positive', threshValue, sigma1, sigma25, 'first', widthRatio4, ignoreFraction4, newWidth5, cannyLow5, cannyHigh5, kernelWidth4, longestOnly4, XsUsed, Ys4, lineX24, lineY24, XsUsed5, YsUsed5, XsIgnored5, YsIgnored5)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI6_LEN_P1, MapToWorld, MapToImage, 'true', FAI6_P1_LineStartX, FAI6_P1_LineStartY, FAI6_P1_LineEndX, FAI6_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI6_LEN_P2, MapToWorld, MapToImage, 'true', FAI6_P2_LineStartX, FAI6_P2_LineStartY, FAI6_P2_LineEndX, FAI6_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI6_LEN_P3, MapToWorld, MapToImage, 'true', FAI6_P3_LineStartX, FAI6_P3_LineStartY, FAI6_P3_LineEndX, FAI6_P3_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI6, lineX1FAI6, lineY2FAI6, lineX2FAI6, FAI6_P1_LineStartY, FAI6_P1_LineStartX, FAI6_P1_LineEndY, FAI6_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI6, lineX1FAI6, lineY2FAI6, lineX2FAI6, FAI6_P2_LineStartY, FAI6_P2_LineStartX, FAI6_P2_LineEndY, FAI6_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI6, lineX1FAI6, lineY2FAI6, lineX2FAI6, FAI6_P3_LineStartY, FAI6_P3_LineStartX, FAI6_P3_LineEndY, FAI6_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>*************************************FAI9********************************************</c>
<l>rectFAI9Row := 1584.57000000 - rowModel</l>
<l>rectFAI9Col := 1744.61000000 - colModel</l>
<l>rectFAI9Radian := rad(-90)</l>
<l>rectFAI9Len1 := 97.95910000</l>
<l>rectFAI9Len2 := 275.13700000</l>
<l>AffineTransRect2 (rectFAI9Row, rectFAI9Col, rectFAI9Radian, rectFAI9Len1, rectFAI9Len2, MovementImageToImage, rectFAI9Row, rectFAI9Col, rectFAI9Radian, rectFAI9Len1, rectFAI9Len2)</l>
<l>GetFindLineParams ('9', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI9Row, rectFAI9Col, rectFAI9Radian, rectFAI9Len1, rectFAI9Len2, numSubRects, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth17, longestOnly19, lineX1FAI9, lineY1FAI9, lineX2FAI9, lineY2FAI9, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours5, rectFAI9Row, rectFAI9Col, rectFAI9Radian, rectFAI9Len1, rectFAI9Len2, 10, 'positive', threshValue, sigma1, sigma26, 'first', widthRatio5, ignoreFraction5, newWidth6, cannyLow6, cannyHigh6, kernelWidth5, longestOnly5, XsUsed, Ys5, lineX25, lineY25, XsUsed6, YsUsed6, XsIgnored6, YsIgnored6)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI9_LEN_P1, MapToWorld, MapToImage, 'true', FAI9_P1_LineStartX, FAI9_P1_LineStartY, FAI9_P1_LineEndX, FAI9_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI9_LEN_P2, MapToWorld, MapToImage, 'true', FAI9_P2_LineStartX, FAI9_P2_LineStartY, FAI9_P2_LineEndX, FAI9_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI9_LEN_P3, MapToWorld, MapToImage, 'true', FAI9_P3_LineStartX, FAI9_P3_LineStartY, FAI9_P3_LineEndX, FAI9_P3_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI9, lineX1FAI9, lineY2FAI9, lineX2FAI9, FAI9_P1_LineStartY, FAI9_P1_LineStartX, FAI9_P1_LineEndY, FAI9_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI9, lineX1FAI9, lineY2FAI9, lineX2FAI9, FAI9_P2_LineStartY, FAI9_P2_LineStartX, FAI9_P2_LineEndY, FAI9_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI9, lineX1FAI9, lineY2FAI9, lineX2FAI9, FAI9_P3_LineStartY, FAI9_P3_LineStartX, FAI9_P3_LineEndY, FAI9_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>******************************FAI12**************************</c>
<l>ROW_1 := 3240 - rowModel</l>
<l>COL_1 := 2420- colModel</l>
<l>RAD_1 := rad(-1)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 100</l>
<c></c>
<l>ROW_2 := 3886- rowModel</l>
<l>COL_2 := 2400- colModel</l>
<l>RAD_2 := rad(-1)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 100</l>
<c></c>
<l>ROW_3 := 4500- rowModel</l>
<l>COL_3 := 2400- colModel</l>
<l>RAD_3 := rad(-1)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 200</l>
<c></c>
<c></c>
<c></c>
<l>rectFAI12Row := 3836- rowModel</l>
<l>rectFAI12Col := 2400- colModel</l>
<l>rectFAI12Radian := rad(0)</l>
<l>rectFAI12Len1 := 150</l>
<l>rectFAI12Len2 := 600</l>
<l>AffineTransRect2 (rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2, MovementImageToImage, rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2)</l>
<c></c>
<l>gen_rectangle2 (Rectangle, rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2)</l>
<l>GetFindLineParams ('12', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2, numSubRects, [threshValue,threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth18, longestOnly20, lineX1FAI12, lineY1FAI12, lineX2FAI12, lineY2FAI12, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours6, rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2, 10, 'positive', threshValue, sigma1, sigma27, 'first', widthRatio6, ignoreFraction6, newWidth7, cannyLow7, cannyHigh7, kernelWidth6, longestOnly6, XsUsed, Ys6, lineX26, lineY26, XsUsed7, YsUsed7, XsIgnored7, YsIgnored7)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate TOP right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI12_LEN_P1, MapToWorld, MapToImage, 'false', FAI12_P1_LineStartX, FAI12_P1_LineStartY, FAI12_P1_LineEndX, FAI12_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI12_LEN_P2, MapToWorld, MapToImage, 'false', FAI12_P2_LineStartX, FAI12_P2_LineStartY, FAI12_P2_LineEndX, FAI12_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI12, lineX1FAI12, lineY2FAI12, lineX2FAI12, FAI12_P1_LineStartY, FAI12_P1_LineStartX, FAI12_P1_LineEndY, FAI12_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<c>****************</c>
<l>GenLineRegion (lineRegion1, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 5120, 5120)</l>
<l>gen_cross_contour_xld (Cross, rowIntersect, colIntersect, 300, Angle)</l>
<c>***************</c>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI12, lineX1FAI12, lineY2FAI12, lineX2FAI12, FAI12_P2_LineStartY, FAI12_P2_LineStartX, FAI12_P2_LineEndY, FAI12_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>*********************************FAI16*************************</c>
<l>rectFAI16Row := 2246.47000000 - rowModel</l>
<l>rectFAI16Col := 992.65500000 - colModel</l>
<l>rectFAI16Radian := rad(-0.5)</l>
<l>rectFAI16Len1 := 125.95600000</l>
<l>rectFAI16Len2 := 470.84500000</l>
<c></c>
<l>AffineTransRect2 (rectFAI16Row, rectFAI16Col, rectFAI16Radian, rectFAI16Len1, rectFAI16Len2, MovementImageToImage, rectFAI16Row, rectFAI16Col, rectFAI16Radian, rectFAI16Len1, rectFAI16Len2)</l>
<l>GetFindLineParams ('16', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI16Row, rectFAI16Col, rectFAI16Radian, rectFAI16Len1, rectFAI16Len2, 6, threshValue, 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth19, longestOnly21, lineX1FAI16, lineY1FAI16, lineX2FAI16, lineY2FAI16, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours7, rectFAI16Row, rectFAI16Col, rectFAI16Radian, rectFAI16Len1, rectFAI16Len2, 20, 'positive', threshValue, sigma1, sigma28, 'first', widthRatio7, ignoreFraction7, newWidth8, cannyLow8, cannyHigh8, kernelWidth7, longestOnly7, XsUsed, Ys7, lineX27, lineY27, XsUsed8, YsUsed8, XsIgnored8, YsIgnored8)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base top</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI16_LEN_P1, MapToWorld, MapToImage, 'false', FAI16_P1_LineStartX, FAI16_P1_LineStartY, FAI16_P1_LineEndX, FAI16_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI16_LEN_P2, MapToWorld, MapToImage, 'false', FAI16_P2_LineStartX, FAI16_P2_LineStartY, FAI16_P2_LineEndX, FAI16_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI16, lineX1FAI16, lineY2FAI16, lineX2FAI16, FAI16_P1_LineStartY, FAI16_P1_LineStartX, FAI16_P1_LineEndY, FAI16_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI16, lineX1FAI16, lineY2FAI16, lineX2FAI16, FAI16_P2_LineStartY, FAI16_P2_LineStartX, FAI16_P2_LineEndY, FAI16_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>**************************FAI17*******************************</c>
<l>ROW_1 := 466 - rowModel</l>
<l>COL_1 := 2700- colModel</l>
<l>RAD_1 := rad(-1)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 100</l>
<c></c>
<l>ROW_2 := 868- rowModel</l>
<l>COL_2 := 2670- colModel</l>
<l>RAD_2 := rad(-1)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 100</l>
<c></c>
<l>ROW_3 := 1266- rowModel</l>
<l>COL_3 := 2670- colModel</l>
<l>RAD_3 := rad(-1)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 100</l>
<c></c>
<c></c>
<c></c>
<l>rectFAI17Row := 1108- rowModel</l>
<l>rectFAI17Col := 2670- colModel</l>
<l>rectFAI17Radian := rad(0)</l>
<l>rectFAI17Len1 := 100</l>
<l>rectFAI17Len2 := 300</l>
<l>AffineTransRect2 (rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2, MovementImageToImage, rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2)</l>
<l>gen_rectangle2 (Rectangle, rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2)</l>
<l>GetFindLineParams ('17', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2, numSubRects, [threshValue, threshValue, threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth20, longestOnly22, lineX1FAI17, lineY1FAI17, lineX2FAI17, lineY2FAI17, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours8, rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2, 30, 'positive', threshValue, sigma1, sigma29, 'first', widthRatio8, ignoreFraction8, newWidth9, cannyLow9, cannyHigh9, kernelWidth8, longestOnly8, XsUsed, Ys8, lineX28, lineY28, XsUsed9, YsUsed9, XsIgnored9, YsIgnored9)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate top base</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI17_LEN_P1, MapToWorld, MapToImage, 'false', FAI17_P1_LineStartX, FAI17_P1_LineStartY, FAI17_P1_LineEndX, FAI17_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI17_LEN_P2, MapToWorld, MapToImage, 'false', FAI17_P2_LineStartX, FAI17_P2_LineStartY, FAI17_P2_LineEndX, FAI17_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI17, lineX1FAI17, lineY2FAI17, lineX2FAI17, FAI17_P1_LineStartY, FAI17_P1_LineStartX, FAI17_P1_LineEndY, FAI17_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI17, lineX1FAI17, lineY2FAI17, lineX2FAI17, FAI17_P2_LineStartY, FAI17_P2_LineStartX, FAI17_P2_LineEndY, FAI17_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>********************************FAI19**************************</c>
<l>ROW_1 := 887 - rowModel</l>
<l>COL_1 := 4665- colModel</l>
<l>RAD_1 := rad(179.5)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 350</l>
<c></c>
<l>ROW_2 := 1806- rowModel</l>
<l>COL_2 := 4665- colModel</l>
<l>RAD_2 := rad(179)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 140</l>
<c></c>
<l>rectFAI19Row := 1137 - rowModel</l>
<l>rectFAI19Col := 4665- colModel</l>
<l>rectFAI19Radian := rad(180)</l>
<l>rectFAI19Len1 := 100</l>
<l>rectFAI19Len2 := 700</l>
<l>AffineTransRect2 (rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2, MovementImageToImage, rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2)</l>
<l>gen_rectangle2 (Rectangle, rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2)</l>
<l>GetFindLineParams ('19', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2, 6, [threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth21, longestOnly23, lineX1FAI19, lineY1FAI19, lineX2FAI19, lineY2FAI19, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineAdaptiveSingle (Image, rect, lineRegion, lineContours9, rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2, 6, 'positive', threshValue, sigma1, sigma210, 'first', widthRatio9, ignoreFraction9, newWidth10, cannyLow10, cannyHigh10, kernelWidth9, longestOnly9, XsUsed, Ys9, lineX29, lineY29, XsUsed10, YsUsed10, XsIgnored10, YsIgnored10)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate top base</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI19_LEN_P1, MapToWorld, MapToImage, 'false', FAI19_P1_LineStartX, FAI19_P1_LineStartY, FAI19_P1_LineEndX, FAI19_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI19_LEN_P2, MapToWorld, MapToImage, 'false', FAI19_P2_LineStartX, FAI19_P2_LineStartY, FAI19_P2_LineEndX, FAI19_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI19, lineX1FAI19, lineY2FAI19, lineX2FAI19, FAI19_P1_LineStartY, FAI19_P1_LineStartX, FAI19_P1_LineEndY, FAI19_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI19, lineX1FAI19, lineY2FAI19, lineX2FAI19, FAI19_P2_LineStartY, FAI19_P2_LineStartX, FAI19_P2_LineEndY, FAI19_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*****************************FAI20********************************</c>
<c>* 定圆心</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI20_LEN_Y, MapToWorld, MapToImage, 'false', FAI20_P2_LineStartX, FAI20_P2_LineStartY, FAI20_P2_LineEndX, FAI20_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI20_LEN_X, MapToWorld, MapToImage, 'true', FAI20V_P1_LineStartX, FAI20V_P1_LineStartY, FAI20V_P1_LineEndX, FAI20V_P1_LineEndY)</l>
<l>intersection_lines (FAI20_P2_LineStartY, FAI20_P2_LineStartX, FAI20_P2_LineEndY, FAI20_P2_LineEndX, FAI20V_P1_LineStartY, FAI20V_P1_LineStartX, FAI20V_P1_LineEndY, FAI20V_P1_LineEndX, rowCenterTop, colCenterTop, IsOverlapping2)</l>
<l>intersectXs := [intersectXs, colCenterTop]</l>
<l>intersectYs := [intersectYs, rowCenterTop]</l>
<c></c>
<l>rectFAI20TRRow := 298.18300000 -rowModel</l>
<l>rectFAI20TRCol := 4577.96000000 - colModel</l>
<l>rectFAI20TRRadian := rad(-150.84800000)</l>
<l>rectFAI20TRLen1 := 40.64630000</l>
<l>rectFAI20TRLen2 := 65.46210000</l>
<c></c>
<l>AffineTransRect2 (rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2, MovementImageToImage, rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2)</l>
<l>gen_rectangle2 (Rectangle5, rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2)</l>
<l>GetFindLineParams ('20-topRight', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep_Pairs (Image, rect, lineRegion, rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2, 'negative', 6, threshValue, sigma1, sigma2, 'first', 'false', ignorePortion, 'first', 10, 50, 5120, 5120, cannyHigh, cannyLow, 'true', newWidth, kernelWidth25, longestOnly11, XsUsed, YsUsed, XsIgnored, YsIgnored, lineX1FAI20TR, lineY1FAI20TR, lineX2FAI20TR, lineY2FAI20TR)</l>
<c></c>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2, 5, FAI20Threshold_up, 'first', 0.3, 'false', 3, sigma2, Width, Height, newWidth, 30, 15, kernelWidth22, longestOnly24, lineX1FAI20TR, lineY1FAI20TR, lineX2FAI20TR, lineY2FAI20TR, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<l>rectFAI20BLRow := 2078.83000000 - rowModel</l>
<l>rectFAI20BLCol := 2775.07000000 - colModel</l>
<l>rectFAI20BLRadian := rad(45)</l>
<l>rectFAI20BLLen1 := 80.07090000</l>
<l>rectFAI20BLLen2 := 80.95030000</l>
<l>AffineTransRect2 (rectFAI20BLRow, rectFAI20BLCol, rectFAI20BLRadian, rectFAI20BLLen1, rectFAI20BLLen2, MovementImageToImage, rectFAI20BLRow, rectFAI20BLCol, rectFAI20BLRadian, rectFAI20BLLen1, rectFAI20BLLen2)</l>
<l>GetFindLineParams ('20-bottomLeft', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI20BLRow, rectFAI20BLCol, rectFAI20BLRadian, rectFAI20BLLen1, rectFAI20BLLen2, 10, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth23, longestOnly25, lineX1FAI20BL, lineY1FAI20BL, lineX2FAI20BL, lineY2FAI20BL, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* FAI20-1</c>
<l>ptX_TR :=(lineX1FAI20TR + lineX2FAI20TR) / 2.0</l>
<l>ptY_TR := (lineY1FAI20TR + lineY2FAI20TR) / 2.0</l>
<l>intersectXs := [intersectXs, ptX_TR]</l>
<l>intersectYs := [intersectYs, ptY_TR]</l>
<c></c>
<l>DistancePLInWorld (lineX1FAI20BL, lineY1FAI20BL, lineX2FAI20BL, lineY2FAI20BL, ptX_TR, ptY_TR, MapToWorld, distanceWorld, distancePixel)</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* FAI20-2</c>
<l>ptX_BL :=(lineX1FAI20BL + lineX2FAI20BL) / 2.0</l>
<l>ptY_BL := (lineY1FAI20BL + lineY2FAI20BL) / 2.0</l>
<l>intersectXs := [intersectXs, ptX_BL]</l>
<l>intersectYs := [intersectYs, ptY_BL]</l>
<c></c>
<l>ptX := (ptX_TR + ptX_BL) / 2.0</l>
<l>ptY := (ptY_TR + ptY_BL) / 2.0</l>
<c></c>
<l>PivotLineAroundPoint(lineRegion, lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colOrigin, rowOrigin, rad(45), 'right', 5120, 5120, outLineX1, outLineY1, outLineX2, outLineY2)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<l>DistancePLInWorld (outLineX1, outLineY1, outLineX2, outLineY2, ptX, ptY, MapToWorld, distanceWorld, distancePixel)</l>
<l>distanceWorld := abs(distanceWorld - 12.202)</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<l>numOutputs := |outputs|</l>
<l>numOutputPixels := |outputsPixel|</l>
<l>return ()</l>
</body>
<docu id="I94TopFaceMeasurementOverflow">
<parameters>
<parameter id="CannyHighs"/>
<parameter id="CannyLows"/>
<parameter id="FindLineNames"/>
<parameter id="FindLineRects"/>
<parameter id="IgnorePortions"/>
<parameter id="Image"/>
<parameter id="ImageUndistorted"/>
<parameter id="ModelID"/>
<parameter id="NewWidths"/>
<parameter id="Sigma1s"/>
<parameter id="Sigma2s"/>
<parameter id="crossesXIgnored"/>
<parameter id="crossesXused"/>
<parameter id="crossesYIgnored"/>
<parameter id="crossesYused"/>
<parameter id="intersectXs"/>
<parameter id="intersectYs"/>
<parameter id="lineRegions"/>
<parameter id="outputs"/>
<parameter id="outputsPixel"/>
<parameter id="thresholds"/>
<parameter id="xCoeff"/>
<parameter id="yCoeff"/>
</parameters>
</docu>
</procedure>
<procedure name="_pinPointFindLine">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="newWidth" base_type="ctrl" dimension="0"/>
<par name="EdgesOnly" base_type="ctrl" dimension="0"/>
<par name="cannyHigh" base_type="ctrl" dimension="0"/>
<par name="cannyLow" base_type="ctrl" dimension="0"/>
<par name="sigma" base_type="ctrl" dimension="0"/>
<par name="kernelWidth" base_type="ctrl" dimension="0"/>
<par name="longestOnly" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowBegin" base_type="ctrl" dimension="0"/>
<par name="ColBegin" base_type="ctrl" dimension="0"/>
<par name="RowEnd" base_type="ctrl" dimension="0"/>
<par name="ColEnd" base_type="ctrl" dimension="0"/>
<par name="EdgesX" base_type="ctrl" dimension="0"/>
<par name="EdgesY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>GetEdgesInSubRect2 (inputImage, findLineRegion, Edges, lineX1, lineY1, lineX2, lineY2, radian, newWidth, sigma, cannyLow, cannyHigh, kernelWidth, longestOnly)</l>
<c></c>
<l>* maxLength := 0</l>
<l>* selectedIndex := 0</l>
<l>* count_obj (Edges, numEdges)</l>
<l>* if (numEdges &gt; 1)</l>
<l>*     for Index := 1 to numEdges by 1</l>
<l>*     select_obj (Edges, Edge, Index)</l>
<l>*     length_xld (Edge,Length)</l>
<l>*     if(Length &gt; maxLength)</l>
<l>*         maxLength := Length</l>
<l>*         selectedIndex := Index</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* select_obj (Edges, Edges, selectedIndex)</l>
<c></c>
<c></c>
<l>* endif</l>
<c></c>
<l>LongestXLD (Edges, Edges, contourLength)</l>
<c></c>
<l>findLineRegion := Edges</l>
<c></c>
<l>if(EdgesOnly == 'true')</l>
<l>    get_contour_xld (Edges, EdgesY, EdgesX)</l>
<l>    return ()</l>
<l>endif</l>
<c></c>
<l>fit_line_contour_xld (Edges, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<c></c>
<l>if(|Dist| &gt; 1)</l>
<l>    tuple_sort_index (Dist, Indices)</l>
<l>    RowBegin := RowBegin[1]</l>
<l>    ColBegin := ColBegin[1]</l>
<l>    RowEnd := RowEnd[1]</l>
<l>    ColEnd := ColEnd[1]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="_pinPointFindLine">
<parameters>
<parameter id="ColBegin"/>
<parameter id="ColEnd"/>
<parameter id="EdgesOnly">
<default_value>'false'</default_value>
<description lang="zh_CN">If true return edges only instead of end points</description>
<sem_type>string</sem_type>
</parameter>
<parameter id="EdgesX"/>
<parameter id="EdgesY"/>
<parameter id="RowBegin"/>
<parameter id="RowEnd"/>
<parameter id="cannyHigh">
<sem_type>number</sem_type>
<values>
<item>60</item>
</values>
</parameter>
<parameter id="cannyLow">
<default_value>30</default_value>
<sem_type>real</sem_type>
</parameter>
<parameter id="findLineRegion"/>
<parameter id="inputImage"/>
<parameter id="kernelWidth"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="longestOnly"/>
<parameter id="newWidth"/>
<parameter id="radian"/>
<parameter id="sigma"/>
</parameters>
</docu>
</procedure>
<procedure name="AngledLineThatPasses">
<interface>
<ic>
<par name="centerX" base_type="ctrl" dimension="0"/>
<par name="centerY" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="x1" base_type="ctrl" dimension="0"/>
<par name="y1" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>m := tan(radian)</l>
<l>b := centerY - m * centerX</l>
<c></c>
<l>x1 := centerX + 100</l>
<l>y1 := m * x1 + b</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="AngledLineThatPasses">
<parameters>
<parameter id="centerX"/>
<parameter id="centerY"/>
<parameter id="radian"/>
<parameter id="x1"/>
<parameter id="y1"/>
</parameters>
</docu>
</procedure>
<procedure name="_getUnmarkedBoundary">
<interface>
<ic>
<par name="boundarySearched" base_type="ctrl" dimension="0"/>
<par name="m" base_type="ctrl" dimension="0"/>
<par name="b" base_type="ctrl" dimension="0"/>
<par name="imageWidth" base_type="ctrl" dimension="0"/>
<par name="imageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="x" base_type="ctrl" dimension="0"/>
<par name="y" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="_getUnmarkedBoundary">
<parameters>
<parameter id="b"/>
<parameter id="boundarySearched"/>
<parameter id="imageHeight"/>
<parameter id="imageWidth"/>
<parameter id="m"/>
<parameter id="x"/>
<parameter id="y"/>
</parameters>
</docu>
</procedure>
<procedure name="_search_boundary">
<interface>
<ic>
<par name="boundariesToSearch" base_type="ctrl" dimension="0"/>
<par name="m" base_type="ctrl" dimension="0"/>
<par name="b" base_type="ctrl" dimension="0"/>
<par name="imageWidth" base_type="ctrl" dimension="0"/>
<par name="imageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="result" base_type="ctrl" dimension="0"/>
<par name="x" base_type="ctrl" dimension="0"/>
<par name="y" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* down</c>
<l>StringTupleContains(boundariesToSearch, 'down', hasElement)</l>
<l>StringTupleContains(boundariesToSearch, 'null', hasNull)</l>
<c></c>
<l>if(hasElement == 'true' or hasNull == 'true')</l>
<l>    y := imageHeight -1</l>
<l>    if(m == 0)</l>
<l>        m := 0.00001</l>
<l>    endif</l>
<l>    x := (y - b) / m</l>
<c></c>
<l>if(x&gt;=0 and x&lt; imageWidth)</l>
<l>    result := 'down'</l>
<l>    return ()</l>
<l>endif</l>
<l>endif</l>
<c></c>
<c>* up</c>
<l>StringTupleContains(boundariesToSearch, 'up', hasElement)</l>
<l>StringTupleContains(boundariesToSearch, 'null', hasNull)</l>
<c></c>
<l>if(hasElement == 'true' or hasNull == 'true')</l>
<l>    y := 0</l>
<l>    x := (y - b) / m</l>
<c></c>
<l>if(x&gt;=0 and x&lt; imageWidth)</l>
<l>    result := 'up'</l>
<l>    return ()</l>
<l>endif</l>
<l>endif</l>
<c></c>
<c>* left</c>
<l>StringTupleContains(boundariesToSearch, 'left', hasElement)</l>
<l>StringTupleContains(boundariesToSearch, 'null', hasNull)</l>
<c></c>
<l>if(hasElement == 'true' or hasNull == 'true')</l>
<l>    x := 0</l>
<l>    y := m*x + b</l>
<c></c>
<l>if(y&gt;=0 and y&lt; imageHeight)</l>
<l>    result := 'left'</l>
<l>    return ()</l>
<l>endif</l>
<l>endif</l>
<c></c>
<c></c>
<c>* right</c>
<l>StringTupleContains(boundariesToSearch, 'right', hasElement)</l>
<l>StringTupleContains(boundariesToSearch, 'null', hasNull)</l>
<c></c>
<l>if(hasElement == 'true' or hasNull == 'true')</l>
<l>    x := imageWidth - 1</l>
<l>    y := m*x + b</l>
<c></c>
<l>if(y&gt;=0 and y&lt; imageHeight)</l>
<l>    result := 'right'</l>
<l>    return ()</l>
<l>endif</l>
<l>endif</l>
<c></c>
<l>result := 'null'</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_search_boundary">
<parameters>
<parameter id="b"/>
<parameter id="boundariesToSearch"/>
<parameter id="imageHeight"/>
<parameter id="imageWidth"/>
<parameter id="m"/>
<parameter id="result"/>
<parameter id="x"/>
<parameter id="y"/>
</parameters>
</docu>
</procedure>
<procedure name="StringTupleContains">
<interface>
<ic>
<par name="listOfString" base_type="ctrl" dimension="0"/>
<par name="targetString" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="hasElement" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>for i := 0 to |listOfString|-1 by 1</l>
<l>    if(listOfString[i] == targetString)</l>
<l>        hasElement := 'true'</l>
<l>        return ()</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>hasElement := 'false'</l>
<c></c>
<l>return ()</l>
</body>
<docu id="StringTupleContains">
<parameters>
<parameter id="hasElement">
<sem_type>string</sem_type>
</parameter>
<parameter id="listOfString"/>
<parameter id="targetString">
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="GetWeightByNamme">
<interface>
<ic>
<par name="nameList" base_type="ctrl" dimension="0"/>
<par name="weightList" base_type="ctrl" dimension="0"/>
<par name="name" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="weight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>nameLen := |nameList|</l>
<l>weightLen := |weightList|</l>
<c></c>
<l>if(nameLen!= weightLen)</l>
<l>    throw ('nameLen != weightLen!!!!!!!!!')</l>
<l>endif</l>
<c></c>
<l>for i := 0 to nameLen-1 by 1</l>
<l>    if(nameList[i] == name)</l>
<l>        weight := weightList[i]</l>
<l>        return ()</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>throw ('Name does not exist')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetWeightByNamme">
<parameters>
<parameter id="name"/>
<parameter id="nameList"/>
<parameter id="weight"/>
<parameter id="weightList"/>
</parameters>
</docu>
</procedure>
<procedure name="AffineTransRect2">
<interface>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="map" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="rowOut" base_type="ctrl" dimension="0"/>
<par name="colOut" base_type="ctrl" dimension="0"/>
<par name="radianOut" base_type="ctrl" dimension="0"/>
<par name="len1Out" base_type="ctrl" dimension="0"/>
<par name="len2Out" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>rowOut :=[]</l>
<l>colOut :=[]</l>
<l>radianOut :=[]</l>
<l>len1Out :=[]</l>
<l>len2Out :=[]</l>
<c></c>
<l>for i := 0 to |row|-1 by 1</l>
<l>    _affineTransRect2Single (row[i], col[i], radian[i], len1[i], len2[i], map, rowO, colO, radianO, len1O, len2O)</l>
<l>    rowOut :=[rowOut, rowO]</l>
<l>colOut :=[colOut, colO]</l>
<l>radianOut :=[radianOut, radianO]</l>
<l>len1Out :=[len1Out, len1O]</l>
<l>len2Out :=[len2Out, len2O]</l>
<l>endfor</l>
</body>
<docu id="AffineTransRect2">
<parameters>
<parameter id="col"/>
<parameter id="colOut"/>
<parameter id="len1"/>
<parameter id="len1Out"/>
<parameter id="len2"/>
<parameter id="len2Out"/>
<parameter id="map"/>
<parameter id="radian"/>
<parameter id="radianOut"/>
<parameter id="row"/>
<parameter id="rowOut"/>
</parameters>
</docu>
</procedure>
<procedure name="PivotLineAroundPoint">
<interface>
<oo>
<par name="lineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="pivotX" base_type="ctrl" dimension="0"/>
<par name="pivotY" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="newPointDirection" base_type="ctrl" dimension="0"/>
<par name="imageWidth" base_type="ctrl" dimension="0"/>
<par name="imageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outLineX1" base_type="ctrl" dimension="0"/>
<par name="outLineY1" base_type="ctrl" dimension="0"/>
<par name="outLineX2" base_type="ctrl" dimension="0"/>
<par name="outLineY2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>line_orientation (lineY1, lineX1, lineY2, lineX2, initialRadian)</l>
<l>newRadian := initialRadian + radian</l>
<c></c>
<l>m := tan(newRadian)</l>
<l>b := pivotY - pivotX * m</l>
<c></c>
<l>outLineX1 := pivotX</l>
<l>outLineY1 := pivotY</l>
<c></c>
<l>dist := 10</l>
<l>if(newPointDirection == 'up')</l>
<l>    outLineY2 := outLineY1 + dist</l>
<l>    outLineX2 := (outLineY2 - b) / m</l>
<l>elseif(newPointDirection == 'down')</l>
<l>    outLineY2 := outLineY1 - dist</l>
<l>    outLineX2 := (outLineY2 - b) / m</l>
<l>elseif(newPointDirection == 'left')</l>
<l>    outLineX2 := outLineX1 - dist</l>
<l>    outLineY2 := outLineX2 * m + b</l>
<l>elseif(newPointDirection == 'right')</l>
<l>    outLineX2 := outLineX1 + dist</l>
<l>    outLineY2 := outLineX2 * m + b</l>
<l>else</l>
<l>    throw ('Invalid Direction')</l>
<l>endif</l>
<c></c>
<l>GenLineRegion (lineRegion, outLineX1, outLineY1, outLineX2, outLineY2, imageWidth, imageHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="PivotLineAroundPoint">
<parameters>
<parameter id="imageHeight">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="imageWidth">
<default_type>integer</default_type>
<default_value>5120</default_value>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="lineRegion"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="newPointDirection"/>
<parameter id="outLineX1"/>
<parameter id="outLineX2"/>
<parameter id="outLineY1"/>
<parameter id="outLineY2"/>
<parameter id="pivotX"/>
<parameter id="pivotY"/>
<parameter id="radian"/>
</parameters>
</docu>
</procedure>
<procedure name="LongestXLD">
<interface>
<io>
<par name="inputContour" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="outputContour" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="contourLength" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>count_obj (inputContour, Number)</l>
<c></c>
<c></c>
<l>    gen_empty_obj (selectedContour)</l>
<l>    selectedIndex := 0</l>
<l>    contourLength := 0</l>
<l>    for Index := 1 to Number by 1</l>
<l>        select_obj (inputContour, ObjectSelected, Index)</l>
<l>        smallest_rectangle2_xld (ObjectSelected, Row, Column, Phi1, Length, Length2)</l>
<l>        if(Length2 &gt; Length)</l>
<l>            Length := Length2</l>
<l>        endif</l>
<c>        </c>
<l>        if(Length &gt; contourLength)</l>
<l>            contourLength := Length</l>
<l>            selectedContour := ObjectSelected</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<c>    </c>
<l>    outputContour := selectedContour</l>
<l>return ()</l>
</body>
<docu id="LongestXLD">
<parameters>
<parameter id="contourLength"/>
<parameter id="inputContour"/>
<parameter id="outputContour"/>
</parameters>
</docu>
</procedure>
<procedure name="_genSubRect2">
<interface>
<oo>
<par name="rect2Out" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="newWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_rectangle2_contour_xld (Rectangle, row, col, radian, len1, len2)</l>
<l>intersection_line_contour_xld (Rectangle, lineY1, lineX1, lineY2, lineX2, rowEndPoint, colEndPoint, IsOverlapping)</l>
<c></c>
<l>if(|rowEndPoint|!= 2 or |colEndPoint|!= 2)</l>
<l>    throw ('Only two end points should be found!')</l>
<l>endif</l>
<c></c>
<l>rowOut := sum(rowEndPoint) / 2.0</l>
<l>colOut := sum(colEndPoint) / 2.0</l>
<c></c>
<l>line_orientation (lineY1, lineX1, lineY2, lineX2, radianNormal)</l>
<l>radianOut := radianNormal + rad(90)</l>
<c></c>
<l>len1Out := newWidth</l>
<l>len2Out := len2</l>
<c></c>
<l>gen_rectangle2 (rect2Out, rowOut, colOut, radianOut, len1Out, len2Out)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="_genSubRect2">
<parameters>
<parameter id="col"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="newWidth"/>
<parameter id="radian"/>
<parameter id="rect2Out"/>
<parameter id="row"/>
</parameters>
</docu>
</procedure>
<procedure name="ProjectionFilter">
<interface>
<ic>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="ignorePortion" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XsOut" base_type="ctrl" dimension="0"/>
<par name="YsOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>numInputs := |Xs|</l>
<c></c>
<l>lineProjectionXs := []</l>
<l>lineProjectionYs := []</l>
<c></c>
<l>for i := 0 to numInputs-1 by 1</l>
<l>    X1 := Xs[i]</l>
<l>    Y1 := Ys[i]</l>
<l>    get_perpendicular_line_that_passes (lineX1, lineY1, lineX2, lineY2, X1, Y1, X2, Y2)</l>
<l>    intersection_lines (lineY1, lineX1, lineY2, lineX2, Y1, X1, Y2, X2, intersectionY, intersectionX, IsOverlapping)</l>
<l>    lineProjectionXs := [lineProjectionXs, intersectionX]</l>
<l>    lineProjectionYs := [lineProjectionYs, intersectionY]</l>
<l>endfor</l>
<c></c>
<l>GetDistancesToDistributionCenter (lineProjectionXs, lineProjectionYs, distances)</l>
<c></c>
<l>tuple_sort_index (distances, Indices)</l>
<c></c>
<l>numChoose := |Xs| * (1 - ignorePortion)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>XsOut := []</l>
<l>YsOut := []</l>
<c></c>
<c>* take data points that are within 2 deviations away, that is 95% range</c>
<l>for i := 0 to |Xs|-1 by 1</l>
<l>    if(Indices[i] &lt; numChoose)</l>
<l>        XsOut := [XsOut, Xs[Indices[i]]]</l>
<l>        YsOut := [YsOut, Ys[Indices[i]]]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>dev_set_color ('red')</l>
<l>gen_cross_contour_xld (Cross, YsOut, XsOut, 1, 0)</l>
<l>dev_set_color ('green')</l>
<l>gen_cross_contour_xld (Cross2, Ys, Xs, 1, 0.785398)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ProjectionFilter">
<parameters>
<parameter id="Xs"/>
<parameter id="XsOut"/>
<parameter id="Ys"/>
<parameter id="YsOut"/>
<parameter id="ignorePortion"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
</parameters>
</docu>
</procedure>
<procedure name="GetLineWeightAndBias">
<interface>
<ic>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="m" base_type="ctrl" dimension="0"/>
<par name="b" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>yDiff := Y2 - Y1</l>
<l>xDiff := X2 - X1</l>
<c></c>
<l>m := yDiff / xDiff</l>
<l>b := Y1 - m*X1</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetLineWeightAndBias">
<parameters>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="b"/>
<parameter id="m"/>
</parameters>
</docu>
</procedure>
<procedure name="GetDistancesToDistributionCenter">
<interface>
<ic>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="distances" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_mean (Xs, xMean)</l>
<l>tuple_mean (Ys, yMean)</l>
<c></c>
<l>distances := []</l>
<c></c>
<l>for i := 0 to |Xs|-1 by 1</l>
<l>    distance_pp (yMean, xMean, Ys[i], Xs[i], Distance)</l>
<l>    distances := [distances, Distance]</l>
<l>endfor</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="GetDistancesToDistributionCenter">
<abstract lang="zh_CN">Normalize 2D points on a line to range (-1, 1)
(X1, Y1) is a point out of the line that is used to calculate two end points on the line</abstract>
<parameters>
<parameter id="Xs"/>
<parameter id="Ys"/>
<parameter id="distances"/>
</parameters>
</docu>
</procedure>
<procedure name="EstimateGaussian1D">
<interface>
<ic>
<par name="Xs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Mean" base_type="ctrl" dimension="0"/>
<par name="Deviation" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_mean (Xs, Mean)</l>
<l>tuple_deviation (Xs, Deviation)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="EstimateGaussian1D">
<parameters>
<parameter id="Deviation"/>
<parameter id="Mean"/>
<parameter id="Xs"/>
</parameters>
</docu>
</procedure>
<procedure name="GetContoursPoints">
<interface>
<io>
<par name="Contours" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Xs" base_type="ctrl" dimension="0"/>
<par name="Ys" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>count_obj (Contours, Number)</l>
<c></c>
<l>Xs := []</l>
<l>Ys := []</l>
<c></c>
<l>for i := 1 to Number by 1</l>
<l>    select_obj (Contours, Contour, i)</l>
<l>    get_contour_xld (Contour, Row, Col)</l>
<l>    Xs := [Xs, Col]</l>
<l>    Ys := [Ys, Row]</l>
<l>endfor</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="GetContoursPoints">
<parameters>
<parameter id="Contours"/>
<parameter id="Xs"/>
<parameter id="Ys"/>
</parameters>
</docu>
</procedure>
<procedure name="GenCalibrationMaps">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CamParams" base_type="ctrl" dimension="0"/>
<par name="CamPose" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MapToWorld" base_type="ctrl" dimension="0"/>
<par name="MapToImage" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_image_size (Image, Width, Height)</l>
<c>* </c>
<l>halfWidth := Width / 3.0</l>
<l>halfHeight := Height / 3.0</l>
<c>* </c>
<l>centerX := Width / 2.0</l>
<l>centerY := Height / 2.0</l>
<c>* </c>
<l>imageXs := []</l>
<l>imageYs := []</l>
<c>* </c>
<c>* </c>
<l>for i := -1 to 1 by 1</l>
<l>    for j := -1 to 1 by 1</l>
<l>        imageX := centerX+j*halfWidth</l>
<l>        imageXs := [imageXs, imageX]</l>
<l>        imageY := centerY + i* halfHeight</l>
<l>        imageYs := [imageYs, imageY]</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<l>image_points_to_world_plane (CamParams, CamPose, imageYs, imageXs, 0.001, worldXs, worldYs)</l>
<c>* </c>
<l>vector_to_hom_mat2d (worldXs, worldYs, imageXs, imageYs, MapToImage)</l>
<l>vector_to_hom_mat2d (imageXs, imageYs, worldXs, worldYs, MapToWorld)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="GenCalibrationMaps">
<parameters>
<parameter id="CamParams"/>
<parameter id="CamPose"/>
<parameter id="Image"/>
<parameter id="MapToImage"/>
<parameter id="MapToWorld"/>
</parameters>
</docu>
</procedure>
<procedure name="GetParallelLine">
<interface>
<ic>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
<par name="Offset" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="X1Out" base_type="ctrl" dimension="0"/>
<par name="Y1Out" base_type="ctrl" dimension="0"/>
<par name="X2Out" base_type="ctrl" dimension="0"/>
<par name="Y2Out" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>GetNormalVector (X1, Y1, X2, Y2, VecX, VecY)</l>
<c>* </c>
<l>X1Out := Offset * VecX + X1</l>
<l>Y1Out := Offset * VecY + Y1</l>
<l>X2Out := Offset * VecX + X2</l>
<l>Y2Out := Offset * VecY + Y2</l>
<l>return ()</l>
</body>
<docu id="GetParallelLine">
<abstract lang="en_US">沿着矢量(X1, Y1)-&gt;(X2, Y2)方向的右手边平移得到直线</abstract>
<parameters>
<parameter id="Offset"/>
<parameter id="X1"/>
<parameter id="X1Out"/>
<parameter id="X2"/>
<parameter id="X2Out"/>
<parameter id="Y1"/>
<parameter id="Y1Out"/>
<parameter id="Y2"/>
<parameter id="Y2Out"/>
</parameters>
</docu>
</procedure>
<procedure name="GetNormalVector">
<interface>
<ic>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="VecX" base_type="ctrl" dimension="0"/>
<par name="VecY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>xDiff := X2- X1</l>
<l>yDiff := Y2 - Y1</l>
<c>* </c>
<l>dist := sqrt(xDiff*xDiff + yDiff*yDiff)</l>
<l>xDiffNorm := xDiff / dist</l>
<l>yDiffNorm := yDiff / dist</l>
<c>* </c>
<l>radian := atan2(yDiffNorm, xDiffNorm)</l>
<c>* </c>
<l>VecX := yDiffNorm</l>
<l>VecY := -xDiffNorm</l>
<c>* </c>
<l>vecXNew := xDiffNorm + VecX</l>
<l>vecYNew := yDiffNorm + VecY</l>
<c>* </c>
<l>radianNew := atan2(vecYNew, vecXNew)</l>
<c>* </c>
<c>* 原单位向量 + 其法线单位向量都会得到一个角度 radianNew = radian + rad(45)的向量</c>
<c>* 若原向量角度大于135, 则radianNew &lt; 0</c>
<l>if (radian &gt; 2.35619)</l>
<l>    if (radianNew &gt; 0)</l>
<l>        VecX := -VecX</l>
<l>        VecY := -VecY</l>
<l>    endif</l>
<c>    * </c>
<l>else</l>
<l>    if (radianNew &lt; radian)</l>
<l>        VecX := -VecX</l>
<l>        VecY := -VecY</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="GetNormalVector">
<abstract lang="en_US">The direction of the input line is pointing from (X1, Y1) to (X2, Y2).
The normal direction of the input line is defined on the right side along the input line.
(VecX, VecY) is a unit vector</abstract>
<parameters>
<parameter id="VecX"/>
<parameter id="VecY"/>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
</parameters>
</docu>
</procedure>
<procedure name="SortLineLeftRight">
<interface>
<ic>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XLeft" base_type="ctrl" dimension="0"/>
<par name="YLeft" base_type="ctrl" dimension="0"/>
<par name="XRight" base_type="ctrl" dimension="0"/>
<par name="YRight" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>XLeft := X1</l>
<l>XRight := X2</l>
<l>YLeft := Y1</l>
<l>YRight := Y2</l>
<c>* </c>
<l>if (X1 &gt; X2)</l>
<l>    XLeft := X2</l>
<l>    XRight := X1</l>
<l>    YLeft := Y2</l>
<l>    YRight := Y1</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="SortLineLeftRight">
<abstract lang="en_US">Sort end points of a line from left to right</abstract>
<parameters>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="XLeft"/>
<parameter id="XRight"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="YLeft"/>
<parameter id="YRight"/>
</parameters>
</docu>
</procedure>
<procedure name="SortLineUpDown">
<interface>
<ic>
<par name="X1" base_type="ctrl" dimension="0"/>
<par name="Y1" base_type="ctrl" dimension="0"/>
<par name="X2" base_type="ctrl" dimension="0"/>
<par name="Y2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XUp" base_type="ctrl" dimension="0"/>
<par name="YUp" base_type="ctrl" dimension="0"/>
<par name="XDown" base_type="ctrl" dimension="0"/>
<par name="YDown" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>XUp := X1</l>
<l>XDown := X2</l>
<l>YUp := Y1</l>
<l>YDown := Y2</l>
<c>* </c>
<l>if (Y1 &gt; Y2)</l>
<l>    XUp := X2</l>
<l>    XDown := X1</l>
<l>    YUp := Y2</l>
<l>    YDown := Y1</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="SortLineUpDown">
<abstract lang="en_US">Sort end points of a line from top to bottom</abstract>
<parameters>
<parameter id="X1"/>
<parameter id="X2"/>
<parameter id="XDown"/>
<parameter id="XUp"/>
<parameter id="Y1"/>
<parameter id="Y2"/>
<parameter id="YDown"/>
<parameter id="YUp"/>
</parameters>
</docu>
</procedure>
<procedure name="UndistortImage">
<interface>
<io>
<par name="ImageRaw" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageUndistorted" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CameraParams" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OutCameraParams" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>change_radial_distortion_cam_par ('adaptive', CameraParams, 0, OutCameraParams)</l>
<l>gen_radial_distortion_map (Map, CameraParams, OutCameraParams, 'bilinear')</l>
<c></c>
<l>map_image (ImageRaw, Map, ImageUndistorted)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="UndistortImage">
<parameters>
<parameter id="CameraParams"/>
<parameter id="ImageRaw"/>
<parameter id="ImageUndistorted"/>
<parameter id="OutCameraParams"/>
</parameters>
</docu>
</procedure>
<procedure name="FindLineGradiant_Pair">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRegion" base_type="iconic" dimension="0"/>
<par name="lineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="ignoreFraction" base_type="ctrl" dimension="0"/>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="sigma1" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
<par name="whichPair" base_type="ctrl" dimension="0"/>
<par name="minWidth" base_type="ctrl" dimension="0"/>
<par name="maxWidth" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_image_size (inputImage, imageWidth, imageHeight)</l>
<l>EdgesX := []</l>
<l>EdgesY := []</l>
<c></c>
<c></c>
<l>gen_empty_obj (findLineRegions)</l>
<c></c>
<l>for i:= 0 to |row|-1 by 1</l>
<l>    VisionProStyleFindLine (inputImage, findLineRegion, transition, row[i], col[i], radian[i], len1[i], len2[i], numSubRects, threshold[i], sigma1, firstOrLast, 'true', whichPair, minWidth, maxWidth, Xs, Ys)</l>
<c></c>
<c>   </c>
<l>        EdgesX := [EdgesX, Xs]</l>
<l>        EdgesY := [EdgesY, Ys]</l>
<l>        concat_obj (findLineRegions, findLineRegion, findLineRegions)</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>    FitLine2D (EdgesX, EdgesY,ignoreFraction, lineX1, lineY1, lineX2, lineY2, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>    findLineRegion := findLineRegions</l>
<c></c>
<c></c>
<l>GenLineRegion (lineRegion, lineX1, lineY1, lineX2, lineY2, imageWidth, imageHeight)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="FindLineGradiant_Pair">
<parameters>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="col"/>
<parameter id="findLineRegion"/>
<parameter id="firstOrLast">
<default_value>'first'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="ignoreFraction">
<default_value>0.2</default_value>
<sem_type>real</sem_type>
</parameter>
<parameter id="inputImage"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="lineRegion"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="maxWidth"/>
<parameter id="minWidth"/>
<parameter id="numSubRects">
<default_value>10</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="radian"/>
<parameter id="row"/>
<parameter id="sigma1">
<default_value>2</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="threshold">
<default_value>20</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="transition">
<default_value>'positive'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="whichPair"/>
</parameters>
</docu>
</procedure>
<procedure name="DistanceInWorld_PP">
<interface>
<ic>
<par name="row1" base_type="ctrl" dimension="0"/>
<par name="col1" base_type="ctrl" dimension="0"/>
<par name="row2" base_type="ctrl" dimension="0"/>
<par name="col2" base_type="ctrl" dimension="0"/>
<par name="MapToWorld" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Distance" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>affine_trans_point_2d (MapToWorld, col2, row2, col2World, row2World)</l>
<l>affine_trans_point_2d (MapToWorld, col1, row1, col1World, row1World)</l>
<c></c>
<l>distance_pp (row1World, col1World, row2World, col2World, Distance)</l>
<l>return ()</l>
</body>
<docu id="DistanceInWorld_PP">
<parameters>
<parameter id="Distance"/>
<parameter id="MapToWorld"/>
<parameter id="col1"/>
<parameter id="col2"/>
<parameter id="row1"/>
<parameter id="row2"/>
</parameters>
</docu>
</procedure>
<procedure name="GetFindLineParams">
<interface>
<ic>
<par name="Key" base_type="ctrl" dimension="0"/>
<par name="FAINames" base_type="ctrl" dimension="0"/>
<par name="Thresholds" base_type="ctrl" dimension="0"/>
<par name="IgnorePortions" base_type="ctrl" dimension="0"/>
<par name="Sigma1s" base_type="ctrl" dimension="0"/>
<par name="Sigma2s" base_type="ctrl" dimension="0"/>
<par name="NewWidths" base_type="ctrl" dimension="0"/>
<par name="CannyLows" base_type="ctrl" dimension="0"/>
<par name="CannyHighs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="threshValue" base_type="ctrl" dimension="0"/>
<par name="ignorePortion" base_type="ctrl" dimension="0"/>
<par name="sigma1" base_type="ctrl" dimension="0"/>
<par name="sigma2" base_type="ctrl" dimension="0"/>
<par name="newWidth" base_type="ctrl" dimension="0"/>
<par name="cannyLow" base_type="ctrl" dimension="0"/>
<par name="cannyHigh" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>numFai := |FAINames|</l>
<c></c>
<l>selectedIndex := -1</l>
<l>for i := 0 to numFai - 1 by 1</l>
<l>    if(FAINames[i] == Key)</l>
<l>        selectedIndex := i</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>if(selectedIndex == -1)</l>
<l>    throw ('Can not find params for this FAI:' + Key)</l>
<l>endif</l>
<c></c>
<l>threshValue := Thresholds[selectedIndex]</l>
<l>ignorePortion := IgnorePortions[selectedIndex]</l>
<l>sigma1 := Sigma1s[selectedIndex]</l>
<l>sigma2 := Sigma2s[selectedIndex]</l>
<l>newWidth := NewWidths[selectedIndex]</l>
<l>cannyLow := CannyLows[selectedIndex]</l>
<l>cannyHigh := CannyHighs[selectedIndex]</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetFindLineParams">
<parameters>
<parameter id="CannyHighs"/>
<parameter id="CannyLows"/>
<parameter id="FAINames"/>
<parameter id="IgnorePortions"/>
<parameter id="Key"/>
<parameter id="NewWidths"/>
<parameter id="Sigma1s"/>
<parameter id="Sigma2s"/>
<parameter id="Thresholds"/>
<parameter id="cannyHigh"/>
<parameter id="cannyLow"/>
<parameter id="ignorePortion"/>
<parameter id="newWidth"/>
<parameter id="sigma1"/>
<parameter id="sigma2"/>
<parameter id="threshValue"/>
</parameters>
</docu>
</procedure>
<procedure name="I94TopFaceMeasurement">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageUndistorted" base_type="iconic" dimension="0"/>
<par name="lineRegions" base_type="iconic" dimension="0"/>
<par name="FindLineRects" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="xCoeff" base_type="ctrl" dimension="0"/>
<par name="yCoeff" base_type="ctrl" dimension="0"/>
<par name="FindLineNames" base_type="ctrl" dimension="0"/>
<par name="thresholds" base_type="ctrl" dimension="0"/>
<par name="IgnorePortions" base_type="ctrl" dimension="0"/>
<par name="Sigma1s" base_type="ctrl" dimension="0"/>
<par name="Sigma2s" base_type="ctrl" dimension="0"/>
<par name="NewWidths" base_type="ctrl" dimension="0"/>
<par name="CannyLows" base_type="ctrl" dimension="0"/>
<par name="CannyHighs" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outputs" base_type="ctrl" dimension="0"/>
<par name="crossesXused" base_type="ctrl" dimension="0"/>
<par name="crossesYused" base_type="ctrl" dimension="0"/>
<par name="crossesXIgnored" base_type="ctrl" dimension="0"/>
<par name="crossesYIgnored" base_type="ctrl" dimension="0"/>
<par name="intersectXs" base_type="ctrl" dimension="0"/>
<par name="intersectYs" base_type="ctrl" dimension="0"/>
<par name="outputsPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CameraParameters := ['area_scan_telecentric_division',0.588471,3.42746,4.4974e-006,4.5e-006,2556.48,2560.7,5120,5120]</l>
<l>CameraPose := [0.00180843,-0.000646214,0.000999199,0.316458,2.27204,180.151,0]</l>
<l>UndistortImage (Image, Image, CameraParameters, OutCameraParams)</l>
<l>ImageUndistorted := Image</l>
<c></c>
<l>GenCalibrationMaps (Image, OutCameraParams, CameraPose, MapToWorld, MapToImage)</l>
<c></c>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<c></c>
<c></c>
<l>dev_set_draw ('margin')</l>
<c></c>
<l>crossSize := 100</l>
<l>numSubRects := 10</l>
<c></c>
<l>ModelThreshold := 160</l>
<c></c>
<c></c>
<c>* record find line points</c>
<l>crossesXused := []</l>
<l>crossesYused := []</l>
<l>crossesXIgnored := []</l>
<l>crossesYIgnored := []</l>
<c></c>
<c>* record line-line intersections</c>
<l>intersectXs := []</l>
<l>intersectYs := []</l>
<c></c>
<c>* outputs</c>
<l>outputs := []</l>
<l>outputsPixel := []</l>
<c></c>
<c>* set units and positions</c>
<c></c>
<c></c>
<l>FAI2_LEN_P1 := 4.583 </l>
<l>FAI2_LEN_P2 := 9 </l>
<l>FAI2_LEN_P3 := 14.583 </l>
<c></c>
<l>FAI3_LEN_P1 := 5.299 </l>
<l>FAI3_LEN_P2 := 9</l>
<l>FAI3_LEN_P3 := 13.299 </l>
<c></c>
<l>FAI4_LEN_P1 := 5.299</l>
<l>FAI4_LEN_P2 := 9.299</l>
<l>FAI4_LEN_P3 := 13.299</l>
<c></c>
<l>FAI5_LEN_P1 := 5.299</l>
<l>FAI5_LEN_P2 := 9.299</l>
<l>FAI5_LEN_P3 := 13.299</l>
<c></c>
<l>FAI6_LEN_P1 := 22.024 </l>
<l>FAI6_LEN_P2 := 24.024 </l>
<l>FAI6_LEN_P3 := 26.024 </l>
<c></c>
<l>FAI9_LEN_P1 := 21.753 </l>
<l>FAI9_LEN_P2 := 23.753</l>
<l>FAI9_LEN_P3 := 25.753</l>
<c></c>
<c></c>
<l>FAI12_LEN_P1 := 23.213</l>
<l>FAI12_LEN_P2 := 34.97</l>
<c></c>
<l>FAI16_LEN_P1 := 13.071</l>
<l>FAI16_LEN_P2 := 20.213</l>
<c></c>
<l>FAI17_LEN_P1 := 1.53</l>
<l>FAI17_LEN_P2 := 9.827</l>
<c></c>
<l>FAI19_LEN_P1 := 2.157 </l>
<l>FAI19_LEN_P2 := 13.791 </l>
<c></c>
<l>FAI20_LEN_X := 9.299</l>
<l>FAI20_LEN_Y := 7.886 </l>
<c></c>
<l>gen_empty_obj (FindLineRects)</l>
<l>gen_empty_obj (lineRegions)</l>
<c></c>
<c></c>
<c>* find model</c>
<l>Threshold := 128</l>
<l>rowModel := 1171.5</l>
<l>colModel := 3678.5</l>
<l>gen_rectangle1 (ROI_0, 53.9, 1940.83, 2000, 3900)</l>
<l>reduce_domain (Image, ROI_0, ImageReduced)</l>
<l>binary_threshold (ImageReduced, Region, 'max_separability', 'light', UsedThreshold)</l>
<l>connection (Region, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 800000, 99999999)</l>
<l>paint_region (SelectedRegions, ImageReduced, ImageResult, 255, 'fill')</l>
<l>find_shape_model (ImageResult, ModelID, -0.39, 0.79, 0.3, 1, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, MovementImageToImage)</l>
<c></c>
<c>* image normalization</c>
<l>ROW_1 := 1972 - rowModel</l>
<l>COL_1 := 4257- colModel</l>
<l>RAD_1 := 0</l>
<l>LEN_1 := 150</l>
<l>LEN_2 := 150</l>
<c></c>
<l>AffineTransRect2 (ROW_1, COL_1, RAD_1, LEN_1, LEN_2, MovementImageToImage, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>gen_rectangle2 (Rectangle8, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>reduce_domain (ImageReduced, Rectangle8, ImageReduced1)</l>
<l>gray_features (Rectangle8, ImageReduced1, 'mean', Value)</l>
<l>standardGrayValue := 140.0</l>
<l>scaleFacotr := standardGrayValue / Value</l>
<l>scale_image (Image, Image, scaleFacotr, 0)</l>
<c></c>
<l>ROW1_1 := 2684 - rowModel</l>
<l>COL1_1 := 4804 - colModel</l>
<l>RAD1_1 := rad(180)</l>
<l>LEN1_1 := 200</l>
<l>LEN2_1 := 350</l>
<c></c>
<l>ROW1_2 := 4380 - rowModel</l>
<l>COL1_2 := 4804 - colModel</l>
<l>RAD1_2 := rad(180)</l>
<l>LEN1_2 := 200</l>
<l>LEN2_2 := 350</l>
<c></c>
<l>baseRightRow := [ROW1_1, ROW1_2]</l>
<l>baseRightColum := [COL1_1,COL1_2]</l>
<l>baseRightRadian := [RAD1_1, RAD1_2]</l>
<l>baseRightLen1 := [LEN1_1, LEN1_2]</l>
<l>baseRightLen2 := [LEN2_1, LEN2_2]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, MovementImageToImage, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<l>gen_rectangle2 (Rectangle1, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<l>GetFindLineParams ('RightBase', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, numSubRects, [threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth1, longestOnly2, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<c></c>
<c>* find top base line</c>
<l>ROW_1 := 162.42300000 - rowModel</l>
<l>COL_1 := 3050 - colModel</l>
<l>RAD_1 := rad(-90.00000000)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 200</l>
<c></c>
<l>ROW_2 := 162.42300000 - rowModel</l>
<l>COL_2 := 3694 - colModel</l>
<l>RAD_2 := rad(-90.00000000)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 100</l>
<c></c>
<l>ROW_3 := 162.42300000 - rowModel</l>
<l>COL_3 := 4310 - colModel</l>
<l>RAD_3 := rad(-90.00000000)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 100</l>
<c></c>
<l>baseTopRow := [ROW_1, ROW_2, ROW_3]</l>
<l>baseTopColumn := [COL_1, COL_2, COL_3]</l>
<l>baseTopRadian := [RAD_1, RAD_2, RAD_3]</l>
<l>baseTopLen1 := [LEN1_1, LEN1_2, LEN1_3]</l>
<l>baseTopLen2 := [LEN2_1, LEN2_2, LEN2_3]</l>
<c></c>
<c></c>
<c></c>
<l>AffineTransRect2 (baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, MovementImageToImage, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<l>GetFindLineParams ('TopBase', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, numSubRects, [threshValue,threshValue,threshValue], 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth2, longestOnly3, lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c></c>
<c></c>
<c>* make origin</c>
<l>intersection_lines (lineY1RightBase, lineX1RightBase, lineY2RightBase, lineX2RightBase, lineY1TopBase, lineX1TopBase, lineY2TopBase, lineX2TopBase, rowOrigin, colOrigin, IsOverlapping)</l>
<l>intersectXs := [intersectXs, colOrigin]</l>
<l>intersectYs := [intersectYs, rowOrigin]</l>
<c></c>
<c>*rectify bases</c>
<l>get_perpendicular_line_that_passes (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colOrigin, rowOrigin, ptXOnPerpenducularDir, ptYOnPerpenducularDir)</l>
<l>lineX1RightBase := colOrigin</l>
<l>lineY1RightBase := rowOrigin</l>
<l>lineX2RightBase := ptXOnPerpenducularDir</l>
<l>lineY2RightBase := ptYOnPerpenducularDir</l>
<c></c>
<c></c>
<c>****************************************************FAI2***********************************</c>
<c>* make vertical grids</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI2_LEN_P1, MapToWorld, MapToImage, 'true', FAI2_P1_LineStartX, FAI2_P1_LineStartY, FAI2_P1_LineEndX, FAI2_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI2_LEN_P2, MapToWorld, MapToImage, 'true', FAI2_P2_LineStartX, FAI2_P2_LineStartY, FAI2_P2_LineEndX, FAI2_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI2_LEN_P3, MapToWorld, MapToImage, 'true', FAI2_P3_LineStartX, FAI2_P3_LineStartY, FAI2_P3_LineEndX, FAI2_P3_LineEndY)</l>
<c></c>
<c>* make H line for FAI2</c>
<c></c>
<l>rectFAI2Row :=2173.39000000 - rowModel</l>
<l>rectFAI2Col :=3168.38000000 - colModel</l>
<l>rectFAI2Radian := rad(-91)</l>
<l>rectFAI2Len1 :=100.89500000</l>
<l>rectFAI2Len2 := 200.18000000</l>
<c></c>
<l>rectFAI2Row_RIGHT :=2173.39000000 - rowModel</l>
<l>rectFAI2Col_RIGHT :=4168.38000000 - colModel</l>
<l>rectFAI2Radian_RIGHT := rad(-91)</l>
<l>rectFAI2Len1_RIGHT :=100.89500000</l>
<l>rectFAI2Len2_RIGHT := 200.18000000</l>
<l>AffineTransRect2 ([rectFAI2Row, rectFAI2Row_RIGHT], [rectFAI2Col,rectFAI2Col_RIGHT], [rectFAI2Radian, rectFAI2Radian_RIGHT], [rectFAI2Len1, rectFAI2Len1_RIGHT], [rectFAI2Len2, rectFAI2Len2_RIGHT], MovementImageToImage, rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2)</l>
<l>GetFindLineParams ('2', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rectFAI2, lineRegion, 'positive', rectFAI2Row, rectFAI2Col, rectFAI2Radian, rectFAI2Len1, rectFAI2Len2, 10, [threshValue,threshValue], 'first', ignorePortion, 'false', sigma1, sigma2, 5120, 5120, newWidth, cannyHigh, cannyLow, kernelWidth3, longestOnly4, lineStartX_FAI2H, lineStartY_FAI2H, lineEndX_FAI2H, lineEndY_FAI2H, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rectFAI2, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c></c>
<c>* FAI2-P2</c>
<l>intersection_lines (lineStartY_FAI2H, lineStartX_FAI2H, lineEndY_FAI2H, lineEndX_FAI2H, FAI2_P2_LineStartY, FAI2_P2_LineStartX, FAI2_P2_LineEndY, FAI2_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping1)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c>**********************************************FAI3************************************</c>
<c></c>
<c></c>
<l>rectFAI3Row :=2200.39000000 - rowModel</l>
<l>rectFAI3Col :=3168.38000000 - colModel</l>
<l>rectFAI3Radian := rad(-94)</l>
<l>rectFAI3Len1 :=50.89500000</l>
<l>rectFAI3Len2 := 200.18000000</l>
<c></c>
<l>rectFAI3Row_RIGHT :=2233.39000000 - rowModel</l>
<l>rectFAI3Col_RIGHT :=4168.38000000 - colModel</l>
<l>rectFAI3Radian_RIGHT := rad(-93)</l>
<l>rectFAI3Len1_RIGHT :=50.89500000</l>
<l>rectFAI3Len2_RIGHT := 200.18000000</l>
<l>AffineTransRect2 ([rectFAI3Row, rectFAI3Row_RIGHT], [rectFAI3Col,rectFAI3Col_RIGHT], [rectFAI3Radian, rectFAI3Radian_RIGHT], [rectFAI3Len1, rectFAI3Len1_RIGHT], [rectFAI3Len2, rectFAI3Len2_RIGHT], MovementImageToImage, rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2)</l>
<c></c>
<l>gen_rectangle2 (Rectangle7, rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2)</l>
<l>* VisionProStyleFindLineOneStep (Image, rectFAI3, lineRegion, 'negative', rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2, 10, [FAI3Threshold,FAI3Threshold], 'first', 0.2, 'false', 1, 1, 5120, 5120, 5, 15, 5, kernelWidth4, longestOnly5, lineX1FAI3, lineY1FAI3, lineX2FAI3, lineY2FAI3, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>GetFindLineParams ('3', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>FindLineAdaptiveSingle (Image, rectFAI3, lineRegion, lineContours, rectFAI3Row, rectFAI3Col, rectFAI3Radian, rectFAI3Len1, rectFAI3Len2, 5, 'negative', [threshValue,threshValue], sigma1, sigma21, 'first', widthRatio, ignoreFraction, newWidth1, cannyLow1, cannyHigh1, kernelWidth, longestOnly, XsUsed, Ys, lineX2, lineY2, XsUsed1, YsUsed1, XsIgnored1, YsIgnored1)</l>
<c></c>
<l>concat_obj (FindLineRects, rectFAI3, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI3_LEN_P1, MapToWorld, MapToImage, 'true', FAI3_P1_LineStartX, FAI3_P1_LineStartY, FAI3_P1_LineEndX, FAI3_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI3_LEN_P2, MapToWorld, MapToImage, 'true', FAI3_P2_LineStartX, FAI3_P2_LineStartY, FAI3_P2_LineEndX, FAI3_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI3_LEN_P3, MapToWorld, MapToImage, 'true', FAI3_P3_LineStartX, FAI3_P3_LineStartY, FAI3_P3_LineEndX, FAI3_P3_LineEndY)</l>
<c></c>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI3, lineX1FAI3, lineY2FAI3, lineX2FAI3, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>***********************************************FAI4*******************************</c>
<l>rectFAI4Row := 4682.30000000 - rowModel</l>
<l>rectFAI4Col := 3567.21000000 - colModel</l>
<l>rectFAI4Radian := rad(85)</l>
<l>rectFAI4Len1 := 70.89900000</l>
<l>rectFAI4Len2 := 800</l>
<l>AffineTransRect2 (rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2, MovementImageToImage, rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2)</l>
<l>gen_rectangle2 (Rectangle6, rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2)</l>
<l>GetFindLineParams ('4', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rectFAI4, lineRegion, 'negative', rectFAI4Row, rectFAI4Col, rectFAI4Radian, rectFAI4Len1, rectFAI4Len2, 6, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth5, longestOnly6, lineX1FAI4, lineY1FAI4, lineX2FAI4, lineY2FAI4, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rectFAI4, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P1_LineStartY, FAI3_P1_LineStartX, FAI3_P1_LineEndY, FAI3_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI4, lineX1FAI4, lineY2FAI4, lineX2FAI4, FAI3_P3_LineStartY, FAI3_P3_LineStartX, FAI3_P3_LineEndY, FAI3_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>*************************************FAI 5***************************************</c>
<l>ROW_1 := 4850 - rowModel</l>
<l>COL_1 := 2800 - colModel</l>
<l>RAD_1 := rad(-90.00000000)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 200</l>
<c></c>
<l>ROW_2 := 4850- rowModel</l>
<l>COL_2 := 3650 - colModel</l>
<l>RAD_2 := rad(-90.00000000)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 150</l>
<c></c>
<l>ROW_3 := 4890- rowModel</l>
<l>COL_3 := 4470 - colModel</l>
<l>RAD_3 := rad(-90.00000000)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 200</l>
<c></c>
<c></c>
<l>rectFAI5Row := [ROW_1, ROW_2, ROW_3]</l>
<l>rectFAI5Col := [COL_1, COL_2, COL_3]</l>
<l>rectFAI5Radian := [RAD_1, RAD_2, RAD_3]</l>
<l>rectFAI5Len1 := [LEN1_1, LEN1_2, LEN1_3]</l>
<l>rectFAI5Len2 := [LEN2_1, LEN2_2, LEN2_3]</l>
<c></c>
<l>AffineTransRect2 (rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2, MovementImageToImage, rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2)</l>
<l>gen_rectangle2 (Rectangle2, rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2)</l>
<c></c>
<l>GetFindLineParams ('5', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'positive', rectFAI5Row, rectFAI5Col, rectFAI5Radian, rectFAI5Len1, rectFAI5Len2, 6, [threshValue,threshValue,threshValue], 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth6, longestOnly7, lineX1FAI5, lineY1FAI5, lineX2FAI5, lineY2FAI5, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI5, lineX1FAI5, lineY2FAI5, lineX2FAI5, FAI3_P1_LineStartY, FAI3_P1_LineStartX, FAI3_P1_LineEndY, FAI3_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI5, lineX1FAI5, lineY2FAI5, lineX2FAI5, FAI3_P2_LineStartY, FAI3_P2_LineStartX, FAI3_P2_LineEndY, FAI3_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI5, lineX1FAI5, lineY2FAI5, lineX2FAI5, FAI3_P3_LineStartY, FAI3_P3_LineStartX, FAI3_P3_LineEndY, FAI3_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c>*************************************FAI 6******************************************</c>
<l>rectFAI6Row := 2983.82000000 - rowModel</l>
<l>rectFAI6Col := 1710.50000000 - colModel</l>
<l>rectFAI6Radian := rad(88)</l>
<l>rectFAI6Len1 := 101.93600000</l>
<l>rectFAI6Len2 := 300.58900000</l>
<l>AffineTransRect2 (rectFAI6Row, rectFAI6Col, rectFAI6Radian, rectFAI6Len1, rectFAI6Len2, MovementImageToImage, rectFAI6Row, rectFAI6Col, rectFAI6Radian, rectFAI6Len1, rectFAI6Len2)</l>
<l>GetFindLineParams ('6', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI6Row, rectFAI6Col, rectFAI6Radian, rectFAI6Len1, rectFAI6Len2, numSubRects, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth7, longestOnly8, lineX1FAI6, lineY1FAI6, lineX2FAI6, lineY2FAI6, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI6_LEN_P1, MapToWorld, MapToImage, 'true', FAI6_P1_LineStartX, FAI6_P1_LineStartY, FAI6_P1_LineEndX, FAI6_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI6_LEN_P2, MapToWorld, MapToImage, 'true', FAI6_P2_LineStartX, FAI6_P2_LineStartY, FAI6_P2_LineEndX, FAI6_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI6_LEN_P3, MapToWorld, MapToImage, 'true', FAI6_P3_LineStartX, FAI6_P3_LineStartY, FAI6_P3_LineEndX, FAI6_P3_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI6, lineX1FAI6, lineY2FAI6, lineX2FAI6, FAI6_P1_LineStartY, FAI6_P1_LineStartX, FAI6_P1_LineEndY, FAI6_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI6, lineX1FAI6, lineY2FAI6, lineX2FAI6, FAI6_P2_LineStartY, FAI6_P2_LineStartX, FAI6_P2_LineEndY, FAI6_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI6, lineX1FAI6, lineY2FAI6, lineX2FAI6, FAI6_P3_LineStartY, FAI6_P3_LineStartX, FAI6_P3_LineEndY, FAI6_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>*************************************FAI9********************************************</c>
<l>rectFAI9Row := 1584.57000000 - rowModel</l>
<l>rectFAI9Col := 1744.61000000 - colModel</l>
<l>rectFAI9Radian := rad(-90)</l>
<l>rectFAI9Len1 := 97.95910000</l>
<l>rectFAI9Len2 := 275.13700000</l>
<l>AffineTransRect2 (rectFAI9Row, rectFAI9Col, rectFAI9Radian, rectFAI9Len1, rectFAI9Len2, MovementImageToImage, rectFAI9Row, rectFAI9Col, rectFAI9Radian, rectFAI9Len1, rectFAI9Len2)</l>
<l>GetFindLineParams ('9', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI9Row, rectFAI9Col, rectFAI9Radian, rectFAI9Len1, rectFAI9Len2, numSubRects, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth8, longestOnly9, lineX1FAI9, lineY1FAI9, lineX2FAI9, lineY2FAI9, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI9_LEN_P1, MapToWorld, MapToImage, 'true', FAI9_P1_LineStartX, FAI9_P1_LineStartY, FAI9_P1_LineEndX, FAI9_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI9_LEN_P2, MapToWorld, MapToImage, 'true', FAI9_P2_LineStartX, FAI9_P2_LineStartY, FAI9_P2_LineEndX, FAI9_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI9_LEN_P3, MapToWorld, MapToImage, 'true', FAI9_P3_LineStartX, FAI9_P3_LineStartY, FAI9_P3_LineEndX, FAI9_P3_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI9, lineX1FAI9, lineY2FAI9, lineX2FAI9, FAI9_P1_LineStartY, FAI9_P1_LineStartX, FAI9_P1_LineEndY, FAI9_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI9, lineX1FAI9, lineY2FAI9, lineX2FAI9, FAI9_P2_LineStartY, FAI9_P2_LineStartX, FAI9_P2_LineEndY, FAI9_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P3</c>
<l>intersection_lines (lineY1FAI9, lineX1FAI9, lineY2FAI9, lineX2FAI9, FAI9_P3_LineStartY, FAI9_P3_LineStartX, FAI9_P3_LineEndY, FAI9_P3_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>******************************FAI12**************************</c>
<l>ROW_1 := 3240 - rowModel</l>
<l>COL_1 := 2420- colModel</l>
<l>RAD_1 := rad(-1)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 100</l>
<c></c>
<l>ROW_2 := 3886- rowModel</l>
<l>COL_2 := 2400- colModel</l>
<l>RAD_2 := rad(-1)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 100</l>
<c></c>
<l>ROW_3 := 4500- rowModel</l>
<l>COL_3 := 2400- colModel</l>
<l>RAD_3 := rad(-1)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 200</l>
<c></c>
<c></c>
<c></c>
<l>rectFAI12Row := [ROW_1, ROW_2, ROW_3]</l>
<l>rectFAI12Col := [COL_1, COL_2, COL_3]</l>
<l>rectFAI12Radian := [RAD_1, RAD_2, RAD_3]</l>
<l>rectFAI12Len1 := [LEN1_1, LEN1_2, LEN1_3]</l>
<l>rectFAI12Len2 := [LEN2_1, LEN2_2, LEN2_3]</l>
<l>AffineTransRect2 (rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2, MovementImageToImage, rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2)</l>
<c></c>
<l>gen_rectangle2 (Rectangle, rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2)</l>
<l>GetFindLineParams ('12', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI12Row, rectFAI12Col, rectFAI12Radian, rectFAI12Len1, rectFAI12Len2, numSubRects, [threshValue,threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth9, longestOnly10, lineX1FAI12, lineY1FAI12, lineX2FAI12, lineY2FAI12, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate TOP right</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI12_LEN_P1, MapToWorld, MapToImage, 'false', FAI12_P1_LineStartX, FAI12_P1_LineStartY, FAI12_P1_LineEndX, FAI12_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI12_LEN_P2, MapToWorld, MapToImage, 'false', FAI12_P2_LineStartX, FAI12_P2_LineStartY, FAI12_P2_LineEndX, FAI12_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI12, lineX1FAI12, lineY2FAI12, lineX2FAI12, FAI12_P1_LineStartY, FAI12_P1_LineStartX, FAI12_P1_LineEndY, FAI12_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<c>****************</c>
<l>GenLineRegion (lineRegion1, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, 5120, 5120)</l>
<l>gen_cross_contour_xld (Cross, rowIntersect, colIntersect, 300, Angle)</l>
<c>***************</c>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI12, lineX1FAI12, lineY2FAI12, lineX2FAI12, FAI12_P2_LineStartY, FAI12_P2_LineStartX, FAI12_P2_LineEndY, FAI12_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>*********************************FAI16*************************</c>
<l>rectFAI16Row := 2246.47000000 - rowModel</l>
<l>rectFAI16Col := 992.65500000 - colModel</l>
<l>rectFAI16Radian := rad(-0.5)</l>
<l>rectFAI16Len1 := 125.95600000</l>
<l>rectFAI16Len2 := 470.84500000</l>
<c></c>
<l>AffineTransRect2 (rectFAI16Row, rectFAI16Col, rectFAI16Radian, rectFAI16Len1, rectFAI16Len2, MovementImageToImage, rectFAI16Row, rectFAI16Col, rectFAI16Radian, rectFAI16Len1, rectFAI16Len2)</l>
<l>GetFindLineParams ('16', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI16Row, rectFAI16Col, rectFAI16Radian, rectFAI16Len1, rectFAI16Len2, 6, threshValue, 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth10, longestOnly11, lineX1FAI16, lineY1FAI16, lineX2FAI16, lineY2FAI16, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate base top</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI16_LEN_P1, MapToWorld, MapToImage, 'false', FAI16_P1_LineStartX, FAI16_P1_LineStartY, FAI16_P1_LineEndX, FAI16_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI16_LEN_P2, MapToWorld, MapToImage, 'false', FAI16_P2_LineStartX, FAI16_P2_LineStartY, FAI16_P2_LineEndX, FAI16_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI16, lineX1FAI16, lineY2FAI16, lineX2FAI16, FAI16_P1_LineStartY, FAI16_P1_LineStartX, FAI16_P1_LineEndY, FAI16_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI16, lineX1FAI16, lineY2FAI16, lineX2FAI16, FAI16_P2_LineStartY, FAI16_P2_LineStartX, FAI16_P2_LineEndY, FAI16_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c>**************************FAI17*******************************</c>
<l>ROW_1 := 466 - rowModel</l>
<l>COL_1 := 2700- colModel</l>
<l>RAD_1 := rad(-1)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 100</l>
<c></c>
<l>ROW_2 := 868- rowModel</l>
<l>COL_2 := 2670- colModel</l>
<l>RAD_2 := rad(-1)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 100</l>
<c></c>
<l>ROW_3 := 1266- rowModel</l>
<l>COL_3 := 2670- colModel</l>
<l>RAD_3 := rad(-1)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 100</l>
<c></c>
<c></c>
<c></c>
<l>rectFAI17Row := [ROW_1, ROW_2, ROW_3]</l>
<l>rectFAI17Col := [COL_1, COL_2, COL_3]</l>
<l>rectFAI17Radian := [RAD_1, RAD_2, RAD_3]</l>
<l>rectFAI17Len1 := [LEN1_1, LEN1_2, LEN1_3]</l>
<l>rectFAI17Len2 := [LEN2_1, LEN2_2, LEN2_3]</l>
<l>AffineTransRect2 (rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2, MovementImageToImage, rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2)</l>
<l>gen_rectangle2 (Rectangle3, rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2)</l>
<l>GetFindLineParams ('17', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI17Row, rectFAI17Col, rectFAI17Radian, rectFAI17Len1, rectFAI17Len2, numSubRects, [threshValue, threshValue, threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth11, longestOnly12, lineX1FAI17, lineY1FAI17, lineX2FAI17, lineY2FAI17, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate top base</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI17_LEN_P1, MapToWorld, MapToImage, 'false', FAI17_P1_LineStartX, FAI17_P1_LineStartY, FAI17_P1_LineEndX, FAI17_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI17_LEN_P2, MapToWorld, MapToImage, 'false', FAI17_P2_LineStartX, FAI17_P2_LineStartY, FAI17_P2_LineEndX, FAI17_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI17, lineX1FAI17, lineY2FAI17, lineX2FAI17, FAI17_P1_LineStartY, FAI17_P1_LineStartX, FAI17_P1_LineEndY, FAI17_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI17, lineX1FAI17, lineY2FAI17, lineX2FAI17, FAI17_P2_LineStartY, FAI17_P2_LineStartX, FAI17_P2_LineEndY, FAI17_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<c></c>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>********************************FAI19**************************</c>
<l>ROW_1 := 887 - rowModel</l>
<l>COL_1 := 4665- colModel</l>
<l>RAD_1 := rad(179.5)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 350</l>
<c></c>
<l>ROW_2 := 1806- rowModel</l>
<l>COL_2 := 4665- colModel</l>
<l>RAD_2 := rad(179)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 140</l>
<c></c>
<l>rectFAI19Row := [ROW_1, ROW_2]</l>
<l>rectFAI19Col := [COL_1, COL_2]</l>
<l>rectFAI19Radian := [RAD_1, RAD_2]</l>
<l>rectFAI19Len1 := [LEN1_1, LEN1_2]</l>
<l>rectFAI19Len2 := [LEN2_1, LEN2_2]</l>
<l>AffineTransRect2 (rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2, MovementImageToImage, rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2)</l>
<l>gen_rectangle2 (Rectangle4, rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2)</l>
<l>GetFindLineParams ('19', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI19Row, rectFAI19Col, rectFAI19Radian, rectFAI19Len1, rectFAI19Len2, 6, [threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth12, longestOnly13, lineX1FAI19, lineY1FAI19, lineX2FAI19, lineY2FAI19, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* translate top base</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI19_LEN_P1, MapToWorld, MapToImage, 'false', FAI19_P1_LineStartX, FAI19_P1_LineStartY, FAI19_P1_LineEndX, FAI19_P1_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI19_LEN_P2, MapToWorld, MapToImage, 'false', FAI19_P2_LineStartX, FAI19_P2_LineStartY, FAI19_P2_LineEndX, FAI19_P2_LineEndY)</l>
<c></c>
<c>* P1</c>
<l>intersection_lines (lineY1FAI19, lineX1FAI19, lineY2FAI19, lineX2FAI19, FAI19_P1_LineStartY, FAI19_P1_LineStartX, FAI19_P1_LineEndY, FAI19_P1_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* P2</c>
<l>intersection_lines (lineY1FAI19, lineX1FAI19, lineY2FAI19, lineX2FAI19, FAI19_P2_LineStartY, FAI19_P2_LineStartX, FAI19_P2_LineEndY, FAI19_P2_LineEndX, rowIntersect, colIntersect, IsOverlapping2)</l>
<l>DistancePLInWorld (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, colIntersect, rowIntersect, MapToWorld, distanceWorld, distancePixel)</l>
<l>intersectXs := [intersectXs, colIntersect]</l>
<l>intersectYs := [intersectYs, rowIntersect]</l>
<c></c>
<l>outputs := [outputs, distanceWorld]</l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*****************************FAI20********************************</c>
<c>* 定圆心</c>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, FAI20_LEN_Y, MapToWorld, MapToImage, 'false', FAI20_P2_LineStartX, FAI20_P2_LineStartY, FAI20_P2_LineEndX, FAI20_P2_LineEndY)</l>
<l>TranslateLineInWorldCoordinateAndConvertBack (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, FAI20_LEN_X, MapToWorld, MapToImage, 'true', FAI20V_P1_LineStartX, FAI20V_P1_LineStartY, FAI20V_P1_LineEndX, FAI20V_P1_LineEndY)</l>
<l>intersection_lines (FAI20_P2_LineStartY, FAI20_P2_LineStartX, FAI20_P2_LineEndY, FAI20_P2_LineEndX, FAI20V_P1_LineStartY, FAI20V_P1_LineStartX, FAI20V_P1_LineEndY, FAI20V_P1_LineEndX, rowCenterTop, colCenterTop, IsOverlapping2)</l>
<l>intersectXs := [intersectXs, colCenterTop]</l>
<l>intersectYs := [intersectYs, rowCenterTop]</l>
<c></c>
<l>rectFAI20TRRow := 288.18300000 -rowModel</l>
<l>rectFAI20TRCol := 4587.96000000 - colModel</l>
<l>rectFAI20TRRadian := rad(50.84800000)</l>
<l>rectFAI20TRLen1 := 84.64630000</l>
<l>rectFAI20TRLen2 := 65.46210000</l>
<c></c>
<l>AffineTransRect2 (rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2, MovementImageToImage, rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2)</l>
<l>gen_rectangle2 (Rectangle5, rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2)</l>
<l>GetFindLineParams ('20-topRight', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep_Pairs (Image, rect, lineRegion, rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2, 'negative', 6, threshValue, sigma1, sigma2, 'last', 'false', ignorePortion, 'first', 10, 50, 5120, 5120, cannyHigh, cannyLow, 'true', newWidth, kernelWidth15, longestOnly1, XsUsed, YsUsed, XsIgnored, YsIgnored, lineX1FAI20TR, lineY1FAI20TR, lineX2FAI20TR, lineY2FAI20TR)</l>
<c></c>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI20TRRow, rectFAI20TRCol, rectFAI20TRRadian, rectFAI20TRLen1, rectFAI20TRLen2, 5, FAI20Threshold_up, 'first', 0.3, 'false', 3, sigma2, Width, Height, newWidth, 30, 15, kernelWidth13, longestOnly14, lineX1FAI20TR, lineY1FAI20TR, lineX2FAI20TR, lineY2FAI20TR, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<l>rectFAI20BLRow := 2078.83000000 - rowModel</l>
<l>rectFAI20BLCol := 2775.07000000 - colModel</l>
<l>rectFAI20BLRadian := rad(45)</l>
<l>rectFAI20BLLen1 := 80.07090000</l>
<l>rectFAI20BLLen2 := 80.95030000</l>
<l>AffineTransRect2 (rectFAI20BLRow, rectFAI20BLCol, rectFAI20BLRadian, rectFAI20BLLen1, rectFAI20BLLen2, MovementImageToImage, rectFAI20BLRow, rectFAI20BLCol, rectFAI20BLRadian, rectFAI20BLLen1, rectFAI20BLLen2)</l>
<l>GetFindLineParams ('20-bottomLeft', FindLineNames, thresholds, IgnorePortions, Sigma1s, Sigma2s, NewWidths, CannyLows, CannyHighs, threshValue, ignorePortion, sigma1, sigma2, newWidth, cannyLow, cannyHigh)</l>
<l>VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', rectFAI20BLRow, rectFAI20BLCol, rectFAI20BLRadian, rectFAI20BLLen1, rectFAI20BLLen2, 10, threshValue, 'first', ignorePortion, 'false', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth14, longestOnly15, lineX1FAI20BL, lineY1FAI20BL, lineX2FAI20BL, lineY2FAI20BL, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>concat_obj (FindLineRects, rect, FindLineRects)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<c></c>
<l>crossesXused := [crossesXused, XsUsed]</l>
<l>crossesYused := [crossesYused, YsUsed]</l>
<l>crossesXIgnored := [crossesXIgnored, XsIgnored]</l>
<l>crossesYIgnored := [crossesYIgnored, YsIgnored]</l>
<c></c>
<c>* FAI20-1</c>
<l>ptX_TR :=(lineX1FAI20TR + lineX2FAI20TR) / 2.0</l>
<l>ptY_TR := (lineY1FAI20TR + lineY2FAI20TR) / 2.0</l>
<l>intersectXs := [intersectXs, ptX_TR]</l>
<l>intersectYs := [intersectYs, ptY_TR]</l>
<c></c>
<l>DistancePLInWorld (lineX1FAI20BL, lineY1FAI20BL, lineX2FAI20BL, lineY2FAI20BL, ptX_TR, ptY_TR, MapToWorld, distanceWorld, distancePixel)</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<c>* FAI20-2</c>
<l>ptX_BL :=(lineX1FAI20BL + lineX2FAI20BL) / 2.0</l>
<l>ptY_BL := (lineY1FAI20BL + lineY2FAI20BL) / 2.0</l>
<l>intersectXs := [intersectXs, ptX_BL]</l>
<l>intersectYs := [intersectYs, ptY_BL]</l>
<c></c>
<l>ptX := (ptX_TR + ptX_BL) / 2.0</l>
<l>ptY := (ptY_TR + ptY_BL) / 2.0</l>
<c></c>
<l>PivotLineAroundPoint(lineRegion, lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colOrigin, rowOrigin, rad(45), 'right', 5120, 5120, outLineX1, outLineY1, outLineX2, outLineY2)</l>
<l>concat_obj (lineRegions, lineRegion, lineRegions)</l>
<l>DistancePLInWorld (outLineX1, outLineY1, outLineX2, outLineY2, ptX, ptY, MapToWorld, distanceWorld, distancePixel)</l>
<l>distanceWorld := abs(distanceWorld - 12.202)</l>
<l>outputs := [outputs, distanceWorld] </l>
<l>outputsPixel := [outputsPixel, distancePixel]</l>
<c></c>
<l>numOutputs := |outputs|</l>
<l>numOutputPixels := |outputsPixel|</l>
<l>return ()</l>
</body>
<docu id="I94TopFaceMeasurement">
<parameters>
<parameter id="CannyHighs"/>
<parameter id="CannyLows"/>
<parameter id="FindLineNames"/>
<parameter id="FindLineRects"/>
<parameter id="IgnorePortions"/>
<parameter id="Image"/>
<parameter id="ImageUndistorted"/>
<parameter id="ModelID"/>
<parameter id="NewWidths"/>
<parameter id="Sigma1s"/>
<parameter id="Sigma2s"/>
<parameter id="crossesXIgnored"/>
<parameter id="crossesXused"/>
<parameter id="crossesYIgnored"/>
<parameter id="crossesYused"/>
<parameter id="intersectXs"/>
<parameter id="intersectYs"/>
<parameter id="lineRegions"/>
<parameter id="outputs"/>
<parameter id="outputsPixel"/>
<parameter id="thresholds"/>
<parameter id="xCoeff"/>
<parameter id="yCoeff"/>
</parameters>
</docu>
</procedure>
<procedure name="FindLineAdaptiveSingle">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRect" base_type="iconic" dimension="0"/>
<par name="lineRegion" base_type="iconic" dimension="0"/>
<par name="lineContours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="sigma1" base_type="ctrl" dimension="0"/>
<par name="sigma2" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
<par name="widthRatio" base_type="ctrl" dimension="0"/>
<par name="ignoreFraction" base_type="ctrl" dimension="0"/>
<par name="newWidth" base_type="ctrl" dimension="0"/>
<par name="cannyLow" base_type="ctrl" dimension="0"/>
<par name="cannyHigh" base_type="ctrl" dimension="0"/>
<par name="kernelWidth" base_type="ctrl" dimension="0"/>
<par name="longestOnly" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>VisionProStyleFindLine (inputImage, findLineRect, transition, row, col, radian, len1, len2, numSubRects, threshold, sigma1, firstOrLast, 'false', 'first', 0, 100, Xs, Ys)</l>
<c></c>
<c>        </c>
<l>        FitLine2D (Xs, Ys, ignoreFraction, lineX1, lineY1, lineX2, lineY2, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>GetEdgesInSubRect2 (inputImage, subRect, Edges, lineX1, lineY1, lineX2, lineY2, radian, newWidth, sigma2, cannyLow, cannyHigh, kernelWidth, longestOnly)</l>
<l>        LongestXLD (Edges, outputContour, contourLength)</l>
<c>        </c>
<l>        minLength :=  widthRatio * len2</l>
<c>        </c>
<l>        if(contourLength &lt; minLength)</l>
<c>            * using leaset square fit</c>
<l>            gen_empty_obj (lineContours)</l>
<l>        else</l>
<c>            * using turkey</c>
<l>            fit_line_contour_xld (outputContour, 'tukey', -1, 0, 5, 2, lineY1, lineX1, lineY2, lineX2, Nr, Nc, Dist)</l>
<l>            findLineRect := subRect</l>
<l>            lineContours := outputContour</l>
<c>            </c>
<l>        endif</l>
<c>        </c>
<c></c>
<l>            GenLineRegion (lineRegion, lineX1, lineY1, lineX2, lineY2, 5120, 5120)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="FindLineAdaptiveSingle">
<parameters>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="cannyHigh"/>
<parameter id="cannyLow"/>
<parameter id="col"/>
<parameter id="findLineRect"/>
<parameter id="firstOrLast">
<default_value>'first'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="ignoreFraction"/>
<parameter id="inputImage"/>
<parameter id="kernelWidth"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="lineContours"/>
<parameter id="lineRegion"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="longestOnly"/>
<parameter id="newWidth"/>
<parameter id="numSubRects">
<default_value>10</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="radian"/>
<parameter id="row"/>
<parameter id="sigma1">
<default_value>2</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="sigma2"/>
<parameter id="threshold">
<default_value>20</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="transition">
<default_value>'positive'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="widthRatio"/>
</parameters>
</docu>
</procedure>
<procedure name="DegreeToUnitVector">
<interface>
<ic>
<par name="Degree" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="VecX" base_type="ctrl" dimension="0"/>
<par name="VecY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>VecX := cos(rad(Degree))</l>
<l>VecY := sin(rad(Degree))</l>
<l>return ()</l>
</body>
<docu id="DegreeToUnitVector">
<parameters>
<parameter id="Degree"/>
<parameter id="VecX"/>
<parameter id="VecY"/>
</parameters>
</docu>
</procedure>
<procedure name="GetChangeOfBase">
<interface>
<ic>
<par name="xStartXAxis" base_type="ctrl" dimension="0"/>
<par name="yStartXAxis" base_type="ctrl" dimension="0"/>
<par name="xEndXAxis" base_type="ctrl" dimension="0"/>
<par name="yEndXAxis" base_type="ctrl" dimension="0"/>
<par name="xStartYAxis" base_type="ctrl" dimension="0"/>
<par name="yStartYAxis" base_type="ctrl" dimension="0"/>
<par name="xEndYAxis" base_type="ctrl" dimension="0"/>
<par name="yEndYAxis" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ChangeOfBase" base_type="ctrl" dimension="0"/>
<par name="ChangeOfBaseInv" base_type="ctrl" dimension="0"/>
<par name="RotationMat" base_type="ctrl" dimension="0"/>
<par name="RotationMatInv" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>GetLineUnitVector (xStartXAxis, yStartXAxis, xEndXAxis, yEndXAxis, xUnitXAxis, yUnitXAxis)</l>
<l>GetLineUnitVector (xStartYAxis, yStartYAxis, xEndYAxis, yEndYAxis, xUnitYAxis, yUnitYAxis)</l>
<c></c>
<l>intersection_lines (yStartXAxis, xStartXAxis, yEndXAxis, xEndXAxis, yStartYAxis, xStartYAxis, yEndYAxis, xEndYAxis, YNewOrg, XNewOrg, IsOverlapping)</l>
<c></c>
<l>ChangeOfBase := [xUnitXAxis, xUnitYAxis, XNewOrg, yUnitXAxis, yUnitYAxis, YNewOrg, 0, 0, 1]</l>
<l>RotationMat := [xUnitXAxis, xUnitYAxis, 0, yUnitXAxis, yUnitYAxis, 0, 0, 0, 1]</l>
<c></c>
<l>create_matrix (3, 3, ChangeOfBase, MatrixID)</l>
<l>create_matrix (3, 3, RotationMat, MatrixIDRotation)</l>
<c></c>
<l>invert_matrix (MatrixID, 'general', 0, MatrixInvID)</l>
<l>invert_matrix (MatrixIDRotation, 'general', 0, MatrixIDRotationInv)</l>
<c></c>
<l>get_full_matrix (MatrixInvID, ChangeOfBaseInv)</l>
<l>get_full_matrix (MatrixIDRotationInv, RotationMatInv)</l>
<l>return ()</l>
</body>
<docu id="GetChangeOfBase">
<abstract lang="en_US">Compute the chang of base matrix given two new axis.
The positive direction of an axis is from Start to End.</abstract>
<parameters>
<parameter id="ChangeOfBase"/>
<parameter id="ChangeOfBaseInv"/>
<parameter id="RotationMat"/>
<parameter id="RotationMatInv"/>
<parameter id="xEndXAxis"/>
<parameter id="xEndYAxis"/>
<parameter id="xStartXAxis"/>
<parameter id="xStartYAxis"/>
<parameter id="yEndXAxis"/>
<parameter id="yEndYAxis"/>
<parameter id="yStartXAxis"/>
<parameter id="yStartYAxis"/>
</parameters>
</docu>
</procedure>
<procedure name="DegreeRelativeToAbs">
<interface>
<ic>
<par name="RotationMat" base_type="ctrl" dimension="0"/>
<par name="DegreeRelative" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DegreeAbs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>DegreeToUnitVector (DegreeRelative, VecX, VecY)</l>
<l>affine_trans_point_2d (RotationMat, VecX, VecY, xUnitNewOrgToFeatureAbs, yUnitNewOrgToFeatureAbs)</l>
<l>angleAbs := -atan2(yUnitNewOrgToFeatureAbs, xUnitNewOrgToFeatureAbs)</l>
<l>DegreeAbs := deg(angleAbs)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="DegreeRelativeToAbs">
<abstract lang="en_US">Convert relative angle to absolute angle
Note that relative angle is in normal representation, but absolute angle is in halcon representation</abstract>
<parameters>
<parameter id="DegreeAbs"/>
<parameter id="DegreeRelative"/>
<parameter id="RotationMat">
<description lang="en_US">Exact RotationMat provided by GetChangeOfBase</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="PointRelativeToAbs">
<interface>
<ic>
<par name="XRelative" base_type="ctrl" dimension="0"/>
<par name="YRelative" base_type="ctrl" dimension="0"/>
<par name="ChangeOfBase" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XAbs" base_type="ctrl" dimension="0"/>
<par name="YAbs" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>affine_trans_point_2d (ChangeOfBase, XRelative, YRelative, XAbs, YAbs)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="PointRelativeToAbs">
<parameters>
<parameter id="ChangeOfBase">
<description lang="en_US">ChangeOfBase from GetChangeOfBase</description>
</parameter>
<parameter id="XAbs"/>
<parameter id="XRelative"/>
<parameter id="YAbs"/>
<parameter id="YRelative"/>
</parameters>
</docu>
</procedure>
<procedure name="GetVectorDegree">
<interface>
<ic>
<par name="VecX" base_type="ctrl" dimension="0"/>
<par name="VecY" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Degree" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>radian := atan2(VecY, VecX)</l>
<l>Degree := deg(radian)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetVectorDegree">
<abstract lang="en_US">Get degree of a vector,normal representation. NOT in Halcon representation !</abstract>
<parameters>
<parameter id="Degree"/>
<parameter id="VecX"/>
<parameter id="VecY"/>
</parameters>
</docu>
</procedure>
<procedure name="I94TopViewChangeBase">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageUndistorted" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ChangeOfBase" base_type="ctrl" dimension="0"/>
<par name="ChangeOfBaseInv" base_type="ctrl" dimension="0"/>
<par name="RotationMat" base_type="ctrl" dimension="0"/>
<par name="RotationMatInv" base_type="ctrl" dimension="0"/>
<par name="MapToWorld" base_type="ctrl" dimension="0"/>
<par name="MapToImage" base_type="ctrl" dimension="0"/>
<par name="lineX1TopBase" base_type="ctrl" dimension="0"/>
<par name="lineY1TopBase" base_type="ctrl" dimension="0"/>
<par name="lineX2TopBase" base_type="ctrl" dimension="0"/>
<par name="lineY2TopBase" base_type="ctrl" dimension="0"/>
<par name="lineX1RightBase" base_type="ctrl" dimension="0"/>
<par name="lineY1RightBase" base_type="ctrl" dimension="0"/>
<par name="lineX2RightBase" base_type="ctrl" dimension="0"/>
<par name="lineY2RightBase" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CameraParameters := ['area_scan_telecentric_division',0.588471,3.42746,4.4974e-006,4.5e-006,2556.48,2560.7,5120,5120]</l>
<l>CameraPose := [0.00180843,-0.000646214,0.000999199,0.316458,2.27204,180.151,0]</l>
<l>UndistortImage (Image, Image, CameraParameters, OutCameraParams)</l>
<l>ImageUndistorted := Image</l>
<c></c>
<l>GenCalibrationMaps (Image, OutCameraParams, CameraPose, MapToWorld, MapToImage)</l>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<l>numSubRects := 10</l>
<c></c>
<l>ModelThreshold := 160</l>
<l>threshValue := 20</l>
<l>ignorePortion := 0.2</l>
<l>sigma1 := 1</l>
<l>sigma2 := 1</l>
<l>cannyHigh := 40</l>
<l>cannyLow := 20</l>
<l>newWidth := 5</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* find model front light</c>
<l>* Threshold := 128</l>
<c></c>
<l>* gen_rectangle1 (ROI_0, 53.9, 1940.83, 2000, 3900)</l>
<l>* reduce_domain (Image, ROI_0, ImageReduced)</l>
<l>* binary_threshold (ImageReduced, Region, 'max_separability', 'light', UsedThreshold)</l>
<l>* connection (Region, ConnectedRegions)</l>
<l>* select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 800000, 99999999)</l>
<l>* paint_region (SelectedRegions, ImageReduced, ImageResult, 255, 'fill')</l>
<c></c>
<c></c>
<c>* find model back light</c>
<l>gen_rectangle1 (ROI_0, 79.5, 1762.7, 2185.1, 4943.5)</l>
<l>reduce_domain (Image, ROI_0, ImageResult)</l>
<c></c>
<c></c>
<c></c>
<l>rowModel := 1171.5</l>
<l>colModel := 3678.5</l>
<l>find_shape_model (ImageResult, ModelHandle, -0.39, 0.79, 0.3, 1, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, MovementImageToImage)</l>
<c></c>
<c>* image normalization</c>
<l>* ROW_1 := 1972 - rowModel</l>
<l>* COL_1 := 4257- colModel</l>
<l>* RAD_1 := 0</l>
<l>* LEN_1 := 150</l>
<l>* LEN_2 := 150</l>
<c></c>
<l>* AffineTransRect2 (ROW_1, COL_1, RAD_1, LEN_1, LEN_2, MovementImageToImage, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>* gen_rectangle2 (Rectangle8, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>* reduce_domain (ImageReduced, Rectangle8, ImageReduced1)</l>
<l>* gray_features (Rectangle8, ImageReduced1, 'mean', Value)</l>
<l>* standardGrayValue := 140.0</l>
<l>* scaleFacotr := standardGrayValue / Value</l>
<l>* scale_image (Image, Image, scaleFacotr, 0)</l>
<c></c>
<l>ROW1_1 := 2684 - rowModel</l>
<l>COL1_1 := 4804 - colModel</l>
<l>RAD1_1 := rad(180)</l>
<l>LEN1_1 := 200</l>
<l>LEN2_1 := 350</l>
<c></c>
<l>ROW1_2 := 4380 - rowModel</l>
<l>COL1_2 := 4804 - colModel</l>
<l>RAD1_2 := rad(180)</l>
<l>LEN1_2 := 200</l>
<l>LEN2_2 := 350</l>
<c></c>
<l>baseRightRow := [ROW1_1, ROW1_2]</l>
<l>baseRightColum := [COL1_1,COL1_2]</l>
<l>baseRightRadian := [RAD1_1, RAD1_2]</l>
<l>baseRightLen1 := [LEN1_1, LEN1_2]</l>
<l>baseRightLen2 := [LEN2_1, LEN2_2]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, MovementImageToImage, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<l>gen_rectangle2 (Rectangle1, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<l>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, numSubRects, [threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, kernelWidth, longestOnly, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>FindLineGradiant (Image, findLineRegion, lineRegion, baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, numSubRects, 0.2, 'negative', [threshValue,threshValue], 2, 'first', XsUsed, YsUsed, XsIgnored, YsIgnored, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase)</l>
<c></c>
<c>* find top base line</c>
<l>ROW_1 := 162.42300000 - rowModel</l>
<l>COL_1 := 3050 - colModel</l>
<l>RAD_1 := rad(-90.00000000)</l>
<l>LEN1_1:= 100</l>
<l>LEN2_1:= 200</l>
<c></c>
<l>ROW_2 := 162.42300000 - rowModel</l>
<l>COL_2 := 3694 - colModel</l>
<l>RAD_2 := rad(-90.00000000)</l>
<l>LEN1_2:= 100</l>
<l>LEN2_2:= 100</l>
<c></c>
<l>ROW_3 := 162.42300000 - rowModel</l>
<l>COL_3 := 4310 - colModel</l>
<l>RAD_3 := rad(-90.00000000)</l>
<l>LEN1_3:= 100</l>
<l>LEN2_3:= 100</l>
<c></c>
<l>baseTopRow := [ROW_1, ROW_2, ROW_3]</l>
<l>baseTopColumn := [COL_1, COL_2, COL_3]</l>
<l>baseTopRadian := [RAD_1, RAD_2, RAD_3]</l>
<l>baseTopLen1 := [LEN1_1, LEN1_2, LEN1_3]</l>
<l>baseTopLen2 := [LEN2_1, LEN2_2, LEN2_3]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, MovementImageToImage, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<l>FindLineGradiant (Image, findLineRegion, lineRegion, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, numSubRects, 0.2, 'negative', [threshValue,threshValue,threshValue], 2, 'first', XsUsed, YsUsed, XsIgnored, YsIgnored, lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase)</l>
<c></c>
<c></c>
<c>* make origin</c>
<l>intersection_lines (lineY1RightBase, lineX1RightBase, lineY2RightBase, lineX2RightBase, lineY1TopBase, lineX1TopBase, lineY2TopBase, lineX2TopBase, rowOrigin, colOrigin, IsOverlapping)</l>
<c></c>
<c></c>
<c>*rectify bases</c>
<l>* get_perpendicular_line_that_passes (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colOrigin, rowOrigin, ptXOnPerpenducularDir, ptYOnPerpenducularDir)</l>
<l>* lineX1RightBase := colOrigin</l>
<l>* lineY1RightBase := rowOrigin</l>
<l>* lineX2RightBase := ptXOnPerpenducularDir</l>
<l>* lineY2RightBase := ptYOnPerpenducularDir</l>
<c></c>
<l>SortLineLeftRight (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, XLeft, YLeft, XRight, YRight)</l>
<l>SortLineUpDown (lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, XUp, YUp, XDown, YDown)</l>
<l>GetChangeOfBase (XRight, YRight, XLeft, YLeft, XUp, YUp, XDown, YDown, ChangeOfBase, ChangeOfBaseInv, RotationMat, RotationMatInv)</l>
<l>return ()</l>
</body>
<docu id="I94TopViewChangeBase">
<parameters>
<parameter id="ChangeOfBase"/>
<parameter id="ChangeOfBaseInv"/>
<parameter id="Image"/>
<parameter id="ImageUndistorted"/>
<parameter id="MapToImage"/>
<parameter id="MapToWorld"/>
<parameter id="ModelHandle"/>
<parameter id="RotationMat"/>
<parameter id="RotationMatInv"/>
<parameter id="lineX1RightBase"/>
<parameter id="lineX1TopBase"/>
<parameter id="lineX2RightBase"/>
<parameter id="lineX2TopBase"/>
<parameter id="lineY1RightBase"/>
<parameter id="lineY1TopBase"/>
<parameter id="lineY2RightBase"/>
<parameter id="lineY2TopBase"/>
</parameters>
</docu>
</procedure>
<procedure name="FindLineGradiant">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRegion" base_type="iconic" dimension="0"/>
<par name="lineRegion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="numSubRects" base_type="ctrl" dimension="0"/>
<par name="ignoreFraction" base_type="ctrl" dimension="0"/>
<par name="transition" base_type="ctrl" dimension="0"/>
<par name="threshold" base_type="ctrl" dimension="0"/>
<par name="sigma1" base_type="ctrl" dimension="0"/>
<par name="firstOrLast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XsUsed" base_type="ctrl" dimension="0"/>
<par name="YsUsed" base_type="ctrl" dimension="0"/>
<par name="XsIgnored" base_type="ctrl" dimension="0"/>
<par name="YsIgnored" base_type="ctrl" dimension="0"/>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_image_size (inputImage, imageWidth, imageHeight)</l>
<l>EdgesX := []</l>
<l>EdgesY := []</l>
<c></c>
<c></c>
<l>gen_empty_obj (findLineRegions)</l>
<c></c>
<l>for i:= 0 to |row|-1 by 1</l>
<l>    VisionProStyleFindLine (inputImage, findLineRegion, transition, row[i], col[i], radian[i], len1[i], len2[i], numSubRects, threshold[i], sigma1, firstOrLast, 'false', 'first', 0, 100, Xs, Ys)</l>
<c></c>
<c>   </c>
<l>        EdgesX := [EdgesX, Xs]</l>
<l>        EdgesY := [EdgesY, Ys]</l>
<l>        concat_obj (findLineRegions, findLineRegion, findLineRegions)</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>    FitLine2D (EdgesX, EdgesY,ignoreFraction, lineX1, lineY1, lineX2, lineY2, XsUsed, YsUsed, XsIgnored, YsIgnored)</l>
<l>    findLineRegion := findLineRegions</l>
<c></c>
<c></c>
<l>GenLineRegion (lineRegion, lineX1, lineY1, lineX2, lineY2, imageWidth, imageHeight)</l>
<c></c>
<l>XsUsed := Xs</l>
<l>YsUsed := Ys</l>
<l>return ()</l>
</body>
<docu id="FindLineGradiant">
<parameters>
<parameter id="XsIgnored"/>
<parameter id="XsUsed"/>
<parameter id="YsIgnored"/>
<parameter id="YsUsed"/>
<parameter id="col"/>
<parameter id="findLineRegion"/>
<parameter id="firstOrLast">
<default_value>'first'</default_value>
<sem_type>string</sem_type>
</parameter>
<parameter id="ignoreFraction">
<default_value>0.2</default_value>
<sem_type>real</sem_type>
</parameter>
<parameter id="inputImage"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="lineRegion"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="numSubRects">
<default_value>10</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="radian"/>
<parameter id="row"/>
<parameter id="sigma1">
<default_value>2</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="threshold">
<default_value>20</default_value>
<sem_type>integer</sem_type>
</parameter>
<parameter id="transition">
<default_value>'positive'</default_value>
<sem_type>string</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="GetEdgesInSubRect2">
<interface>
<io>
<par name="inputImage" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="findLineRegion" base_type="iconic" dimension="0"/>
<par name="Edges" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="lineX1" base_type="ctrl" dimension="0"/>
<par name="lineY1" base_type="ctrl" dimension="0"/>
<par name="lineX2" base_type="ctrl" dimension="0"/>
<par name="lineY2" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="newWidth" base_type="ctrl" dimension="0"/>
<par name="sigma" base_type="ctrl" dimension="0"/>
<par name="cannyLow" base_type="ctrl" dimension="0"/>
<par name="cannyHigh" base_type="ctrl" dimension="0"/>
<par name="kernelWidth" base_type="ctrl" dimension="0"/>
<par name="longestOnly" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>lineCenterX := (lineX1 + lineX2) / 2.0</l>
<l>lineCenterY := (lineY1 + lineY2) / 2.0</l>
<l>line_orientation (lineY1, lineX1, lineY2, lineX2, Phi)</l>
<l>xDirOld := cos(radian)</l>
<l>yDirOld := sin(radian)</l>
<c></c>
<l>xDirNew := cos(Phi + rad(90))</l>
<l>yDirNew := sin(Phi + rad(90))</l>
<c></c>
<l>if((xDirOld * xDirNew + yDirOld * yDirNew)&lt;0)</l>
<l>    yDirNew := -yDirNew</l>
<l>    xDirNew := -xDirNew</l>
<l>endif</l>
<c></c>
<l>newRadian := atan2(yDirNew, xDirNew)</l>
<c></c>
<l>distance_pp (lineY1, lineX1, lineY2, lineX2, newHeight)</l>
<c></c>
<l>if(kernelWidth &gt; 0)</l>
<c></c>
<l>    MeanImageIAndFineEdges (inputImage, Edges, lineCenterY, lineCenterX, newRadian, newWidth, newHeight / 2, cannyHigh, cannyLow, sigma, kernelWidth)</l>
<l>    gen_rectangle2 (findLineRegion, lineCenterY, lineCenterX, newRadian, newWidth, newHeight/2)</l>
<c></c>
<l>else</l>
<l>    gen_rectangle2 (findLineRegion, lineCenterY, lineCenterX, newRadian, newWidth, newHeight/2)</l>
<l>reduce_domain (inputImage, findLineRegion, ImageReduced)</l>
<l>edges_sub_pix(ImageReduced, Edges, 'canny', sigma, cannyLow, cannyHigh)</l>
<c></c>
<l>endif</l>
<c></c>
<l>if(longestOnly == 'true')</l>
<l>    LongestXLD (Edges, Edges, contourLength)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetEdgesInSubRect2">
<parameters>
<parameter id="Edges"/>
<parameter id="cannyHigh"/>
<parameter id="cannyLow"/>
<parameter id="findLineRegion"/>
<parameter id="inputImage"/>
<parameter id="kernelWidth"/>
<parameter id="lineX1"/>
<parameter id="lineX2"/>
<parameter id="lineY1"/>
<parameter id="lineY2"/>
<parameter id="longestOnly"/>
<parameter id="newWidth"/>
<parameter id="radian"/>
<parameter id="sigma"/>
</parameters>
</docu>
</procedure>
<procedure name="ImageLineIntersections">
<interface>
<ic>
<par name="m" base_type="ctrl" dimension="0"/>
<par name="b" base_type="ctrl" dimension="0"/>
<par name="imageWidth" base_type="ctrl" dimension="0"/>
<par name="imageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="xStart" base_type="ctrl" dimension="0"/>
<par name="yStart" base_type="ctrl" dimension="0"/>
<par name="xEnd" base_type="ctrl" dimension="0"/>
<par name="yEnd" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>_search_boundary ('null', m, b, imageWidth, imageHeight, result, xStart, yStart)</l>
<l>allBoundaries := ['left','right','up','down']</l>
<l>for Index := 0 to |allBoundaries|-1 by 1</l>
<l>    if(allBoundaries[Index] == result)</l>
<l>        tuple_remove (allBoundaries, Index, boundariesLeft)</l>
<l>    endif</l>
<l>endfor</l>
<l>_search_boundary (boundariesLeft, m, b, imageWidth, imageHeight, result, xEnd, yEnd)</l>
<l>return ()</l>
</body>
<docu id="ImageLineIntersections">
<parameters>
<parameter id="b"/>
<parameter id="imageHeight"/>
<parameter id="imageWidth"/>
<parameter id="m"/>
<parameter id="xEnd"/>
<parameter id="xStart"/>
<parameter id="yEnd"/>
<parameter id="yStart"/>
</parameters>
</docu>
</procedure>
<procedure name="swap">
<interface>
<ic>
<par name="a" base_type="ctrl" dimension="0"/>
<par name="b" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="newA" base_type="ctrl" dimension="0"/>
<par name="newB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>newA := b</l>
<l>newB := a</l>
<c></c>
<l>return ()</l>
</body>
<docu id="swap">
<parameters>
<parameter id="a"/>
<parameter id="b"/>
<parameter id="newA"/>
<parameter id="newB"/>
</parameters>
</docu>
</procedure>
<procedure name="GetI94TopViewBaseRectsNoRectify">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ModelHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="baseTopRow" base_type="ctrl" dimension="0"/>
<par name="baseTopColumn" base_type="ctrl" dimension="0"/>
<par name="baseTopRadian" base_type="ctrl" dimension="0"/>
<par name="baseTopLen1" base_type="ctrl" dimension="0"/>
<par name="baseTopLen2" base_type="ctrl" dimension="0"/>
<par name="baseRightRow" base_type="ctrl" dimension="0"/>
<par name="baseRightColumn" base_type="ctrl" dimension="0"/>
<par name="baseRightRadian" base_type="ctrl" dimension="0"/>
<par name="baseRightLen1" base_type="ctrl" dimension="0"/>
<par name="baseRightLen2" base_type="ctrl" dimension="0"/>
<par name="MapToWorld" base_type="ctrl" dimension="0"/>
<par name="MapToImage" base_type="ctrl" dimension="0"/>
<par name="CameraParameters" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CameraParameters := ['area_scan_telecentric_division',0.588471,3.42746,4.4974e-006,4.5e-006,2556.48,2560.7,5120,5120]</l>
<l>CameraPose := [0.00180843,-0.000646214,0.000999199,0.316458,2.27204,180.151,0]</l>
<l>ImageUndistorted := Image</l>
<c></c>
<l>GenCalibrationMaps (Image, CameraParameters, CameraPose, MapToWorld, MapToImage)</l>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<l>numSubRects := 10</l>
<c></c>
<l>ModelThreshold := 160</l>
<l>threshValue := 20</l>
<l>ignorePortion := 0.2</l>
<l>sigma1 := 1</l>
<l>sigma2 := 1</l>
<l>cannyHigh := 40</l>
<l>cannyLow := 20</l>
<l>newWidth := 5</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* find model front light</c>
<l>* Threshold := 128</l>
<c></c>
<l>* gen_rectangle1 (ROI_0, 53.9, 1940.83, 2000, 3900)</l>
<l>* reduce_domain (Image, ROI_0, ImageReduced)</l>
<l>* binary_threshold (ImageReduced, Region, 'max_separability', 'light', UsedThreshold)</l>
<l>* connection (Region, ConnectedRegions)</l>
<l>* select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 800000, 99999999)</l>
<l>* paint_region (SelectedRegions, ImageReduced, ImageResult, 255, 'fill')</l>
<c></c>
<c></c>
<c>* find model back light</c>
<l>gen_rectangle1 (ROI_0, 79.5, 1762.7, 2185.1, 4943.5)</l>
<l>reduce_domain (Image, ROI_0, ImageResult)</l>
<c></c>
<c></c>
<c></c>
<l>rowModel := 1171.5</l>
<l>colModel := 3678.5</l>
<l>find_shape_model (ImageResult, ModelHandle, -0.39, 0.79, 0.3, 1, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, MovementImageToImage)</l>
<c></c>
<c>* image normalization</c>
<l>* ROW_1 := 1972 - rowModel</l>
<l>* COL_1 := 4257- colModel</l>
<l>* RAD_1 := 0</l>
<l>* LEN_1 := 150</l>
<l>* LEN_2 := 150</l>
<c></c>
<c>* AffineTransRect2 (ROW_1, COL_1, RAD_1, LEN_1, LEN_2, MovementImageToImage, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</c>
<l>* gen_rectangle2 (Rectangle8, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>* reduce_domain (ImageReduced, Rectangle8, ImageReduced1)</l>
<l>* gray_features (Rectangle8, ImageReduced1, 'mean', Value)</l>
<l>* standardGrayValue := 140.0</l>
<l>* scaleFacotr := standardGrayValue / Value</l>
<l>* scale_image (Image, Image, scaleFacotr, 0)</l>
<c></c>
<l>ROW1_1 := 2684 - rowModel</l>
<l>COL1_1 := 4804 - colModel</l>
<l>RAD1_1 := rad(180)</l>
<l>LEN1_1 := 200.0</l>
<l>LEN2_1 := 350.0</l>
<c></c>
<l>ROW1_2 := 4380 - rowModel</l>
<l>COL1_2 := 4804 - colModel</l>
<l>RAD1_2 := rad(180)</l>
<l>LEN1_2 := 200.0</l>
<l>LEN2_2 := 350.0</l>
<c></c>
<l>baseRightRow := [ROW1_1, ROW1_2]</l>
<l>baseRightColumn := [COL1_1,COL1_2]</l>
<l>baseRightRadian := [RAD1_1, RAD1_2]</l>
<l>baseRightLen1 := [LEN1_1, LEN1_2]</l>
<l>baseRightLen2 := [LEN2_1, LEN2_2]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseRightRow, baseRightColumn, baseRightRadian, baseRightLen1, baseRightLen2, MovementImageToImage, baseRightRow, baseRightColumn, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<c>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, numSubRects, [threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, XsUsed, YsUsed, XsIgnored, YsIgnored)</c>
<c></c>
<c>* find top base line</c>
<l>ROW_1 := 162.42300000 - rowModel</l>
<l>COL_1 := 3050 - colModel</l>
<l>RAD_1 := rad(-90.00000000)</l>
<l>LEN1_1 := 100.0</l>
<l>LEN2_1 := 200.0</l>
<c></c>
<l>ROW_2 := 162.42300000 - rowModel</l>
<l>COL_2 := 3694 - colModel</l>
<l>RAD_2 := rad(-90.00000000)</l>
<l>LEN1_2 := 100.0</l>
<l>LEN2_2 := 100.0</l>
<c></c>
<l>ROW_3 := 162.42300000 - rowModel</l>
<l>COL_3 := 4310 - colModel</l>
<l>RAD_3 := rad(-90.00000000)</l>
<l>LEN1_3 := 100.0</l>
<l>LEN2_3 := 100.0</l>
<c></c>
<l>baseTopRow := [ROW_1, ROW_2, ROW_3]</l>
<l>baseTopColumn := [COL_1, COL_2, COL_3]</l>
<l>baseTopRadian := [RAD_1, RAD_2, RAD_3]</l>
<l>baseTopLen1 := [LEN1_1, LEN1_2, LEN1_3]</l>
<l>baseTopLen2 := [LEN2_1, LEN2_2, LEN2_3]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, MovementImageToImage, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<c></c>
<c></c>
<c>* make origin</c>
<c></c>
<c></c>
<c>* rectify bases</c>
<c>* get_perpendicular_line_that_passes (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colOrigin, rowOrigin, ptXOnPerpenducularDir, ptYOnPerpenducularDir)</c>
<l>* lineX1RightBase := colOrigin</l>
<l>* lineY1RightBase := rowOrigin</l>
<l>* lineX2RightBase := ptXOnPerpenducularDir</l>
<l>* lineY2RightBase := ptYOnPerpenducularDir</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetI94TopViewBaseRectsNoRectify">
<parameters>
<parameter id="CameraParameters"/>
<parameter id="Image"/>
<parameter id="MapToImage"/>
<parameter id="MapToWorld"/>
<parameter id="ModelHandle"/>
<parameter id="baseRightColumn"/>
<parameter id="baseRightLen1"/>
<parameter id="baseRightLen2"/>
<parameter id="baseRightRadian"/>
<parameter id="baseRightRow"/>
<parameter id="baseTopColumn"/>
<parameter id="baseTopLen1"/>
<parameter id="baseTopLen2"/>
<parameter id="baseTopRadian"/>
<parameter id="baseTopRow"/>
</parameters>
</docu>
</procedure>
<procedure name="MeanImageIAndFineEdges">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Edges" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
<par name="cannyHigh" base_type="ctrl" dimension="0"/>
<par name="cannyLow" base_type="ctrl" dimension="0"/>
<par name="sigma2" base_type="ctrl" dimension="0"/>
<par name="kernelWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>padding := kernelWidth + 5</l>
<l>len1Padded := len1 + padding</l>
<l>len2Padded := len2 + padding</l>
<c></c>
<l>gen_rectangle2 (ROI_0, row, col, radian, len1Padded, len2Padded)</l>
<l>reduce_domain (Image, ROI_0, ImageReduced)</l>
<c></c>
<c></c>
<l>epslon := 5</l>
<l>degreeAbs := abs(deg(radian))</l>
<l>isHorizontal := abs(degreeAbs-90) &lt; epslon</l>
<l>isVertical := abs(degreeAbs-180) &lt; epslon or degreeAbs &lt; epslon</l>
<c></c>
<c>* do not transform if the region is originally vertical or horizontal</c>
<l>* if(isHorizontal or isVertical)</l>
<c>    </c>
<l>*     if(isHorizontal)</l>
<l>*         kernelWidth := kernelWidth</l>
<l>*         kernelHeight := 1</l>
<l>*     else</l>
<l>*         kernelHeight := kernelWidth</l>
<l>*         kernelWidth := 1</l>
<l>*     endif</l>
<l>*     mean_image (ImageReduced, ImageMean, kernelWidth, kernelHeight)</l>
<c>    </c>
<l>*     edges_sub_pix (ImageMean, Edges, 'canny', sigma2, cannyLow, cannyHigh)</l>
<c></c>
<l>* else</l>
<l>    vector_angle_to_rigid (row, col, radian, len1Padded, len2Padded, rad(-90), HomMat2D)</l>
<l>    affine_trans_image (ImageReduced, ImageAffineTrans, HomMat2D, 'bilinear', 'false')</l>
<c>    </c>
<l>    gen_rectangle2 (Rectangle, len1Padded, len2Padded, rad(90), len1Padded, len2Padded)</l>
<l>    reduce_domain (ImageAffineTrans, Rectangle, ImageReduced1)</l>
<c>    </c>
<l>    mean_image (ImageReduced1, ImageMean, kernelWidth, 1)</l>
<c></c>
<c>    </c>
<l>    edges_sub_pix (ImageMean, Edges, 'canny', sigma2, cannyLow, cannyHigh)</l>
<c>    </c>
<l>    col1Clip := padding</l>
<l>    row1Clip := padding</l>
<l>    col2Clip := padding + len2 *2</l>
<l>    row2Clip := padding + len1 *2</l>
<l>    gen_rectangle1 (Rectangle1, row1Clip, col1Clip, row2Clip, col2Clip)</l>
<l>    clip_contours_xld (Edges, ClippedContours, row1Clip, col1Clip, row2Clip, col2Clip)</l>
<c>    </c>
<l>    vector_angle_to_rigid (len1Padded, len2Padded, rad(-90), row, col, radian, HomMatInv)</l>
<c>    </c>
<l>    affine_trans_contour_xld (ClippedContours, Edges, HomMatInv)</l>
<c>    </c>
<l>* endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="MeanImageIAndFineEdges">
<parameters>
<parameter id="Edges"/>
<parameter id="Image"/>
<parameter id="cannyHigh"/>
<parameter id="cannyLow"/>
<parameter id="col"/>
<parameter id="kernelWidth"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="radian"/>
<parameter id="row"/>
<parameter id="sigma2"/>
</parameters>
</docu>
</procedure>
<procedure name="GetI94BottomViewBaseRectsNoRectify">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ModelHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="baseTopRow" base_type="ctrl" dimension="0"/>
<par name="baseTopCol" base_type="ctrl" dimension="0"/>
<par name="baseTopRadian" base_type="ctrl" dimension="0"/>
<par name="baseTopLen1" base_type="ctrl" dimension="0"/>
<par name="baseTopLen2" base_type="ctrl" dimension="0"/>
<par name="baseLeftRow" base_type="ctrl" dimension="0"/>
<par name="baseLeftCol" base_type="ctrl" dimension="0"/>
<par name="baseLeftRadian" base_type="ctrl" dimension="0"/>
<par name="baseLeftLen1" base_type="ctrl" dimension="0"/>
<par name="baseLeftLen2" base_type="ctrl" dimension="0"/>
<par name="MapToWorld" base_type="ctrl" dimension="0"/>
<par name="MapToImage" base_type="ctrl" dimension="0"/>
<par name="CameraParameters" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CameraParameters := ['area_scan_telecentric_division',0.579268,-3.64444,4.49772e-006,4.5e-006,2440.35,3083.74,5120,5120]</l>
<l>CameraPose := [0.000303946,-0.0050309,0.000999219,0.0906952,357.737,89.8488,0]</l>
<c></c>
<l>ImageUndistorted := Image</l>
<l>GenCalibrationMaps (Image, CameraParameters, CameraPose, MapToWorld, MapToImage)</l>
<c></c>
<c></c>
<l>modelRow := 1166.78</l>
<l>modelCol := 2205</l>
<c></c>
<l>find_shape_model (Image, ModelHandle, -0.39, 0.79, 0.2, 1, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, MovementOfItem)</l>
<c></c>
<l>sigma2 := 5</l>
<c></c>
<c>* Find top base line</c>
<l>row1TopBase := 137.0 - modelRow</l>
<l>col1TopBase := 2217.0 - modelCol</l>
<l>radianTopBase := rad(-91.0)</l>
<l>len1TopBase := 187.0</l>
<l>len2TopBase := 107.0</l>
<c></c>
<l>row1TopBase1 := 137.0 - modelRow</l>
<l>col1TopBase1 := 1628.0 - modelCol</l>
<l>radianTopBase1 := rad(-91.0)</l>
<l>len1TopBase1 := 187.0</l>
<l>len2TopBase1 := 107.0</l>
<c></c>
<l>row1TopBase2 := 137.0 - modelRow</l>
<l>col1TopBase2 := 2876.0 - modelCol</l>
<l>radianTopBase2 := rad(-91.0)</l>
<l>len1TopBase2 := 187.0</l>
<l>len2TopBase2 := 160.0</l>
<c></c>
<l>row1TopBase := [row1TopBase, row1TopBase1, row1TopBase2]</l>
<l>col1TopBase := [col1TopBase, col1TopBase1, col1TopBase2]</l>
<l>radianTopBase := [radianTopBase, radianTopBase1, radianTopBase2]</l>
<l>len1TopBase := [len1TopBase, len1TopBase1, len1TopBase2]</l>
<l>len2TopBase := [len2TopBase, len2TopBase1,len2TopBase2]</l>
<c></c>
<l>AffineTransRect2 (row1TopBase, col1TopBase, radianTopBase, len1TopBase, len2TopBase, MovementOfItem, baseTopRow, baseTopCol, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* Find left base line</c>
<l>row1LeftBase := 2607.0 - modelRow</l>
<l>col1LeftBase := 995.0 - modelCol</l>
<l>radianLeftBase := rad(-1.0)</l>
<l>len1LeftBase := 150.0</l>
<l>len2LeftBase := 281.0</l>
<c></c>
<l>row1LeftBase1 := 4216.0 - modelRow</l>
<l>col1LeftBase1 := 995.0 - modelCol</l>
<l>radianLeftBase1 := rad(-1.0)</l>
<l>len1LeftBase1 := 150.0</l>
<l>len2LeftBase1 := 281.0</l>
<c></c>
<l>row1LeftBase := [row1LeftBase, row1LeftBase1]</l>
<l>col1LeftBase := [col1LeftBase, col1LeftBase1]</l>
<l>radianLeftBase := [radianLeftBase, radianLeftBase1]</l>
<l>len1LeftBase := [len1LeftBase, len1LeftBase1]</l>
<l>len2LeftBase := [len2LeftBase, len2LeftBase1]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (row1LeftBase, col1LeftBase, radianLeftBase, len1LeftBase, len2LeftBase, MovementOfItem, baseLeftRow, baseLeftCol, baseLeftRadian, baseLeftLen1, baseLeftLen2)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetI94BottomViewBaseRectsNoRectify">
<parameters>
<parameter id="CameraParameters"/>
<parameter id="Image"/>
<parameter id="MapToImage"/>
<parameter id="MapToWorld"/>
<parameter id="ModelHandle"/>
<parameter id="baseLeftCol"/>
<parameter id="baseLeftLen1"/>
<parameter id="baseLeftLen2"/>
<parameter id="baseLeftRadian"/>
<parameter id="baseLeftRow"/>
<parameter id="baseTopCol"/>
<parameter id="baseTopLen1"/>
<parameter id="baseTopLen2"/>
<parameter id="baseTopRadian"/>
<parameter id="baseTopRow"/>
</parameters>
</docu>
</procedure>
<procedure name="I94FindLeftCircle">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ContourCircle" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="centerXImageAbs" base_type="ctrl" dimension="0"/>
<par name="centerYImageAbs" base_type="ctrl" dimension="0"/>
<par name="radiusPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>gen_rectangle2 (ROI_0, row, col, radian, len1, len2)</l>
<c></c>
<l>reduce_domain (Image, ROI_0, ImageReduced1)</l>
<l>edges_sub_pix (ImageReduced1, Edges2, 'canny', 3, 15, 30)</l>
<c></c>
<l>select_contours_xld (Edges2, SelectedContours, 'contour_length', 200, 999999, -0.5, 0.5)</l>
<l>union_cocircular_contours_xld (SelectedContours, UnionContours, rad(180), rad(5), rad(180), 2000, 10, 50, 'true', 3)</l>
<c></c>
<l>LongestXLD (UnionContours, outputContour, contourLength)</l>
<l>fit_circle_contour_xld (outputContour, 'algebraic', -1, 0, 0, 3, 2, centerYImageAbs, centerXImageAbs, radiusPixel, StartPhi, EndPhi, PointOrder)</l>
<l>gen_circle_contour_xld (ContourCircle, centerYImageAbs, centerXImageAbs, radiusPixel, 0, rad(360), 'positive', 1)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="I94FindLeftCircle">
<parameters>
<parameter id="ContourCircle"/>
<parameter id="Image"/>
<parameter id="centerXImageAbs"/>
<parameter id="centerYImageAbs"/>
<parameter id="col"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="radian"/>
<parameter id="radiusPixel"/>
<parameter id="row"/>
</parameters>
</docu>
</procedure>
<procedure name="I94FindRightCircle">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ContourCircle" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="row" base_type="ctrl" dimension="0"/>
<par name="col" base_type="ctrl" dimension="0"/>
<par name="radian" base_type="ctrl" dimension="0"/>
<par name="len1" base_type="ctrl" dimension="0"/>
<par name="len2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="centerXImageAbs" base_type="ctrl" dimension="0"/>
<par name="centerYImageAbs" base_type="ctrl" dimension="0"/>
<par name="radiusPixel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>gen_rectangle2 (ROI_0, row, col, radian, len1, len2)</l>
<l>reduce_domain (Image, ROI_0, ImageReduced)</l>
<l>threshold (ImageReduced, Region, 100, 255)</l>
<l>connection (Region, ConnectedRegions)</l>
<c></c>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 800000, 1200000)</l>
<l>dilation_circle (SelectedRegions, RegionDilation, 35)</l>
<c></c>
<l>reduce_domain (Image, RegionDilation, image_intersection)</l>
<l>edges_sub_pix (image_intersection, Edges, 'canny', 1, 10, 20)</l>
<c></c>
<l>union_adjacent_contours_xld (Edges, UnionContours2, 1000, 1000, 'attr_keep')</l>
<l>LongestXLD (UnionContours2, SelectedXLD, contourLength5)</l>
<l>smallest_circle_xld (SelectedXLD, centerYImageAbs, centerXImageAbs, radiusPixel)</l>
<l>* fit_circle_contour_xld (SelectedXLD, 'algebraic', -1, 0, 0, 3, 2, rowRightCircle, colRightCircle, radRightCircle, StartPhi1, EndPhi1, PointOrder1)</l>
<l>gen_circle_contour_xld (ContourCircle, centerYImageAbs, centerXImageAbs, radiusPixel, 0, rad(360), 'positive', 1)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="I94FindRightCircle">
<parameters>
<parameter id="ContourCircle"/>
<parameter id="Image"/>
<parameter id="centerXImageAbs"/>
<parameter id="centerYImageAbs"/>
<parameter id="col"/>
<parameter id="len1"/>
<parameter id="len2"/>
<parameter id="radian"/>
<parameter id="radiusPixel"/>
<parameter id="row"/>
</parameters>
</docu>
</procedure>
<procedure name="GetI94TopViewBaseRects">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageUndistorted" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="baseTopRow" base_type="ctrl" dimension="0"/>
<par name="baseTopColumn" base_type="ctrl" dimension="0"/>
<par name="baseTopRadian" base_type="ctrl" dimension="0"/>
<par name="baseTopLen1" base_type="ctrl" dimension="0"/>
<par name="baseTopLen2" base_type="ctrl" dimension="0"/>
<par name="baseRightRow" base_type="ctrl" dimension="0"/>
<par name="baseRightColumn" base_type="ctrl" dimension="0"/>
<par name="baseRightRadian" base_type="ctrl" dimension="0"/>
<par name="baseRightLen1" base_type="ctrl" dimension="0"/>
<par name="baseRightLen2" base_type="ctrl" dimension="0"/>
<par name="MapToWorld" base_type="ctrl" dimension="0"/>
<par name="MapToImage" base_type="ctrl" dimension="0"/>
<par name="CameraParameters" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CameraParameters := ['area_scan_telecentric_division',0.588471,3.42746,4.4974e-006,4.5e-006,2556.48,2560.7,5120,5120]</l>
<l>CameraPose := [0.00180843,-0.000646214,0.000999199,0.316458,2.27204,180.151,0]</l>
<l>UndistortImage (Image, Image, CameraParameters, OutCameraParams)</l>
<l>ImageUndistorted := Image</l>
<c></c>
<l>GenCalibrationMaps (Image, OutCameraParams, CameraPose, MapToWorld, MapToImage)</l>
<c></c>
<l>get_image_size (Image, Width, Height)</l>
<l>numSubRects := 10</l>
<c></c>
<l>ModelThreshold := 160</l>
<l>threshValue := 20</l>
<l>ignorePortion := 0.2</l>
<l>sigma1 := 1</l>
<l>sigma2 := 1</l>
<l>cannyHigh := 40</l>
<l>cannyLow := 20</l>
<l>newWidth := 5</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* find model front light</c>
<l>* Threshold := 128</l>
<c></c>
<l>* gen_rectangle1 (ROI_0, 53.9, 1940.83, 2000, 3900)</l>
<l>* reduce_domain (Image, ROI_0, ImageReduced)</l>
<l>* binary_threshold (ImageReduced, Region, 'max_separability', 'light', UsedThreshold)</l>
<l>* connection (Region, ConnectedRegions)</l>
<l>* select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 800000, 99999999)</l>
<l>* paint_region (SelectedRegions, ImageReduced, ImageResult, 255, 'fill')</l>
<c></c>
<c></c>
<c>* find model back light</c>
<l>gen_rectangle1 (ROI_0, 79.5, 1762.7, 2185.1, 4943.5)</l>
<l>reduce_domain (Image, ROI_0, ImageResult)</l>
<c></c>
<c></c>
<c></c>
<l>rowModel := 1171.5</l>
<l>colModel := 3678.5</l>
<l>find_shape_model (ImageResult, ModelHandle, -0.39, 0.79, 0.3, 1, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, MovementImageToImage)</l>
<c></c>
<c>* image normalization</c>
<l>* ROW_1 := 1972 - rowModel</l>
<l>* COL_1 := 4257- colModel</l>
<l>* RAD_1 := 0</l>
<l>* LEN_1 := 150</l>
<l>* LEN_2 := 150</l>
<c></c>
<c>* AffineTransRect2 (ROW_1, COL_1, RAD_1, LEN_1, LEN_2, MovementImageToImage, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</c>
<l>* gen_rectangle2 (Rectangle8, ROW_1, COL_1, RAD_1, LEN_1, LEN_2)</l>
<l>* reduce_domain (ImageReduced, Rectangle8, ImageReduced1)</l>
<l>* gray_features (Rectangle8, ImageReduced1, 'mean', Value)</l>
<l>* standardGrayValue := 140.0</l>
<l>* scaleFacotr := standardGrayValue / Value</l>
<l>* scale_image (Image, Image, scaleFacotr, 0)</l>
<c></c>
<l>ROW1_1 := 2684 - rowModel</l>
<l>COL1_1 := 4804 - colModel</l>
<l>RAD1_1 := rad(180)</l>
<l>LEN1_1 := 200.0</l>
<l>LEN2_1 := 350.0</l>
<c></c>
<l>ROW1_2 := 4380 - rowModel</l>
<l>COL1_2 := 4804 - colModel</l>
<l>RAD1_2 := rad(180)</l>
<l>LEN1_2 := 200.0</l>
<l>LEN2_2 := 350.0</l>
<c></c>
<l>baseRightRow := [ROW1_1, ROW1_2]</l>
<l>baseRightColumn := [COL1_1,COL1_2]</l>
<l>baseRightRadian := [RAD1_1, RAD1_2]</l>
<l>baseRightLen1 := [LEN1_1, LEN1_2]</l>
<l>baseRightLen2 := [LEN2_1, LEN2_2]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseRightRow, baseRightColumn, baseRightRadian, baseRightLen1, baseRightLen2, MovementImageToImage, baseRightRow, baseRightColumn, baseRightRadian, baseRightLen1, baseRightLen2)</l>
<c>* VisionProStyleFindLineOneStep (Image, rect, lineRegion, 'negative', baseRightRow, baseRightColum, baseRightRadian, baseRightLen1, baseRightLen2, numSubRects, [threshValue,threshValue], 'first', ignorePortion, 'true', sigma1, sigma2, Width, Height, newWidth, cannyHigh, cannyLow, lineX1RightBase, lineY1RightBase, lineX2RightBase, lineY2RightBase, XsUsed, YsUsed, XsIgnored, YsIgnored)</c>
<c></c>
<c>* find top base line</c>
<l>ROW_1 := 162.42300000 - rowModel</l>
<l>COL_1 := 3050 - colModel</l>
<l>RAD_1 := rad(-90.00000000)</l>
<l>LEN1_1 := 100.0</l>
<l>LEN2_1 := 200.0</l>
<c></c>
<l>ROW_2 := 162.42300000 - rowModel</l>
<l>COL_2 := 3694 - colModel</l>
<l>RAD_2 := rad(-90.00000000)</l>
<l>LEN1_2 := 100.0</l>
<l>LEN2_2 := 100.0</l>
<c></c>
<l>ROW_3 := 162.42300000 - rowModel</l>
<l>COL_3 := 4310 - colModel</l>
<l>RAD_3 := rad(-90.00000000)</l>
<l>LEN1_3 := 100.0</l>
<l>LEN2_3 := 100.0</l>
<c></c>
<l>baseTopRow := [ROW_1, ROW_2, ROW_3]</l>
<l>baseTopColumn := [COL_1, COL_2, COL_3]</l>
<l>baseTopRadian := [RAD_1, RAD_2, RAD_3]</l>
<l>baseTopLen1 := [LEN1_1, LEN1_2, LEN1_3]</l>
<l>baseTopLen2 := [LEN2_1, LEN2_2, LEN2_3]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2, MovementImageToImage, baseTopRow, baseTopColumn, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<c></c>
<c></c>
<c>* make origin</c>
<c></c>
<c></c>
<c>* rectify bases</c>
<c>* get_perpendicular_line_that_passes (lineX1TopBase, lineY1TopBase, lineX2TopBase, lineY2TopBase, colOrigin, rowOrigin, ptXOnPerpenducularDir, ptYOnPerpenducularDir)</c>
<l>* lineX1RightBase := colOrigin</l>
<l>* lineY1RightBase := rowOrigin</l>
<l>* lineX2RightBase := ptXOnPerpenducularDir</l>
<l>* lineY2RightBase := ptYOnPerpenducularDir</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetI94TopViewBaseRects">
<parameters>
<parameter id="CameraParameters"/>
<parameter id="Image"/>
<parameter id="ImageUndistorted"/>
<parameter id="MapToImage"/>
<parameter id="MapToWorld"/>
<parameter id="ModelHandle"/>
<parameter id="baseRightColumn"/>
<parameter id="baseRightLen1"/>
<parameter id="baseRightLen2"/>
<parameter id="baseRightRadian"/>
<parameter id="baseRightRow"/>
<parameter id="baseTopColumn"/>
<parameter id="baseTopLen1"/>
<parameter id="baseTopLen2"/>
<parameter id="baseTopRadian"/>
<parameter id="baseTopRow"/>
</parameters>
</docu>
</procedure>
<procedure name="GetI94BottomViewBaseRects">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageUndistorted" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ModelHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="baseTopRow" base_type="ctrl" dimension="0"/>
<par name="baseTopCol" base_type="ctrl" dimension="0"/>
<par name="baseTopRadian" base_type="ctrl" dimension="0"/>
<par name="baseTopLen1" base_type="ctrl" dimension="0"/>
<par name="baseTopLen2" base_type="ctrl" dimension="0"/>
<par name="baseLeftRow" base_type="ctrl" dimension="0"/>
<par name="baseLeftCol" base_type="ctrl" dimension="0"/>
<par name="baseLeftRadian" base_type="ctrl" dimension="0"/>
<par name="baseLeftLen1" base_type="ctrl" dimension="0"/>
<par name="baseLeftLen2" base_type="ctrl" dimension="0"/>
<par name="MapToWorld" base_type="ctrl" dimension="0"/>
<par name="MapToImage" base_type="ctrl" dimension="0"/>
<par name="CameraParameters" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>CameraParameters := ['area_scan_telecentric_division',0.579268,-3.64444,4.49772e-006,4.5e-006,2440.35,3083.74,5120,5120]</l>
<l>CameraPose := [0.000303946,-0.0050309,0.000999219,0.0906952,357.737,89.8488,0]</l>
<c></c>
<l>UndistortImage (Image, Image, CameraParameters, OutCameraParams)</l>
<l>ImageUndistorted := Image</l>
<l>GenCalibrationMaps (Image, OutCameraParams, CameraPose, MapToWorld, MapToImage)</l>
<c></c>
<c></c>
<l>modelRow := 1166.78</l>
<l>modelCol := 2205</l>
<c></c>
<l>find_shape_model (Image, ModelHandle, -0.39, 0.79, 0.2, 1, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score)</l>
<l>vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, MovementOfItem)</l>
<c></c>
<l>sigma2 := 5</l>
<c></c>
<c>* Find top base line</c>
<l>row1TopBase := 137.0 - modelRow</l>
<l>col1TopBase := 2217.0 - modelCol</l>
<l>radianTopBase := rad(-91.0)</l>
<l>len1TopBase := 187.0</l>
<l>len2TopBase := 107.0</l>
<c></c>
<l>row1TopBase1 := 137.0 - modelRow</l>
<l>col1TopBase1 := 1628.0 - modelCol</l>
<l>radianTopBase1 := rad(-91.0)</l>
<l>len1TopBase1 := 187.0</l>
<l>len2TopBase1 := 107.0</l>
<c></c>
<l>row1TopBase2 := 137.0 - modelRow</l>
<l>col1TopBase2 := 2876.0 - modelCol</l>
<l>radianTopBase2 := rad(-91.0)</l>
<l>len1TopBase2 := 187.0</l>
<l>len2TopBase2 := 160.0</l>
<c></c>
<l>row1TopBase := [row1TopBase, row1TopBase1, row1TopBase2]</l>
<l>col1TopBase := [col1TopBase, col1TopBase1, col1TopBase2]</l>
<l>radianTopBase := [radianTopBase, radianTopBase1, radianTopBase2]</l>
<l>len1TopBase := [len1TopBase, len1TopBase1, len1TopBase2]</l>
<l>len2TopBase := [len2TopBase, len2TopBase1,len2TopBase2]</l>
<c></c>
<l>AffineTransRect2 (row1TopBase, col1TopBase, radianTopBase, len1TopBase, len2TopBase, MovementOfItem, baseTopRow, baseTopCol, baseTopRadian, baseTopLen1, baseTopLen2)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* Find left base line</c>
<l>row1LeftBase := 2607.0 - modelRow</l>
<l>col1LeftBase := 995.0 - modelCol</l>
<l>radianLeftBase := rad(-1.0)</l>
<l>len1LeftBase := 150.0</l>
<l>len2LeftBase := 281.0</l>
<c></c>
<l>row1LeftBase1 := 4216.0 - modelRow</l>
<l>col1LeftBase1 := 995.0 - modelCol</l>
<l>radianLeftBase1 := rad(-1.0)</l>
<l>len1LeftBase1 := 150.0</l>
<l>len2LeftBase1 := 281.0</l>
<c></c>
<l>row1LeftBase := [row1LeftBase, row1LeftBase1]</l>
<l>col1LeftBase := [col1LeftBase, col1LeftBase1]</l>
<l>radianLeftBase := [radianLeftBase, radianLeftBase1]</l>
<l>len1LeftBase := [len1LeftBase, len1LeftBase1]</l>
<l>len2LeftBase := [len2LeftBase, len2LeftBase1]</l>
<c></c>
<c></c>
<l>AffineTransRect2 (row1LeftBase, col1LeftBase, radianLeftBase, len1LeftBase, len2LeftBase, MovementOfItem, baseLeftRow, baseLeftCol, baseLeftRadian, baseLeftLen1, baseLeftLen2)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="GetI94BottomViewBaseRects">
<parameters>
<parameter id="CameraParameters"/>
<parameter id="Image"/>
<parameter id="ImageUndistorted"/>
<parameter id="MapToImage"/>
<parameter id="MapToWorld"/>
<parameter id="ModelHandle"/>
<parameter id="baseLeftCol"/>
<parameter id="baseLeftLen1"/>
<parameter id="baseLeftLen2"/>
<parameter id="baseLeftRadian"/>
<parameter id="baseLeftRow"/>
<parameter id="baseTopCol"/>
<parameter id="baseTopLen1"/>
<parameter id="baseTopLen2"/>
<parameter id="baseTopRadian"/>
<parameter id="baseTopRow"/>
</parameters>
</docu>
</procedure>
<procedure name="TranslateLine">
<interface>
<ic>
<par name="lineStartX" base_type="ctrl" dimension="0"/>
<par name="lineStartY" base_type="ctrl" dimension="0"/>
<par name="lineEndX" base_type="ctrl" dimension="0"/>
<par name="lineEndY" base_type="ctrl" dimension="0"/>
<par name="distance" base_type="ctrl" dimension="0"/>
<par name="isVertical" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="outLineStartX" base_type="ctrl" dimension="0"/>
<par name="outLineStartY" base_type="ctrl" dimension="0"/>
<par name="outLineEndX" base_type="ctrl" dimension="0"/>
<par name="outLineEndY" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if(isVertical == 'true')</l>
<l>    SortLineUpDown (lineStartX, lineStartY, lineEndX, lineEndY, lineStartX, lineStartY, lineEndX, lineEndY)</l>
<l>elseif (isVertical == 'false')</l>
<l>    SortLineLeftRight (lineStartX, lineStartY, lineEndX, lineEndY, lineStartX, lineStartY, lineEndX, lineEndY)</l>
<l>else</l>
<l>    throw ('Unknow param &lt;isVertical&gt;')</l>
<l>endif</l>
<c></c>
<c></c>
<l>GetParallelLine (lineStartX, lineStartY, lineEndX, lineEndY, distance, outLineStartX, outLineStartY, outLineEndX, outLineEndY)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="TranslateLine">
<parameters>
<parameter id="distance"/>
<parameter id="isVertical"/>
<parameter id="lineEndX"/>
<parameter id="lineEndY"/>
<parameter id="lineStartX"/>
<parameter id="lineStartY"/>
<parameter id="outLineEndX"/>
<parameter id="outLineEndY"/>
<parameter id="outLineStartX"/>
<parameter id="outLineStartY"/>
</parameters>
</docu>
</procedure>
<procedure name="ScaleToByte">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="ROI" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ByteImage" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>  reduce_domain (Image, ROI, ImageReducedB)</l>
<l>    min_max_gray (ROI, ImageReducedB, 0, Min, Max, Range)</l>
<l>    scale_image (ImageReducedB, ImageScaled, 1, -Min)</l>
<l>    scale := 255.0 / Range</l>
<l>    scale_image (ImageScaled, ImageScaled1, scale, 0)</l>
<l>    convert_image_type (ImageScaled1, ByteImage, 'byte')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ScaleToByte">
<parameters>
<parameter id="ByteImage"/>
<parameter id="Image"/>
<parameter id="ROI"/>
</parameters>
</docu>
</procedure>
<procedure name="I40RightScannerAlign">
<interface>
<io>
<par name="ImageRight" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ShapeModelHandel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowCenter" base_type="ctrl" dimension="0"/>
<par name="ColCenter" base_type="ctrl" dimension="0"/>
<par name="RowEnd" base_type="ctrl" dimension="0"/>
<par name="ColEnd" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>find_shape_model (ImageRight,ShapeModelHandel, -0.39, 0.79, 0.3, 1, 0.5, 'least_squares', 0, 0.9, RowMdel, ColumnModel, Angle, Score)</l>
<c></c>
<c>* 获取中央水平线</c>
<l>rowHLine := RowMdel + 140</l>
<l>colHline := ColumnModel</l>
<l>gen_rectangle2 (ROI_HLine, rowHLine, colHline, rad(90), 20.8478, 366.834)</l>
<l>min_max_gray (ROI_HLine, ImageRight, 0, Min, Max, Range)</l>
<l>reduce_domain (ImageRight, ROI_HLine, ImageReduced1)</l>
<c></c>
<l>binary_threshold (ImageReduced1, Region3, 'max_separability', 'light', UsedThreshold)</l>
<c>*如果只是将无效区域分离了, 那就先将无效区域除去再二值化</c>
<l>if(UsedThreshold &lt; 1)</l>
<l>    ScaleToByte (ImageRight, Region3, ByteImage)</l>
<l>    threshold (ByteImage, Region3, 100, 255)</l>
<l>endif</l>
<c></c>
<l>gen_contour_region_xld (Region3, Contours, 'border')</l>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines', 5, 4, 2)</l>
<l>select_contours_xld (ContoursSplit, SelectedContours, 'contour_length', 200, 9999, -0.5, 0.5)</l>
<l>sort_contours_xld (SelectedContours, SortedContours, 'upper_left', 'true', 'row')</l>
<l>select_obj (SortedContours, ObjectSelected, 1)</l>
<l>fit_line_contour_xld (ObjectSelected, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<c></c>
<c>* 以中央水平线为粗基准构建上下ROI</c>
<l>gen_rectangle2 (ROI_0, rowHLine - 150, colHline, rad(-90), 56.3662, 480.108)</l>
<l>gen_rectangle2 (ROI_1, rowHLine + 150, colHline, rad(-90), 56.3662, 363.272)</l>
<c></c>
<l>union2 (ROI_0, ROI_1, RegionUnion)</l>
<l>reduce_domain (ImageRight, RegionUnion, ImageReduced)</l>
<c></c>
<l>threshold (ImageReduced, Region, 0, 2)</l>
<c></c>
<l>area_center (Region, Area, Row, Column)</l>
<l>get_perpendicular_line_that_passes (ColBegin, RowBegin, ColEnd, RowEnd, Column, Row, lineXPerpendicular, lineYPerpendicular)</l>
<l>intersection_lines (Row, Column, lineYPerpendicular, lineXPerpendicular, RowBegin, ColBegin, RowEnd, ColEnd, RowCenter, ColCenter, IsOverlapping)</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="I40RightScannerAlign">
<parameters>
<parameter id="ColCenter"/>
<parameter id="ColEnd"/>
<parameter id="ImageRight"/>
<parameter id="RowCenter"/>
<parameter id="RowEnd"/>
<parameter id="ShapeModelHandel"/>
</parameters>
</docu>
</procedure>
<procedure name="I40AlignAllAndGetBaseLines">
<interface>
<io>
<par name="ImageRight" base_type="iconic" dimension="0"/>
<par name="ImageLeft" base_type="iconic" dimension="0"/>
<par name="ImageBottom" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageLeftAligned" base_type="iconic" dimension="0"/>
<par name="ImageBottomAligned" base_type="iconic" dimension="0"/>
<par name="MultiChannelImageLR" base_type="iconic" dimension="0"/>
<par name="MultiChannelImageBR" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ShapeModelHandel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowBeginB" base_type="ctrl" dimension="0"/>
<par name="ColBeginB" base_type="ctrl" dimension="0"/>
<par name="RowEndB" base_type="ctrl" dimension="0"/>
<par name="ColEndB" base_type="ctrl" dimension="0"/>
<par name="RowBeginC" base_type="ctrl" dimension="0"/>
<par name="ColBeginC" base_type="ctrl" dimension="0"/>
<par name="RowEndC" base_type="ctrl" dimension="0"/>
<par name="ColEndC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_image_size (ImageRight, Width, Height)</l>
<l>mirror_image (ImageLeft, ImageMirror, 'column')</l>
<c></c>
<l>I40LeftScannerAlign (ImageMirror, ShapeModelHandel, RowCenter, ColCenter, RowEnd, ColEnd)</l>
<l>I40RightScannerAlign (ImageRight, ShapeModelHandel, RowFixture, ColFixture, RowEndFixture, ColEndFixture)</l>
<c></c>
<c>* I40RightScannerAlign (ImageRight, ShapeModelHandel, RowFixture, ColFixture)</c>
<c></c>
<l>vector_angle_to_rigid (RowCenter, ColCenter, 0, RowFixture, ColFixture, 0, HomMat2D)</l>
<l>affine_trans_image(ImageMirror, ImageLeftAligned, HomMat2D, 'constant', 'false')</l>
<c></c>
<c></c>
<c></c>
<c>* Find base line in the right view</c>
<c>* 第一条边</c>
<l>RowRectangleB1 := RowFixture-135</l>
<l>gen_rectangle2 (RectangleB1, RowRectangleB1, ColFixture-545, rad(0), 5.68206, 22.1838)</l>
<l>gen_rectangle2 (RectangleB2, 300.057, ColFixture-545, rad(0), 5.68206, 22.4712)</l>
<c></c>
<l>union2 (RectangleB1, RectangleB2, ROIB)</l>
<l>reduce_domain (ImageRight, ROIB, ImageReducedB)</l>
<l>threshold (ImageReducedB, RegionFilter, 1, 99999)</l>
<l>reduce_domain (ImageRight, RegionFilter, ImageReducedB)</l>
<l>min_max_gray (RegionFilter, ImageReducedB, 0, Min, Max, Range)</l>
<l>scale_image (ImageReducedB, ImageScaled, 1, -Min)</l>
<l>binary_threshold (ImageScaled, RegionB, 'max_separability', 'light', UsedThreshold)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>opening_circle (RegionB, RegionOpeningB, 2)</l>
<l>boundary (RegionOpeningB, RegionBorderB, 'inner')</l>
<l>gen_contour_region_xld (RegionBorderB, ContourBs, 'border')</l>
<l>segment_contours_xld (ContourBs, ContourBsSplit, 'lines', 5, 2, 1)</l>
<l>select_contours_xld (ContourBsSplit, SelectedContourBs, 'contour_length', 5, 2000, -0.5, 0.5)</l>
<l>select_contours_xld (SelectedContourBs, SelectedContourBs, 'direction', 1.2, 2, -0.5, 0.5)</l>
<l>union_collinear_contours_ext_xld (SelectedContourBs, UnionContourBs, 10, 10, 10, 0.6, 0, -1, 1, 1, 1, 1, 1, 0, 'attr_keep')</l>
<l>select_contours_xld (UnionContourBs, SelectedContourBs, 'contour_length', 10, 2000, -0.5, 0.5)</l>
<l>sort_contours_xld (SelectedContourBs, SortedContourBs, 'character', 'true', 'column')    </l>
<l>select_obj (SortedContourBs, ObjectSelectedB, [1,2])</l>
<c>*取20%靠右的一点</c>
<l>SelectContoursXValue(ObjectSelectedB, 0.5, X)</l>
<l>Y := RowRectangleB1</l>
<l>get_perpendicular_line_that_passes (ColFixture, RowFixture, ColEndFixture, RowEndFixture, X, Y, ColEndB, RowEndB)</l>
<l>ColBeginB := X</l>
<l>RowBeginB := Y</l>
<c></c>
<l>GenLineRegion (lineRegionB, ColBeginB, RowBeginB, ColEndB, RowEndB, Width, Height)</l>
<l>GenLineRegion (lineRegionBase, ColFixture, RowFixture, ColEndFixture, RowEndFixture, Width, Height)</l>
<c></c>
<c></c>
<c>*生成第二条线</c>
<c></c>
<l>gen_rectangle2 (RectangleC2, RowFixture+257, ColFixture+315, rad(-90), 11.045, 77.7974)</l>
<l>gen_rectangle2 (RectangleC1, RowFixture+257, ColFixture-315, rad(-90), 11.045, 77.7974)</l>
<c></c>
<c></c>
<l>union2 (RectangleC1, RectangleC2, ROIC)</l>
<l>reduce_domain (ImageRight, ROIC, ImageReducedC)</l>
<l>min_max_gray (ROIC, ImageRight, 0, Min, Max, Range)</l>
<l>scale_image (ImageReducedC, ImageScaled, 1, -Min)</l>
<l>scale := 255.0 / Range</l>
<l>scale_image (ImageScaled, ImageScaled1, scale, 0)</l>
<l>convert_image_type (ImageScaled1, ImageConverted1, 'byte')</l>
<c></c>
<l>threshold (ImageConverted1, RegionC, 100, 255)</l>
<c></c>
<c></c>
<l>opening_circle (RegionC, RegionOpeningC, 1)</l>
<l>boundary (RegionOpeningC, RegionBorderC, 'inner')   </l>
<l>gen_contour_region_xld (RegionBorderC, ContourCs, 'border')</l>
<l>segment_contours_xld (ContourCs, ContourCsSplit, 'lines', 5, 1, 1)</l>
<l>select_contours_xld (ContourCsSplit, SelectedContourCs, 'contour_length', 30, 2000, -0.5, 0.5)</l>
<l>union_collinear_contours_ext_xld (SelectedContourCs, UnionContourCs, 200, 1, 4, 0.1, 0, -1, 1, 1, 1, 1, 1, 0, 'attr_keep')</l>
<l>sort_contours_xld (UnionContourCs, SortedContourCs, 'character', 'true', 'row')</l>
<l>select_obj (SortedContourCs, ObjectSelectedC, [3,4])</l>
<l>union_collinear_contours_xld (ObjectSelectedC, UnionContours1, 1000, 20, 20, 0.5, 'attr_keep')</l>
<l>fit_line_contour_xld (UnionContours1, 'tukey', -1, 0, 5, 2, RowBeginC, ColBeginC, RowEndC, ColEndC, NrC, NcC, DistC)</l>
<l>gen_contour_polygon_xld (ContourC, [RowBeginC,RowEndC], [ColBeginC,ColEndC])</l>
<c>*记录C线的角度</c>
<l>line_orientation (RowBeginC, ColBeginC, RowEndC, ColEndC, PhiC)</l>
<c></c>
<c></c>
<c>* align right and bottom</c>
<l>mirror_image (ImageBottom, ImageBMirror, 'column')</l>
<l>scale_image_max (ImageBMirror, ImageBScaleMax)</l>
<l>scale_image_max (ImageRight, ImageRScaleMax)</l>
<c></c>
<l>gen_rectangle1 (ROI_0, 149.739, 505.08, 269.037, 1444.67)</l>
<l>reduce_domain (ImageRScaleMax, ROI_0, ImageReduced)</l>
<l>create_shape_model (ImageReduced, 'auto', -0.39, 0.79, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID)</l>
<c></c>
<l>find_shape_model (ImageRScaleMax,ModelID, -0.39, 0.79, 0.5, 1, 0.5, 'least_squares', 0, 0.9, RowRight, ColumnRight, Angle, Score)</l>
<l>find_shape_model (ImageBScaleMax,ModelID, -0.39, 0.79, 0.2, 1, 0.5, 'least_squares', 0, 0.9, RowB, ColumnB, Angle, Score)</l>
<c></c>
<l>vector_angle_to_rigid (RowB, ColumnB, 0, RowRight, ColumnRight, 0, HomMat2D)</l>
<l>affine_trans_image (ImageBScaleMax, ImageBottomAligned, HomMat2D, 'constant', 'false')</l>
<c></c>
<c>* Visualize alignment quality</c>
<l>Visualize := 0</l>
<l>if(Visualize)</l>
<l>    GenAlignVisualImage (ImageLeftAligned, ImageRight, MultiChannelImageLR)</l>
<l>    GenAlignVisualImage (ImageRScaleMax, ImageBottomAligned,MultiChannelImageBR)</l>
<l>    dev_display (ImageRight)</l>
<l>    dev_display (lineRegionB)</l>
<l>    dev_display(ContourC)</l>
<l>    stop ()</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="I40AlignAllAndGetBaseLines">
<parameters>
<parameter id="ColBeginB"/>
<parameter id="ColBeginC"/>
<parameter id="ColEndB"/>
<parameter id="ColEndC"/>
<parameter id="ImageBottom"/>
<parameter id="ImageBottomAligned"/>
<parameter id="ImageLeft"/>
<parameter id="ImageLeftAligned"/>
<parameter id="ImageRight"/>
<parameter id="MultiChannelImageBR"/>
<parameter id="MultiChannelImageLR"/>
<parameter id="RowBeginB"/>
<parameter id="RowBeginC"/>
<parameter id="RowEndB"/>
<parameter id="RowEndC"/>
<parameter id="ShapeModelHandel"/>
</parameters>
</docu>
</procedure>
<procedure name="GenAlignVisualImage">
<interface>
<io>
<par name="ImageLeftAligned" base_type="iconic" dimension="0"/>
<par name="ImageRight" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="MultiChannelImage" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>get_image_size (ImageRight, Width, Height)</l>
<l>scale_image_max (ImageLeftAligned, ImageScaleMax)</l>
<l>scale_image_max (ImageRight, ImageScaleMax1)</l>
<l>gen_image_const (Image, 'byte', Width, Height)</l>
<l>compose3 (Image, ImageScaleMax, ImageScaleMax1, MultiChannelImage)</l>
<l>return ()</l>
</body>
<docu id="GenAlignVisualImage">
<parameters>
<parameter id="ImageLeftAligned"/>
<parameter id="ImageRight"/>
<parameter id="MultiChannelImage"/>
</parameters>
</docu>
</procedure>
<procedure name="SelectContoursXValue">
<interface>
<io>
<par name="Contours" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Percent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Value" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>GetContoursPoints (Contours, Xs, Ys)</l>
<l>tuple_sort (Xs, Sorted)</l>
<l>selectedIndex := Percent * |Xs|</l>
<l>tuple_int (selectedIndex, Int)</l>
<c></c>
<l>Value := Sorted[Int]</l>
<c></c>
<l>return ()</l>
</body>
<docu id="SelectContoursXValue">
<abstract lang="en_US">Sort all contour points in x direction and pick the lowest persent value</abstract>
<parameters>
<parameter id="Contours"/>
<parameter id="Percent"/>
<parameter id="Value"/>
</parameters>
</docu>
</procedure>
<procedure name="I40LeftScannerAlign">
<interface>
<io>
<par name="ImageRight" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ShapeModelHandel" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowCenter" base_type="ctrl" dimension="0"/>
<par name="ColCenter" base_type="ctrl" dimension="0"/>
<par name="RowEnd" base_type="ctrl" dimension="0"/>
<par name="ColEnd" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>find_shape_model (ImageRight,ShapeModelHandel, -0.39, 0.79, 0.2, 1, 0.5, 'least_squares', 0, 0.9, RowMdel, ColumnModel, Angle, Score)</l>
<c></c>
<c>* 获取中央水平线</c>
<l>rowHLine := RowMdel + 140</l>
<l>colHline := ColumnModel</l>
<l>gen_rectangle2 (ROI_HLine, rowHLine, colHline, rad(90), 20.8478, 366.834)</l>
<l>ScaleToByte (ImageRight, ROI_HLine, ByteImage)</l>
<l>threshold (ByteImage, Region1, 100, 255)</l>
<l>fill_up (Region1, RegionFillUp)</l>
<l>gen_contour_region_xld (RegionFillUp, Contours, 'border')</l>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines', 5, 4, 2)</l>
<l>select_contours_xld (ContoursSplit, SelectedContours, 'contour_length', 200, 9999, -0.5, 0.5)</l>
<l>sort_contours_xld (SelectedContours, SortedContours, 'upper_left', 'true', 'row')</l>
<l>select_obj (SortedContours, ObjectSelected, 1)</l>
<l>fit_line_contour_xld (ObjectSelected, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<c></c>
<c>* 以中央水平线为粗基准构建上下ROI</c>
<l>gen_rectangle2 (ROI_0, rowHLine - 150, colHline, rad(-90), 56.3662, 480.108)</l>
<l>gen_rectangle2 (ROI_1, rowHLine + 150, colHline, rad(-90), 56.3662, 363.272)</l>
<c></c>
<l>union2 (ROI_0, ROI_1, RegionUnion)</l>
<l>reduce_domain (ImageRight, RegionUnion, ImageReduced)</l>
<c></c>
<l>threshold (ImageReduced, Region, 0, 2)</l>
<c></c>
<l>area_center (Region, Area, Row, Column)</l>
<l>get_perpendicular_line_that_passes (ColBegin, RowBegin, ColEnd, RowEnd, Column, Row, lineXPerpendicular, lineYPerpendicular)</l>
<l>intersection_lines (Row, Column, lineYPerpendicular, lineXPerpendicular, RowBegin, ColBegin, RowEnd, ColEnd, RowCenter, ColCenter, IsOverlapping)</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="I40LeftScannerAlign">
<parameters>
<parameter id="ColCenter"/>
<parameter id="ColEnd"/>
<parameter id="ImageRight"/>
<parameter id="RowCenter"/>
<parameter id="RowEnd"/>
<parameter id="ShapeModelHandel"/>
</parameters>
</docu>
</procedure>
<procedure name="FilterAndGetPointValue">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="KernelSize" base_type="ctrl" dimension="0"/>
<par name="X" base_type="ctrl" dimension="0"/>
<par name="Y" base_type="ctrl" dimension="0"/>
<par name="TrimPercent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="GrayValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>halfWidth := (KernelSize - 1) / 2</l>
<c></c>
<c>* determind the rectangle region to smooth</c>
<l>gen_rectangle1 (Rectangle, Y - halfWidth, X - halfWidth, Y + halfWidth, X + halfWidth)</l>
<l>get_region_points (Rectangle, Rows, Columns)</l>
<l>get_grayval (Image, Rows, Columns, GrayvalOrgin)</l>
<l>tuple_sort (GrayvalOrgin, Sorted)</l>
<l>numPoints := |Sorted|</l>
<l>tuple_int (numPoints * TrimPercent, low)</l>
<l>tuple_int (numPoints * (1-TrimPercent), high)</l>
<l>tuple_select_range (Sorted, low, high, Grayval)</l>
<c></c>
<l>tuple_median (Grayval, GrayValue)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="FilterAndGetPointValue">
<parameters>
<parameter id="GrayValue">
<sem_type>real</sem_type>
</parameter>
<parameter id="Image"/>
<parameter id="KernelSize">
<sem_type>integer</sem_type>
</parameter>
<parameter id="TrimPercent">
<sem_type>real</sem_type>
</parameter>
<parameter id="X">
<sem_type>integer</sem_type>
</parameter>
<parameter id="Y">
<sem_type>integer</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="DWQ_I40GetBaseLine">
<interface>
<io>
<par name="ProfileImageTLW" base_type="iconic" dimension="0"/>
<par name="ProfileImageTRW" base_type="iconic" dimension="0"/>
<par name="ProfileImageBW" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageB" base_type="iconic" dimension="0"/>
<par name="ImageLeftAligned" base_type="iconic" dimension="0"/>
<par name="ImageRotateNewTRW" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="RowB" base_type="ctrl" dimension="0"/>
<par name="ColB" base_type="ctrl" dimension="0"/>
<par name="RowC" base_type="ctrl" dimension="0"/>
<par name="ColC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>convert_image_type (ProfileImageTLW, ImageTLWConverted, 'int4')</l>
<l>scale_image (ImageTLWConverted, ImageTLWScaled, 1, -32768)</l>
<l>scale_image (ImageTLWScaled, ImageTLWScaled, 1.6, 0)</l>
<l>* get_image_size (ImageTLWScaled, WidthPITLW, HeightPITLW)</l>
<l>* gen_image_const (ImageNewTempTLW, 'int4', WidthPITLW, HeightPITLW)</l>
<l>* for Index := 0 to HeightPITLW-1 by 1</l>
<l>*     get_grayval (ImageTLWScaled, gen_tuple_const(WidthPITLW,Index), [0:WidthPITLW-1], grayValuePITLWBefore)</l>
<l>*     grayValuePITLW := grayValuePITLWBefore[0:WidthPITLW-1]-([0:WidthPITLW-1]*kTL+bTL)</l>
<l>*     set_grayval (ImageNewTempTLW, gen_tuple_const(WidthPITLW,Index), [0:WidthPITLW-1], grayValuePITLW)</l>
<l>* endfor</l>
<l>mirror_image (ImageTLWScaled, ImageNewTLWMirror, 'column')</l>
<l>convert_image_type (ImageNewTLWMirror, ImageNewTLW, 'int2')</l>
<c></c>
<c></c>
<l>convert_image_type (ProfileImageTRW, ImagePITRWConverted, 'int4')</l>
<l>scale_image (ImagePITRWConverted, ImageTRWScaled, 1, -32768)</l>
<l>scale_image (ImageTRWScaled, ImageTRWScaled, 1.6, 400)</l>
<l>* get_image_size (ImageTRWScaled, WidthPITRW, HeightPITRW)</l>
<l>* gen_image_const (ImageNewTempTRW, 'int4', WidthPITRW, HeightPITRW)</l>
<l>* for Index := 0 to HeightPITRW-1 by 1</l>
<l>*     get_grayval (ImageTRWScaled, gen_tuple_const(WidthPITRW,Index), [0:WidthPITRW-1], grayValuePITRWBefore)</l>
<l>*     grayValuePITRW := grayValuePITRWBefore[0:WidthPITRW-1]-([0:WidthPITRW-1]*kTR+bTR)</l>
<l>*     set_grayval (ImageNewTempTRW, gen_tuple_const(WidthPITRW,Index), [0:WidthPITRW-1], grayValuePITRW)</l>
<l>* endfor</l>
<l>convert_image_type (ImageTRWScaled, ImageNewTRWMirror, 'int2')</l>
<l>mirror_image (ImageNewTRWMirror, ImageNewTRW, 'column')</l>
<l>rotate_image (ImageNewTRW, ImageRotateNewTRW, 90, 'constant')</l>
<c></c>
<l>convert_image_type (ProfileImageBW, ImageBWConverted, 'int4')</l>
<l>scale_image (ImageBWConverted, ImageBWScaled, 1, -32768)</l>
<l>scale_image (ImageBWScaled, ImageBWScaled, 1.6, 0)</l>
<l>* get_image_size (ImageBWScaled, WidthB, HeightB)</l>
<l>* gen_image_const (ImageNewTempBW, 'int4', WidthB, HeightB)</l>
<l>* for Index := 0 to HeightB-1 by 1</l>
<l>*     get_grayval (ImageBWScaled, gen_tuple_const(WidthB,Index), [0:WidthB-1], grayValueBefore)</l>
<l>*     grayValue := grayValueBefore[0:WidthB-1]-([0:WidthB-1]*kB+bB)</l>
<l>*     set_grayval (ImageNewTempBW, gen_tuple_const(WidthB,Index), [0:WidthB-1], grayValue)</l>
<l>* endfor</l>
<l>mirror_image (ImageBWScaled, ImageNewBWMirror, 'column')</l>
<l>convert_image_type (ImageNewBWMirror, ImageNewBW, 'int2')</l>
<c></c>
<c>* **********************合并上面两张图</c>
<c></c>
<l>* dev_update_on ()</l>
<c>* 读取TL图，并转换成8位图</c>
<l>mirror_image (ProfileImageTLW, ImageTLWMirror, 'column')</l>
<l>convert_image_type (ImageTLWMirror, ImageTLWToByte, 'byte')</l>
<c>* 读取TR图，镜像并转换成8位图</c>
<l>mirror_image (ProfileImageTRW, ImageTRWMirror, 'column')</l>
<l>convert_image_type (ImageTRWMirror, ImageTRWToByte, 'byte')</l>
<c>* 创建模板</c>
<c></c>
<l>gen_rectangle1 (ROI_0, 160, 522.637, 280, 1419.89)</l>
<l>reduce_domain (ImageTRWToByte, ROI_0, ImageReducedMS)</l>
<l>inspect_shape_model (ImageReducedMS, ModelImages, ModelRegions, 4, 50)</l>
<l>create_shape_model (ImageReducedMS, 4, -0.39, 0.79, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID)</l>
<c>* 找模板，找旋转中心</c>
<l>find_shape_model (ImageTRWToByte, ModelID, -1, 1, 0.5, 1, 0.5, 'least_squares', 2, 0.9, RowTR, ColumnTR, AngleTR, ScoreTR)</l>
<l>dev_display (ImageTRWToByte)</l>
<l>dev_display_shape_matching_results (ModelID, 'red', RowTR, ColumnTR, AngleTR, 1, 1, 0)</l>
<l>find_shape_model (ImageTLWToByte, ModelID, -1, 1, 0.3, 1, 0.5, 'least_squares', 2, 0.9, RowTL, ColumnTL, AngleTL, ScoreTL)</l>
<l>dev_display (ImageTLWToByte)</l>
<l>dev_display_shape_matching_results (ModelID, 'red', RowTL, ColumnTL, AngleTL, 1, 1, 0)</l>
<c>* 旋转TL矫正镜像图片照片</c>
<l>vector_angle_to_rigid (RowTL, ColumnTL, AngleTL, RowTR, ColumnTR, AngleTR, HomMat2D)</l>
<l>affine_trans_image (ImageNewTLW, ImageNewTLWAffineTrans, HomMat2D, 'constant', 'false')</l>
<l>rotate_image (ImageNewTLWAffineTrans, ImageLeftAligned, 90, 'constant')</l>
<c></c>
<l>threshold (ImageNewTRW, Region1, -128000, -25500)</l>
<l>connection (Region1, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 99577.5, 200000)</l>
<l>dilation_circle (SelectedRegions1, RegionDilation, 11)</l>
<l>union1 (RegionDilation, RegionUnion)</l>
<l>reduce_domain (ImageNewTLWAffineTrans, RegionUnion, ImageReduced1)</l>
<l>paint_gray (ImageReduced1, ImageNewTRW, ImageMax)</l>
<c>* 图片叠</c>
<l>* max_image (ImageNewTRW, ImageNewTLWAffineTrans, ImageMax)</l>
<l>rotate_image (ImageMax, ImageUP, 90, 'constant')</l>
<c>* 底面旋转到检测位置</c>
<l>convert_image_type (ProfileImageBW, ImageBWConverted, 'byte')</l>
<l>mirror_image (ImageBWConverted, ImageBWMirror, 'column')</l>
<l>find_shape_model (ImageBWMirror, ModelID, -1, 1, 0.2, 1, 0.5, 'least_squares', 2, 0.9, RowB, ColumnB, AngleB, Score2)</l>
<l>dev_display (ImageBWMirror)</l>
<l>dev_display_shape_matching_results (ModelID, 'red', RowB, ColumnB, AngleB, 1, 1, 0)</l>
<l>vector_angle_to_rigid (RowB, ColumnB, AngleB, RowTR, ColumnTR, AngleTR, HomMat2D)</l>
<l>affine_trans_image (ImageNewBW, ImageNewBWAffines, HomMat2D, 'constant', 'false')</l>
<l>rotate_image (ImageNewBWAffines, ImageB, 90, 'constant')</l>
<l>threshold (ImageB, Region, -1280, 255)</l>
<c></c>
<c>* ********************FAI16-1检测***************************</c>
<c>* 创建模板</c>
<c></c>
<l>gen_rectangle1 (ROI_0, 160, 500, 280, 1425)</l>
<l>reduce_domain (ImageTRWToByte, ROI_0, ImageReducedMS)</l>
<l>inspect_shape_model (ImageReducedMS, ModelImages, ModelRegions, 4, 50)</l>
<l>create_shape_model (ImageReducedMS, 4, -0.39, 0.79, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID)</l>
<c>* 找模板，找旋转中心</c>
<l>find_shape_model (ImageTRWToByte, ModelID, -1, 1, 0.5, 1, 0.5, 'least_squares', 2, 0.9, RowTR, ColumnTR, AngleTR, ScoreTR)</l>
<l>dev_display (ImageTRWToByte)</l>
<l>dev_display_shape_matching_results (ModelID, 'red', RowTR, ColumnTR, AngleTR, 1, 1, 0)</l>
<l>find_shape_model (ImageTLWToByte, ModelID, -1, 1, 0.3, 1, 0.5, 'least_squares', 2, 0.9, RowTL, ColumnTL, AngleTL, ScoreTL)</l>
<l>dev_display (ImageTLWToByte)</l>
<l>dev_display_shape_matching_results (ModelID, 'red', RowTL, ColumnTL, AngleTL, 1, 1, 0)</l>
<c>* 旋转TL矫正镜像图片照片</c>
<l>vector_angle_to_rigid (RowTL, ColumnTL, AngleTL, RowTR, ColumnTR, AngleTR, HomMat2D)</l>
<l>affine_trans_image (ImageNewTLW, ImageNewTLW, HomMat2D, 'constant', 'false')</l>
<l>threshold (ImageNewTRW, Region1, -128000, -25500)</l>
<l>fill_up_shape (Region1, RegionFillUp, 'area', 1, 100)</l>
<l>opening_circle (RegionFillUp, RegionOpening1, 9)</l>
<c></c>
<l>connection (RegionOpening1, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 99577.5, 200000)</l>
<l>dilation_circle (SelectedRegions1, RegionDilation, 7)</l>
<l>union1 (RegionDilation, RegionUnion)</l>
<l>reduce_domain (ImageNewTLW, RegionUnion, ImageReduced1)</l>
<l>paint_gray (ImageReduced1, ImageNewTRW, ImageMax)</l>
<c>* 图片叠加取最大值</c>
<l>rotate_image (ImageMax, ImageUP, 90, 'constant')</l>
<c>* 底面旋转到检测位置</c>
<l>convert_image_type (ProfileImageBW, ImageBWConverted, 'byte')</l>
<l>mirror_image (ImageBWConverted, ImageBWMirror, 'column')</l>
<l>find_shape_model (ImageBWMirror, ModelID, -1, 1, 0.2, 1, 0.5, 'least_squares', 2, 0.9, RowB, ColumnB, AngleB, Score2)</l>
<l>dev_display (ImageBWMirror)</l>
<l>dev_display_shape_matching_results (ModelID, 'red', RowB, ColumnB, AngleB, 1, 1, 0)</l>
<l>vector_angle_to_rigid (RowB, ColumnB, AngleB, RowTR, ColumnTR, AngleTR, HomMat2D)</l>
<l>affine_trans_image (ImageNewBW, ImageNewBWAffines, HomMat2D, 'constant', 'false')</l>
<l>rotate_image (ImageNewBWAffines, ImageB, 90, 'constant')</l>
<l>threshold (ImageB, Region, -1280, 255)</l>
<c></c>
<c>* 找初级准线</c>
<l>rotate_image (ImageTRWToByte, ImageTRWToByteRotate, 90, 'constant')</l>
<l>gen_rectangle1 (ROI_0, 191.697, 152.539, 1108.33, 269.822)</l>
<l>reduce_domain (ImageTRWToByteRotate, ROI_0, ImageReduced2)</l>
<l>create_shape_model (ImageReduced2, 'auto', -0.39, 0.79, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelIDL)</l>
<l>find_shape_model (ImageTRWToByteRotate, ModelIDL, -0.5, 0.5, 0.5, 1, 0.5, 'least_squares', 0, 0.9, RowL, ColumnL, AngleL, ScoreL)</l>
<l>a := 1208-RowL+558</l>
<l>b := 302-ColumnL+90.5</l>
<c></c>
<l>gen_rectangle1 (ROI_0, RowL-260, ColumnL+158.5, RowL+270, ColumnL+178.5)</l>
<l>reduce_domain (ImageRotateNewTRW, ROI_0, ImageReduced)</l>
<l>threshold (ImageReduced, RegionStd, -2050, 4095)</l>
<l>opening_rectangle1 (RegionStd, RegionOpeningStd, 1, 3)</l>
<c></c>
<l>boundary (RegionOpeningStd, RegionBorderStd, 'inner')</l>
<l>gen_contour_region_xld (RegionBorderStd, ContourStds, 'border')</l>
<l>segment_contours_xld (ContourStds, ContourStdsSplit, 'lines', 5, 1, 1)</l>
<l>select_contours_xld (ContourStdsSplit, SelectedContourStds, 'contour_length', 20, 2000, -0.5, 0.5)</l>
<l>union_collinear_contours_ext_xld (SelectedContourStds, UnionContourStds, 200, 3, 3, 0.1, 0, -1, 1, 1, 1, 1, 1, 0, 'attr_keep')</l>
<l>sort_contours_xld (UnionContourStds, SortedContourStds, 'character', 'true', 'row')</l>
<l>select_obj (SortedContourStds, ObjectSelectedStd, 1)</l>
<l>union_collinear_contours_xld (ObjectSelectedStd, UnionStdontoursStd1, 1000, 20, 20, 0.5, 'attr_keep')</l>
<l>fit_line_contour_xld (UnionStdontoursStd1, 'drop', -1, 2, 5, 1, RowBeginStd, ColBeginStd, RowEndStd, ColEndStd, NrC, NcC, DistC)</l>
<l>gen_contour_polygon_xld (ContourStd, [RowBeginStd,RowEndStd], [ColBeginStd,ColEndStd])</l>
<c></c>
<l>line_orientation (RowBeginStd, ColBeginStd, RowEndStd, ColEndStd, PhiStd)</l>
<c></c>
<c>* 生成基准垂线</c>
<c></c>
<l>RowM := (RowBeginStd+RowEndStd)/2</l>
<l>ColM := (ColBeginStd+ColEndStd)/2</l>
<c>* ********************生成垂线**************************垂线长度</c>
<l>LineLength := 200</l>
<c>* 起点</c>
<l>RowStartV := RowM-cos(PhiStd)*LineLength</l>
<l>ColStartV := ColM-sin(PhiStd)*LineLength</l>
<c>* 终点</c>
<l>RowEndV := RowM+cos(PhiStd)*LineLength</l>
<l>ColEndV := ColM+sin(PhiStd)</l>
<c>* LineLength</c>
<l>line_orientation (RowStartV, RowStartV, RowEndV, ColEndV, PhiV)</l>
<l>gen_contour_polygon_xld (ContourV, [RowStartV,RowEndV], [ColStartV,ColEndV])</l>
<c></c>
<c>* ********************FAI16-1检测***************************</c>
<c>* 生成第一条线,左边起</c>
<l>gen_rectangle1 (ROI_1, 195, 170, 1100, 250)</l>
<l>reduce_domain (ImageTRWToByteRotate, ROI_1, ImageReducedMS1)</l>
<l>inspect_shape_model (ImageReducedMS1, ModelImages, ModelRegions, 4, 50)</l>
<l>create_shape_model (ImageReducedMS1, 4, -0.39, 0.79, 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID)</l>
<c>* 找模板，找旋转中心</c>
<l>find_shape_model (ImageTRWToByteRotate, ModelID, -1, 1, 0.5, 1, 0.5, 'least_squares', 2, 0.9, RowTR, ColumnTR, AngleTR, ScoreTR)</l>
<l>dev_display (ImageTRWToByteRotate)</l>
<l>dev_display_shape_matching_results (ModelID, 'red', RowTR, ColumnTR, AngleTR, 1, 1, 0)</l>
<c></c>
<l>* dev_get_window (WindowHandle1)</l>
<l>* draw_rectangle1 (WindowHandle1, Row11, Column11, Row2, Column2)</l>
<l>* gen_rectangle1 (RectangleB1, 1183, 112, 1203, 135)</l>
<l>* gen_rectangle1 (RectangleB2, 1183, 312, 1203, 331)</l>
<l>* union2 (RectangleB1, RectangleB2, ROIB)</l>
<l>* reduce_domain (ImageRotateNewTRW, ROIB, ImageReducedB)</l>
<l>* scale_image (ImageReducedB, ImageScaledReducedB, 5, 0)</l>
<l>* threshold (ImageScaledReducedB, RegionB, -9000, 100000)</l>
<l>* closing_rectangle1 (RegionB, RegionClosing, 5, 1)</l>
<l>* opening_rectangle1 (RegionClosing, RegionOpening, 3, 1)</l>
<c></c>
<l>* connection (RegionOpening, ConnectedRegions)</l>
<l>* select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 150, 99999)</l>
<l>* boundary (SelectedRegions, RegionBorderB, 'inner')</l>
<c></c>
<l>* skeleton (RegionBorderB, Skeleton)</l>
<l>* gen_contours_skeleton_xld (Skeleton, Contours, 5, 'generalize1')</l>
<l>* segment_contours_xld (Contours, ContoursSplit, 'lines', 1, 1, 1)</l>
<c></c>
<l>* select_contours_xld (ContoursSplit, SelectedContours1, 'direction', -1, 1, -0.5, 0.5)</l>
<l>* union_adjacent_contours_xld (SelectedContours1, UnionContours, 10, 1, 'attr_keep')</l>
<l>* select_contours_xld (UnionContours, SelectedContours, 'contour_length', 5, 200, -0.5, 0.5)</l>
<c></c>
<l>* rowBs := []</l>
<l>* colBs := []</l>
<l>* sort_contours_xld (SelectedContours, SortedContours, 'character', 'true', 'row')</l>
<l>* select_obj (SortedContours, ObjectSelected1, 3)</l>
<l>* get_contour_xld (ObjectSelected1, Row1, Col1)</l>
<l>* tuple_select_range (Row1, 2, |Row1|-2, Row1)</l>
<l>* tuple_select_range (Col1, 2, |Col1|-2, Col1)</l>
<l>* select_obj (SortedContours, ObjectSelected1, 4)</l>
<l>* get_contour_xld (ObjectSelected1, Row2, Col2)</l>
<l>* tuple_select_range (Row2, 2, |Row2|-2, Row2)</l>
<l>* tuple_select_range (Col2, 2, |Col2|-2, Col2)</l>
<l>* rowBs := [Row1,Row2]</l>
<l>* colBs := [Col1,Col2]</l>
<c></c>
<c></c>
<c>* 点到直线的距离</c>
<l>* distance_pl (rowBs, colBs, RowStartV, RowStartV, RowEndV, ColEndV, DistanceB)</l>
<l>* tuple_mean (DistanceB, MeanDistanceB)</l>
<l>* tuple_sub (DistanceB, MeanDistanceB, DiffDistanceB)</l>
<l>* tuple_abs (DiffDistanceB, DiffDistanceBAbs)</l>
<l>* tuple_div (DiffDistanceBAbs, 0.5, DiffDistanceBAbsDiv)</l>
<l>* for Index1 := 0 to |DiffDistanceBAbsDiv|-1 by 1</l>
<l>*     if (DiffDistanceBAbsDiv[Index1]&lt;1)</l>
<l>*         DiffDistanceBAbsDiv[Index1] := 0</l>
<l>*     else</l>
<l>*         DiffDistanceBAbsDiv[Index1] := 1</l>
<l>*     endif</l>
<l>* endfor</l>
<l>* tuple_and (DiffDistanceBAbsDiv, 1, DiffDistanceBAbsDivAnd)</l>
<l>* tuple_find (DiffDistanceBAbsDiv, 0, Indices)</l>
<l>* tuple_remove (rowBs, Indices, ReducedrowBs)</l>
<l>* tuple_remove (colBs, Indices, ReducedcolBs)</l>
<c>* 创建直线B</c>
<l>* gen_contour_polygon_xld (ContourB, rowBs, colBs)</l>
<l>* fit_line_contour_xld (ContourB, 'drop', -1, 4, 5, 1, RowBeginB, ColBeginB, RowEndB, ColEndB, NrB, NcB, Dist)</l>
<l>* gen_contour_polygon_xld (OrginLineB, [RowBeginB,RowEndB], [ColBeginB,ColEndB])</l>
<c>* 记录B线的角度</c>
<l>* line_orientation (RowBeginB, ColBeginB, RowEndB, ColEndB, RowB)</l>
<l>* vector_angle_to_rigid ((RowBeginB+RowEndB)/2, (ColBeginB+ColEndB)/2, RowB, (RowBeginB+RowEndB)/2, (ColBeginB+ColEndB)/2, PhiStd-rad(90), HomMat2DB)</l>
<l>* affine_trans_contour_xld (OrginLineB, LineB, HomMat2DB)</l>
<l>* get_contour_xld (LineB, RowB, ColB)</l>
<l>* orientation_xld (LineB, PhiBB)</l>
<l>* fwrite_string (FileHandleB, PhiBB)</l>
<l>* fnew_line (FileHandleB)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>* 生成第一条线</c>
<c></c>
<l>gen_rectangle1 (ROI_B, RowL+535, ColumnL-101.5, RowL+558, ColumnL+90.5)</l>
<c></c>
<l>reduce_domain (ImageUP, ROI_B, ImageReducedB)</l>
<l>threshold (ImageReducedB, RegionB, -2200, -1700)</l>
<l>closing_rectangle1 (RegionB, RegionBlosing2, 35, 1)</l>
<l>boundary (RegionBlosing2, RegionBorderB, 'inner')</l>
<l>gen_contour_region_xld (RegionBorderB, ContourBs, 'border')</l>
<l>segment_contours_xld (ContourBs, ContourBsSplit, 'lines', 5, 1, 1)</l>
<l>select_contours_xld (ContourBsSplit, SelectedContourBs, 'contour_length', 30, 2000, -0.5, 0.5)</l>
<l>union_collinear_contours_xld (SelectedContourBs, UnionContourBs, 100, 5, 5, 0.5, 'attr_keep')</l>
<l>sort_contours_xld (UnionContourBs, SortedContourBs, 'character', 'true', 'row')</l>
<l>select_obj (SortedContourBs, ObjectSelectedB, 2)</l>
<l>union_collinear_contours_xld (ObjectSelectedB, UnionContours1, 1000, 20, 20, 0.5, 'attr_keep')</l>
<l>fit_line_contour_xld (UnionContours1, 'drop', -1, 0, 5, 1, RowBeginB, ColBeginB, RowEndB, ColEndB, NrC, NcC, DistC)</l>
<l>gen_contour_polygon_xld (OrginLineB, [RowBeginB,RowEndB], [ColBeginB,ColEndB])</l>
<c>* 记录B线的角度</c>
<l>line_orientation (RowBeginB, ColBeginB, RowEndB, ColEndB, RowB)</l>
<c></c>
<l>vector_angle_to_rigid ((RowBeginB+RowEndB)/2, (ColBeginB+ColEndB)/2, RowB, (RowBeginB+RowEndB)/2, (ColBeginB+ColEndB)/2, PhiStd-rad(90), HomMat2DB)</l>
<l>affine_trans_contour_xld (OrginLineB, LineB, HomMat2DB)</l>
<l>get_contour_xld (LineB, RowB, ColB)</l>
<l>orientation_xld (LineB, PhiBB)</l>
<c></c>
<c>* 生成第二条线</c>
<l>gen_rectangle1 (ROI_C, RowL-270, ColumnL+485, RowL+270, ColumnL+495)</l>
<c></c>
<l>reduce_domain (ImageUP, ROI_C, ImageReducedC)</l>
<l>threshold (ImageReducedC, RegionC, -2200, -600)</l>
<l>closing_rectangle1 (RegionC, RegionClosing2, 1, 5)</l>
<l>boundary (RegionClosing2, RegionBorderC, 'inner')</l>
<l>gen_contour_region_xld (RegionBorderC, ContourCs, 'border')</l>
<l>segment_contours_xld (ContourCs, ContourCsSplit, 'lines', 5, 1, 1)</l>
<l>select_contours_xld (ContourCsSplit, SelectedContourCs, 'contour_length', 20, 2000, -0.5, 0.5)</l>
<l>union_collinear_contours_xld (SelectedContourCs, UnionContourCs, 100, 10, 10, 0.5, 'attr_keep')</l>
<l>sort_contours_xld (UnionContourCs, SortedContourCs, 'character', 'true', 'row')</l>
<l>select_obj (SortedContourCs, ObjectSelectedC, 2)</l>
<l>union_collinear_contours_xld (ObjectSelectedC, UnionContours1, 1000, 20, 20, 0.5, 'attr_keep')</l>
<l>fit_line_contour_xld (UnionContours1, 'drop', -1, 0, 5, 1, RowBeginC, ColBeginC, RowEndC, ColEndC, NrC, NcC, DistC)</l>
<l>gen_contour_polygon_xld (OrginLineC, [RowBeginC,RowEndC], [ColBeginC,ColEndC])</l>
<c>* 记录B线的角度</c>
<l>line_orientation (RowBeginC, ColBeginC, RowEndC, ColEndC, PhiC)</l>
<c></c>
<l>vector_angle_to_rigid ((RowBeginC+RowEndC)/2, (ColBeginC+ColEndC)/2, PhiC, (RowBeginC+RowEndC)/2, (ColBeginC+ColEndC)/2, PhiStd, HomMat2DC)</l>
<l>affine_trans_contour_xld (OrginLineC, LineC, HomMat2DC)</l>
<l>get_contour_xld (LineC, RowC, ColC)</l>
<l>orientation_xld (LineC, PhiCC)</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="DWQ_I40GetBaseLine">
<parameters>
<parameter id="ColB"/>
<parameter id="ColC"/>
<parameter id="ImageB"/>
<parameter id="ImageLeftAligned"/>
<parameter id="ImageRotateNewTRW"/>
<parameter id="ProfileImageBW"/>
<parameter id="ProfileImageTLW"/>
<parameter id="ProfileImageTRW"/>
<parameter id="RowB"/>
<parameter id="RowC"/>
</parameters>
</docu>
</procedure>
</hdevelop>
